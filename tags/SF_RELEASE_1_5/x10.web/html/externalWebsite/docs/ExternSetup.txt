This document explains the mechanics behind support of the x10 'extern' keyword.

Simple usage of the keyword looks like:

class C {
  public static extern void foo();
  public static extern long doit(int x);
  public static extern long doit(float f,int i);
  static { System.loadLibrary("CexternLib"); }
};

This assumes that a shared library named "CexternLib" with the Java native
library naming conventions ("libCexternLib.so" on Unix, "CexternLib.dll" on
Windows) will be produced from the generated C code.

The methods will then be invoked as

  ...
  C.foo();          //-- (1)
  x = C.doit(12);   //-- (2)
  float f = ...
  y = C.doit(f,11); //-- (3)
  
  
in some X10 program.  At the call points, the user will expect that a C routine with the
format <ContainingClass> "_" <methodName> will be called  ie for foo, a C routine
C_foo(void) would be called.  The "-libpath" x10 option should be used to point
the X10 runtime at the libraries (e.g., "x10 -libpath . X10Prog" if the libraries
are in the current working directory).
  
The Java specification does not say what happens with overloaded methods, so we've taken the
JNI approach of adding a suffix "__"+<signature> ie two '_' characters and a string
of characters, one for each parameter, the mapping being the same as in JNI (e.g. V = void, J = long
F = float, I= int etc).
  
So, for the two overloaded methods doit, we'd expect
  C_doit__I
and
  C_doit__FI
  
The x10 compiler will produce C files with a suffix "_x10stub.c" for each of the classes containing
an extern declaration.  These will contain the JNI calls wrapping the C calls the user expects.
Within the X10 program, the java equivalent would create wrappers, and look like:

--- java program---
class C {
  public static native void C_foo();
  public static native long C_doit(int x);
  public static native long C_doit(float f,int i);
  public static  void foo() { C_foo();}
  public static  long doit(int x){ return C_doit(x);}
  public static  long doit(float f,int i){ return C_doit(f,i);}
};
  
A file called C_x10stub.c would be created, and it would look like:
  
---- file begins--- 
/*
* Filename:C_x10stub.c
* Generated: 1/11/05 7:34 PM */
/*Automatically generated -- DO NOT EDIT THIS FILE */
#include <jni.h>
#ifdef __cplusplus
extern "C" {
#endif

/* * * * * * * */
extern void C_foo();
JNIEXPORT void JNICALL
Java_C_C_1foo(JNIEnv *env, jobject obj){
   C_foo()
}

/* * * * * * * */
extern long C_doit__I(int x);
JNIEXPORT jlong JNICALL
Java_C_C_1foo__I(JNIEnv *env, jobject obj,jint x){
   return C_doit__I(x);
}

/* * * * * * * */
extern long C_doit__IF(float f,int i);
JNIEXPORT jlong JNICALL
Java_C_C_1foo__FI(JNIEnv *env, jobject obj,jfloat f ,jint i){
   return C_doit__FI(f,i);
}
#ifdef __cplusplus
}
#endif

--- file ends ---
  
The Java_... methods are what the java JNI framework will call from the JVM, which in turn
will call the user's routine.
The user will have to create a dynamically linked library containing the stub files, and in addition call
System.loadLibrary() to load this library.
  
MORE COMPLICATED ISSUES
-----------------------
There are curerntly two major issues identified when interfacing to native code.  First, 'long'
variables, secondly multiply dimensioned arrays.

Longs:
  Long in java is different from a long in C or C++.  In java, a long is always 64 bits.  In C/C++,
  it's the 'natural' size of the architecture ie could be 32 or 64 bits.  So, on a 32 bit machine,
  passing a long to native code could easily lead to errors.  JNI has the same issue, and we solve
  the problem in the same way: we utilize the JNI typedefs found in jni.h for long, specifically
  jlong, which is typecast to a 64 bit type for all platforms.  Manipulating this value in native
  code may require some work, however, as arithmetic operators may or may not work, depending
  on compiler support.

Arrays:
  The native code must know the layout in memory of any multidimensioned array
  passed from an x10 program.  Single dimension arrays are trivial to traverse,
  however with multiple-dimension arrays, the native code must know whether the
  arrays is row or column major, and the size of the row/column, in order to
  scale the indices correctly.  In X10, all arrays are allocated in row-major
  order ie in C style.
  X10 generates array descriptors to help deal with this issue.  An array
  descriptor consists of an array of integers, where the first element (index 0)
  is the rank (number of dimensions) of the array.  Each subsequent element is
  the size of each dimension, from left to right.  An array descriptor is
  generated for each array passed to a native routine, and is found immediately
  following the argument declaration for the array itself ie if the nth
  argument is an array, a descriptor will be generated as the n+1th, and all
  argument declarations shifted by one.

  Example of usage:
  class X { ...
    final region R= [0:(N+3), 0:(N+1)];
    final distribution D = distribution.factory.block(R);

    ...
    static void extern Initialize(double[.] dbl a);
    ...
    void runit() {
      final double[D] a= new double unsafe[D];
      ...
      Initialize(a);
      ...
    }
  }

  and corresponding C code called by the generated wrapper:

  void X_Initialize(double arrPtr[],int a_descriptor[]) {
    int i,j,rank,innerSize,outerSize;
    rank = a_descriptor[0];

    // Expecting 2-dimensional arrays
    if (rank != 2) {
      printf("Unexpected rank %d != 2\n",rank);
      return;
    }

    outerSize = a_descriptor[1]; //This will be  N+4
    innerSize = a_descriptor[2]; //This will be  N+2
    
    for (i=0;i<outerSize;++i)
      for (j=0;j<innerSize;++j)
        arrPtr[i*innerSize + j] = 0; /* scale by rowSize*/
  }


LIMITATIONS
-----------
Currently extern method names with unicode characters are not handled.
(Igor @Vijay: I think this has been fixed -- please verify).

Only primitive values (ie int, float, double, long, char, byte, short and
boolean) and X10 arrays can be passed into extern methods.  Currently only
primitive values can be returned.

For performance reasons, the actual memory representing X10 arrays is passed to
the extern method, which has two consequences for this release:

1) There is currently no storage protection mechanism for X10 arrays passed to
extern methods, so if the extern method corrupts memory, there can be no
guarantee of the correctness or stability of the X10 program.

2) The X10 VM garbage collector (GC) currently does not support pinning of
objects, and so GC must be suspended during extern calls to avoid moving the
object while possibly being referenced.  In a multi-threaded X10 application, a
long running extern call, or a sequence of parallel extern invocations from
independent threads (whose running times overlap), will essentially prevent GC
from running.  This is an issue if there is a risk of memory exhaustion.

