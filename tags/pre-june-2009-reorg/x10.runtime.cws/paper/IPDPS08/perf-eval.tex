\section{Performance Evaluation}\label{s:results}

We use a collection of sparse graph generators to compare the performance of the different implementations of 
parallel spanning tree graph algorithms. Our generators include several employed in previous
experimental studies of parallel graph algorithms for related
problems. For instance, we include the torus topologies used in the connectivity studies of Greiner
\cite{Gre94}, Krishnamurthy \emph{et al.} \cite{KLC97}, Hsu \emph{et
  al.} \cite{HRD97}, Goddard \emph{et al.} \cite{GKP97}, and Bader and Cong \cite{BC04b}, the
random graphs used by Greiner \cite{Gre94}, Hsu \emph{et al.}  \cite{HRD97}, and Goddard \emph{et
  al.} \cite{GKP97}, the geometric graphs used by
Greiner \cite{Gre94}, Hsu \emph{et al.} \cite{HRD97}, Krishnamurthy
\emph{et al.} \cite{KLC97}, and Goddard \emph{et al.} \cite{GKP97}.

\begin{itemize}
\itemsep0pt

\item \textbf{2D Torus} The vertices of the graph are placed on a 2D
  mesh, with each vertex connected to its four neighbors.  

\item \textbf{Random Graph} We create a random graph of $n$ vertices
  and $m$ edges by randomly adding $m$ unique edges to the vertex
  set. Several software packages generate random graphs this way,
  including LEDA \cite{MN99}.
  
\item \textbf{Geometric Graphs and AD3} In these $k$-regular graphs,
  %$n$ points are chosen uniformly and at random in a unit square in
  %the Cartesian plane, and 
  each vertex is connected to its $k$ %nearest
  neighbors.  Moret and Shapiro \cite{MS94} use these
  in their empirical study of sequential MST algorithms. \textbf{AD3}
  is a geometric graph with $k=3$.  
\end{itemize}


All the C implementations follow the SPMD programming style.  $P$ threads are created, and each of them is assigned a piece of work .  The DFS implemenation balances the workload through a simple, explicit work-stealing scheme as described in \cite{BL94}.  Both the BFS and SV implementaions simply distribute the input array evenly to each processor to work on. 
Ajacency array are used for the input representation in BFS and DFS.  SV simulates the corresponding PRAM algorithm, and uses the edge list representation.
In DFS, mutula-exclusion through atomic instruction is used for synchronization.  BFS and SV employ only barriers, and the barrier implemenation is the usual $O(\log P)$ tree implemenation.

DFS in Cilk use the same input represenation as the C implementation.  Concurrency and synchronization are supported by Cilk runtime and Cilk lock ( an efficient implementation through atomic instructions). 

The performance numbers for handwritten C application and for the
\XWS{} code are given below, for psuedo-depth-first search,
breadth-first search and the Shiloach Vishkin algorithm for spanning
tree (from top to bottom). Numbers are presented for two machines,
altair (containing 4 dual-core Opterons) on the left and moxie, a
32-processor Niagara on the right. The best numbers for ten
consecutive runs are presented.

The Java programs were run using the experimental Java 1.7 release on
both machines. C programs were compiled with Sun cc v 5.8 and Cilk
programs with the 5.3.2 compiler.

The graphs show good scaling for the \XWS{} version of applications on
both machines. In all cases the numbers for \XWS{} are better than
that for the C code at higher processor counts.

Cilk does not perform well for BFS. (We were unable to get a Cilk
version of SV running in time for the submission.) 


\begin{figure}
 \begin{tabular}{ccc}
 \pdfimage width 8cm {altair.dfs.pdf} &
 \pdfimage width 8cm {moxie.dfs.pdf} 
 \end{tabular}
\caption{Psuedo-DFS for altair and moxie}
\end{figure}

\begin{figure}
 \begin{tabular}{ccc}
 \pdfimage width 8cm {altair.bfs.pdf} &
 \pdfimage width 8cm {moxie.bfs.pdf} 
 \end{tabular}
\caption{BFS for altair and moxie}
\end{figure}

\begin{figure}
 \begin{tabular}{ccc}
 \pdfimage width 8cm {altair.sv.pdf} &
 \pdfimage width 8cm {moxie.sv.pdf} 
 \end{tabular}
\caption{SV for altair and moxie}
\end{figure}
