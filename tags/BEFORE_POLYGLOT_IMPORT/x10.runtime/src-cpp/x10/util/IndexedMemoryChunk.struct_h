#ifndef __X10_UTIL_INDEXEDMEMORYCHUNK_STRUCT_H
#define __X10_UTIL_INDEXEDMEMORYCHUNK_STRUCT_H

#include <x10aux/config.h>
#include <x10aux/ref.h>
#include <x10aux/RTT.h>
#include <x10aux/serialization.h>
#include <x10aux/struct_equals.h>

#include <assert.h>

// platform-specific min chunk alignment
#ifdef _POWER
#define X10_MIN_INDEXEDMEMORYCHUNK_ALIGNMENT 16
#else
#define X10_MIN_INDEXEDMEMORYCHUNK_ALIGNMENT ((x10_int)sizeof(x10_double))
#endif

namespace x10 {
    namespace util { 

        template<class T> class IndexedMemoryChunk  {
          public:
            RTT_H_DECLS_STRUCT

            static x10aux::itable_entry _itables[2];
            static x10aux::itable_entry _iboxitables[2];

            x10aux::itable_entry* _getITables() { return _itables; }
            x10aux::itable_entry* _getIBoxITables() { return _iboxitables; }
    
            T* FMGL(data); /* TODO: We would like this to be T* const data */

            IndexedMemoryChunk(): FMGL(data)(NULL) {}
            IndexedMemoryChunk(T* _data): FMGL(data)(_data) {}

            inline T apply(x10_int index) { return FMGL(data)[index]; }
            inline T apply(x10_long index) { return FMGL(data)[index]; }
            
            inline void set(T val, x10_int index) { FMGL(data)[index] = val; }
            inline void set(T val, x10_long index) { FMGL(data)[index] = val; }
    
            x10::util::IndexedMemoryChunk<T>* operator->() { return this; }
        
            static void _serialize(x10::util::IndexedMemoryChunk<T> this_, x10aux::serialization_buffer& buf);
    
            static x10::util::IndexedMemoryChunk<T> _deserialize(x10aux::deserialization_buffer& buf) {
                x10::util::IndexedMemoryChunk<T> this_;
                this_->_deserialize_body(buf);
                return this_;
            }
    
            void _deserialize_body(x10aux::deserialization_buffer& buf);
            
            x10_boolean equals(x10aux::ref<x10::lang::Any>);
    
            x10_boolean equals(x10::util::IndexedMemoryChunk<T>);
    
            x10_boolean _struct_equals(x10aux::ref<x10::lang::Any>);
    
            x10_boolean _struct_equals(x10::util::IndexedMemoryChunk<T>);
    
            x10aux::ref<x10::lang::String> toString();
    
            x10_int hashCode();
        };


        template <> class IndexedMemoryChunk<void> {
          private:
            template<class T> static IndexedMemoryChunk<T> allocInternal(size_t numElements,
                                                                         x10_int alignment,
                                                                         x10_boolean pinned,
                                                                         x10_boolean zeroed);
          public:
            static x10aux::RuntimeType rtt;
            static const x10aux::RuntimeType* getRTT() { return &rtt; }

            template<class T> static IndexedMemoryChunk<T> allocate(x10_int numElements,
                                                                    x10_int alignment,
                                                                    x10_boolean pinned,
                                                                    x10_boolean zeroed) {
                assert(numElements >=0);
                return allocInternal<T>((size_t)numElements, alignment, pinned, zeroed);
            }
            
            template<class T> static IndexedMemoryChunk<T> allocate(x10_long numElements,
                                                                    x10_int alignment,
                                                                    x10_boolean pinned,
                                                                    x10_boolean zeroed) {
                assert(numElements >= 0);
                assert(((x10_long)((size_t)numElements)) == numElements); // check for alloc requests >31 bits on 32 bit system
                return allocInternal<T>((size_t)numElements, alignment, pinned, zeroed);
            }
        };


        template<class T> IndexedMemoryChunk<T> IndexedMemoryChunk<void>::allocInternal(size_t numElements,
                                                                                        x10_int alignment,
                                                                                        x10_boolean pinned, 
                                                                                        x10_boolean zeroed) {
            assert((alignment & (alignment-1)) == 0);
            if (alignment < X10_MIN_INDEXEDMEMORYCHUNK_ALIGNMENT) {
                alignment = X10_MIN_INDEXEDMEMORYCHUNK_ALIGNMENT;
            }

            bool containsPtrs = x10aux::getRTT<T>()->containsPtrs;
            size_t size = alignment + numElements*sizeof(T);
            T* allocMem = x10aux::alloc<T>(size, containsPtrs);
            if (zeroed) {
                memset(allocMem, 0, size);
            }
            size_t alignDelta = alignment-1;
            size_t alignMask = ~alignDelta;
            size_t alignedMem = ((size_t)allocMem + alignDelta) & alignMask;
            return IndexedMemoryChunk<T>((T*)alignedMem);
        }
    }
} 
#endif // X10_UTIL_INDEXEDMEMORYCHUNK_STRUCT_H

