/*
 *
 * (C) Copyright IBM Corporation 2006
 *
 *  This file is part of X10 Test.
 *
 */
import harness.x10Test;;

/**
 * Given two horizontal strip regions R1 and R2 and a vertical strip
 * region R3 going over R1 and R2 in an 8*8 grid, this test case tests
 * algebraic operations on regions and dists.
 *
 * <code>
          01234567
        0 ++++++++
        1 ++++++++
        2
        3
        4 ********
        5 ********
        6
        7

          01234567
        0     $$
        1     $$
        2     $$
        3     $$
        4     $$
        5     $$
        6     $$
        7     $$

        + region R1
        * region R2
        $ region R3

 * </code>
 *
 * @author kemal 4/2005
 */
public class DistAlgebra2 extends x10Test {

	public def run(): boolean = {
		final val P: dist = distmakeUnique();
		final val R1: region{rank==2} = [0..1, 0..7]; // horizontal strip
		pr("R1", R1);
		final val R2: region{rank==2} = [4..5, 0..7]; // horizontal strip
		pr("R2", R2);
		final val R3: region{rank==2} = [0..7, 4..5]; // vertical strip
		pr("R3", R3);
		final val R1orR2: region{rank==2} = (R1 || R2);
		pr("R1orR2", R1orR2);
		final val R1orR2andR3: region{rank==2} = R1orR2 && R3;
		pr("R1orR2andR3", R1orR2andR3);
		chk(R1orR2andR3.equals([0..1, 4..5] || [4..5, 4..5]));
		chk(R1orR2.contains(R1orR2andR3) && R3.contains(R1orR2andR3));
		final val R1orR2orR3: region{rank==2} = R1 || R2 || R3;
		pr("R1orR2orR3", R1orR2orR3);
		chk(R1orR2orR3.equals([0..1, 0..7] || [4..5, 0..7] ||
					[2..3, 4..5] || [6..7, 4..5]));
		chk(R1orR2orR3.contains(R1) &&  R1orR2orR3.contains(R2) &&
				R1orR2orR3.contains(R3));
		final val R1orR2minusR3: region{rank==2} = R1orR2 - R3;
		pr("R1orR2minusR3", R1orR2minusR3);
		chk(R1orR2minusR3.equals([0..1, 0..3] || [0..1, 6..7] ||
					[4..5, 0..3] || [4..5, 6..7]));
		chk(R1orR2.contains(R1orR2minusR3) && R1orR2minusR3.disjoint(R3));

		//Constant dist of R1||R2||R3
		final val DR1orR2orR3: dist{rank==2} = (dist{rank==2})) dist.factory.constant(R1orR2orR3, P(3));
		pr("DR1orR2orR3", DR1orR2orR3);
		for (val (i,j): point in DR1orR2orR3) {
			chk(DR1orR2orR3(i, j) == P(3));
		}

		//Check range restriction to a place
		final val np: int = place.MAX_PLACES;
		for (val (k): point in [0..np-1]) {
			final val DR1orR2orR3Here: dist = (DR1orR2orR3 | P(k));
			pr("DR1orR2orR3Here("+k+")", DR1orR2orR3Here);
			for (val (i,j): point in DR1orR2orR3) {
				chk(iff(DR1orR2orR3(i, j) == P(k),
							DR1orR2orR3Here.contains([i, j]) &&
							DR1orR2orR3Here(i, j) == P(k)));
			}
		}

		//DR1orR2andR3 is restriction of DR1orR2orR3 to (R1||R2)&&R3
		final val DR1orR2andR3: dist{rank==2} = DR1orR2orR3 | R1orR2andR3;
		pr("DR1orR2andR3", DR1orR2andR3);
		//DR1orR2minusR3 is restr. of DR1orR2orR3 to (R1||R2)-R3
		final val DR1orR2minusR3: dist{rank==2} = DR1orR2orR3 | R1orR2minusR3;
		pr("DR1orR2minusR3", DR1orR2minusR3);
		final val TD1: dist{rank==2} = DR1orR2orR3 - DR1orR2minusR3;
		pr("TD1", TD1);
		final val DR3: dist{rank==2} = DR1orR2orR3 | R3;
		pr("DR3", DR3);
		chk(TD1.equals(DR3));

		//intersection with common mapping
		//on common points
		final val TD2: dist{rank==2} = (DR1orR2minusR3 && DR1orR2orR3);
		pr("TD2", TD2);
		chk(TD2.equals(DR1orR2minusR3));

		// testing overlay with common mapping on common points
		final val DR1orR2: dist = DR1orR2orR3 | R1orR2;
		pr("DR1orR2", DR1orR2);
		final val TD3: dist = (DR1orR2.overlay(DR3));
		pr("TD3", TD3);
		chk(TD3.equals(DR1orR2orR3));

		//disjoint union
		final val TD4: dist = DR1orR2andR3 || DR1orR2minusR3;
		pr("TD4", TD4);
		chk(TD4.equals(DR1orR2));

		// overlay with common points not
		// necessarily mapping to same place
		final val TD9: dist = dist.factory.constant(R1orR2andR3, P(0));
		pr("TD9", TD9);
		final val Doverlay: dist{rank==2} = (dist{rank==2})) DR1orR2orR3.overlay(TD9);
		pr("Doverlay", Doverlay);
		for (val (i,j): point in Doverlay) {
			if (R1orR2andR3.contains([i, j])) {
				chk(Doverlay(i, j) == P(0) && TD9(i, j) == P(0));
			} else {
				chk(Doverlay(i, j) == DR1orR2orR3(i, j));
			}
		}

		// intersection with common points
		// not necessarily mapping to same place

		// if a point is common and maps to same place
		// in both dists,
		// the point is included in the intersection
		// with the same mapping.
		// Otherwise, the point is not included in
		// intersection.

		final val Dintersect: dist{rank==2} = DR1orR2orR3&&Doverlay;
		pr("Dintersect", Dintersect);
		for (val (i,j): point in [0..7, 0..7]) {
			chk(
					(DR1orR2orR3.contains([i, j]) &&
					 Doverlay.contains([i, j]) &&
					 DR1orR2orR3(i, j) == Doverlay(i, j)) ?

					(Dintersect.contains([i, j]) &&
					 Dintersect(i, j) == Doverlay(i, j)) :

					!Dintersect.contains([i, j])
			   );
		}

		return true;
	}

	static def iff(var x: boolean, var y: boolean): boolean = {
		return (x == y);
	}

	static def pr(var s: String, var d: dist): void = {
		System.out.println();
		System.out.println("printing dist "+s);
		var k: int = 0;
		final val N: int = 8;
		for (val (i,j): point in [0..N-1, 0..N-1]) {
			System.out.print(" "+(d.contains([i, j]) ? (""+d(i, j).id) : "."));
			if ((++k) % N == 0) System.out.println();
		}
	}

	static def pr(var s: String, var r: region): void = {
		System.out.println();
		System.out.println("printing region "+s);
		var k: int = 0;
		final val N: int = 8;
		for (val (i,j): point in [0..N-1, 0..N-1]) {
			System.out.print(" "+(r.contains([i, j]) ? "+" : "."));
			if ((++k) % N == 0) System.out.println();
		}
	}

	public static def main(var args: Rail[String]): void = {
		new DistAlgebra2().execute();
	}
}
