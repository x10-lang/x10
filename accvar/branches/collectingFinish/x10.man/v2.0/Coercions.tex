\section{Coercions and conversions}
\label{XtenConversions}
\label{User-definedCoercions}
\index{conversions}\index{coercions}

\XtenCurrVer{} supports the following coercions and conversions

\subsection{Coercions}

A {\em coercion} does not change object identity; a coerced object may
be explicitly coerced back to its original type through a cast. A {\em
  conversion} may change object identity if the type being converted
to is not the same as the type converted from. \Xten{} permits
user-defined conversions (\Sref{sec:user-defined-conversions}).

\paragraph{Subsumption coercion.}
A subtype may be implicitly coerced to any supertype.
\index{coercions!subsumption coercion}

\paragraph{Explicit coercion (casting with \xcd"as")}
A reference type may be explicitly coerced to any other
reference type using the \xcd"as" operation.
If the value coerced is not an instance of the target type,
a \xcd"ClassCastException" is thrown.  Casting to a constrained
type may require a run-time check that the constraint is
satisfied.
\index{coercions!explicit coercion}
\index{casting}
\index{\Xcd{as}}

\paragraph{Effects of explicit numeric coercion}
\label{sec:effects-of-explicit-numeric-coercions}

Coercing a number of one type to another type gives the best approximation of
the number in the result type, or a suitable disaster value if no
approximation is good enough.  

\begin{itemize}
\item Casting a number to a {\em wider} numeric type is safe and effective,
      and can be done by an implicit conversion as well as an explicit
      coercion.  For example, \xcd`4 as Long` produces the \xcd`Long` value of
      4. 
\item Casting a floating-point value to an integer value truncates the digits
      after the decimal point, thereby rounding the number towards zero.  
      \xcd`54.321 as Int` is \xcd`54`, and 
      \xcd`-54.321 as Int` is \xcd`-54`.
      If the floating-point value is too large to represent as that kind of
      integer, the coercion returns the largest or smallest value of that type
      instead: \xcd`1e110 as Int` is 
      \xcd`Int.MAX_VALUE`, \xcd`2147483647`. 

\item Casting a \xcd`Double` to a \xcd`Float` normally truncates digits: 
      \xcd`0.12345678901234567890 as Float` is \xcd`0.12345679f`.  This can
      turn a nonzero \xcd`Double` into \xcd`0.0f`, the zero of type
      \xcd`Float`: \xcd`1e-100 as Float` is \xcd`0.0f`.  Since 
      \xcd`Double`s can be as large as about \xcd`1.79E308` and \xcd`Float`s
      can only be as large as about \xcd`3.4E38f`, a large \xcd`Double` will
      be converted to the special \xcd`Float` value of \xcd`Infinity`: 
      \xcd`1e100 as Float` is \xcd`Infinity`.
\item Integers are coerced to smaller integer types by truncating the
      high-order bits. If the value of the large integer fits into the smaller
      integer's range, this gives the same number in the smaller type: \xcd`12 as Byte` is the \xcd`Byte`-sized 12, \xcd`-12 as Byte` is -12. 
      However, if the larger integer {\em doesn't} fit in the smaller type,
      the numeric value and even the sign can change: \xcd`254 as Byte` is
      \xcd`Byte`-sized \xcd`-2`.  


\end{itemize}

\subsection{Conversions}

\paragraph{Widening numeric conversion.}
A numeric type may be implicitly converted to a wider numeric type. In
particular, an implicit conversion may be performed between a numeric
type and a type to its right, below:

\begin{xten}
Byte < Short < Int < Long < Float < Double
\end{xten}

\index{conversions!widening conversions}
\index{conversions!numeric conversions}

\paragraph{String conversion.}
Any object that is an operand of the binary
\xcd"+" operator may
be converted to \xcd"String" if the other operand is a \xcd"String".
A conversion to \xcd"String" is performed by invoking the \xcd"toString()"
method of the object.

\index{conversions!string conversion}

\paragraph{User defined conversions.}\label{sec:user-defined-conversions}
\index{conversions!user defined}

The user may define conversion operators from type \Xcd{A} {\em to} a
container type \Xcd{B} by specifying a method on \Xcd{B} as follows:

\begin{xten}
  public static operator (r: A): T = ... 
\end{xten}

The return type \Xcd{T} should be a subtype of \Xcd{B}. The return
type need not be specified explicitly; it will be computed in the
usual fashion if it is not. However, it is good practice for the
programmer to specify the return type for such operators explicitly.

For instance, the code for \Xcd{x10.lang.Point} contains:

\begin{xten}
  public static global safe operator (r: Rail[int])
     : Point(r.length) = make(r);
\end{xten}

The compiler looks for such operators on the container type \Xcd{B}
when it encounters an expression of the form \Xcd{r as B} (where
\Xcd{r} is of type \Xcd{A}). If it finds such a method, it sets the
type of the expression \Xcd{r as B} to be the return type of the
method. Thus the type of \Xcd{r as B} is guaranteed to be some subtype
of \Xcd{B}.

\begin{example}
Consider the following code:  
\begin{xten}
val p  = [2, 2, 2, 2, 2] as Point;
val q = [1, 1, 1, 1, 1] as Point;
val a = p - q;    
\end{xten}
This code fragment compiles successfully, given the above operator definition. 
The type of \Xcd{p} is inferred to be \Xcd{Point(5)} (i.e.{} the type 
\xcd"Point{self.rank==5}".
Similarly for \Xcd{q}. Hence the application of the operator ``\Xcd{-}'' is legal (it requires both arguments to have the same rank). The type of \Xcd{a} is computed as \Xcd{Point(5)}.
\end{example}
