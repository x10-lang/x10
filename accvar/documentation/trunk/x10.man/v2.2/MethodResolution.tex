\section{Method Resolution}
\index{method!resolution}
\index{method!which one will get called}
\label{sect:MethodResolution}

Method resolution is the problem of determining, statically, which method (or
constructor or operator)
should be invoked, when there are several choices that could be invoked.  For
example, the following class has two overloaded \xcd`zap` methods, one taking
an \Xcd{Object}, and the other a \Xcd{Resolve}.  Method resolution will figure
out that the call \Xcd{zap(1..4)} should call \xcd`zap(Object)`, and
\Xcd{zap(new Resolve())} should call \xcd`zap(Resolve)`.  

\begin{ex}
%~~gen ^^^ MethodResolution10
%package MethodResolution.yousayyouwantaresolution;
% KNOWNFAIL
%~~vis
\begin{xten}
class Res {
  public static interface Surface {}
  public static interface Deface {}

  public static class Ace implements Surface {
    public static operator (Boolean) : Ace = new Ace();
    public static operator (Place) : Ace = new Ace();
  }
  public static class Face implements Surface, Deface{}

  public static class A {}
  public static class B extends A {}
  public static class C extends B {}

  def m(x:A) = 0;
  def m(x:Int) = 1;
  def m(x:Boolean) = 2;
  def m(x:Surface) = 3;
  def m(x:Deface) = 4; 


  def example() {
     assert m(100) == 1 : "Int"; 
     assert m(new C()) == 0 : "C";
     // An Ace is a Surface, unambiguous best choice
     assert m(new Ace()) == 3 : "Ace";
     // ERROR: m(new Face());

     // Boolean could be handled directly, or by 
     // implicit coercion Boolean -> Ace.
     // Direct matches always win.
     assert m(here) == 3 : "Place";
     assert m(true) == 2 : "Boolean"; 


  }
\end{xten}
%~~siv
%  public static def main(argv:Array[String](1)) {(new Res()).example(); Console.OUT.println("That's all!");}
% }
% class Hook{ def run(){ (new Res()).example(); return true;} }
%~~neg

In the \xcd`"Int"` line, there is a very close match.  \xcd`100` is an
\xcd`Int`.  In fact, \xcd`100` is an \xcd`Int{self==100}`, so even in this
case the type of the actual parameter is not {\em precisely} equal to the type
of the method.

In the \xcd`"C"` line of the example, \xcd`new C()` is an instance of \xcd`C`,
which is a subtype of \xcd`A`, so the \xcd`A` method applies.  No other method
does, and so the \xcd`A` method will be invoked.

Similarly, in the \xcd`"Ace"` line, the \xcd`Ace` class implements
\xcd`Surface`, and so \xcd`new Ace()` matches the \xcd`Surface` method. 

However, a \xcd`Face` is both a \xcd`Surface` and a \xcd`Deface`, so there is
no unique best match for the invocation \xcd`m(new Face())`.  This invocation
would be forbidden, and a compile-time error issued.

None of the defined methods match \xcd`Place`. However, there is an implicit
coercion (\Sref{sect:ImplicitCoercion}) from \xcd`Place` to \xcd`Ace`.  So, 
the \xcd`Ace` method will be called for \xcd`m(here)` --- with the implicit
coercion applied to \xcd`here` before the method call.
(\limitationx: this does not currently compile in all cases.)

For \xcd`m(true)`, both the \xcd`Boolean` and, with the implicit coercion,
\xcd`Ace` methods could apply.  Since the \xcd`Boolean` method applies
directly, and the \xcd`Ace` method requires an implicit coercion, this call
resolves to the \xcd`Boolean` method, without an error.

\end{ex}


The basic concept of method resolution is:
\begin{enumerate}
\item List all the methods that could possibly be used, inferring generic
      types but not performing implicit coercions.    If the
      \xcd`STATIC_CALLS` compiler flag is specified, the constraints must
      match exactly at this step; if not, they do not, but run-time tests will
      be generated if necessary.
\item If one possible method is more specific than all the others, that one 
      is the desired method.
\item If there are two or more methods neither of which is more specific than
      the others, then the method invocation is ambiguous.  Method resolution
      fails and reports an error.
\item Otherwise, no possible methods were found without implicit coercions.
      Try the preceding steps again, but with coercions allowed.  If a single
      most specific method is found with coercions, it is the desired method.
      If there are several, the invocation is ambiguous and erronious.
\item If no methods were found even with coercions, then the method invocation
      is undetermined.  Method resolution fails and reports an error.
\end{enumerate}
\noindent
In the presence of X10's highly-detailed type system, some subtleties arise. 
One point, at least, is {\em not} subtle. The same procedure is used, {\em
mutatis mutandis} for method, constructor, and operator resolution.  

\subsection{Possible Methods}

This section describes what it means for a method to be a {\em possible}
resolution of a method invocation.  



Generics introduce several subtleties, especially with the inference of
generic types. 
For the purposes of method resolution, all that matters about a method,
constructor, or operator \xcd`M` --- we use the word ``method'' to include all
three choices for this section --- is its signature, plus which method it is.
So, a typical \xcd`M` might look like 
\xcdmath"def m[G$_1$,$\ldots$, G$_g$](x$_1$:T$_1$,$\ldots$, x$_f$:T$_f$){c} =...".  The code body \xcd`...` is irrelevant for the purpose of whether a
given method call means \xcd`M` or not, so we ignore it for this section.

All that matters about a method definition, for the purposes of method
resolution, is: 
\begin{enumerate}
\item The method name \xcd`m`;
\item The generic type parameters of the method \xcd`m`,  \xcdmath"G$_1$,$\ldots$, G$_g$".  If there
      are no generic type parameters, {$g=0$}.  
\item The types \xcdmath"x$_1$:T$_1$,$\ldots$, x$_f$:T$_f$" of the formal parameters.  If
      there are no formal parameters, {$f=0$}. In the case of an instance
      method, the receiver will be the first formal parameter.\footnote{The
      variable names are relevant because one formal can be mentioned in a
      later type, or even a constraint: {\tt def f(a:Int, b:Point\{rank==a\})=...}.}
\item The constraint \xcd`c` of the method \xcd`M`. If no constraint is specified, \xcd`c` is
      \xcd`true`. 
\item A {\em unique identifier} \xcd`id`, sufficient to tell the compiler
      which method body is intended.  A file name and position in that file
      would suffice.  The details of the identifier are not relevant.
\end{enumerate}

For the purposes of understanding method resolution, we assume that all the
actual parameters of an invocation are simply variables: \xcd`x1.meth(x2,x3)`.
This is done routinely by the compiler in any case; the code 
\xcd`tbl(i).meth(true, a+1)` would be treated roughly as 
\begin{xten}
val x1 = tbl(i);
val x2 = true;
val x3 = a+1;
x1.meth(x2,x3);
\end{xten}

All that matters about an invocation \xcd`I` is: 
\begin{enumerate}
\item The method name \xcdmath"m$'$";
\item The generic type parameters \xcdmath"G$'_1$,$\ldots$, G$'_g$".  If there
      are no generic type parameters, {$g=0$}.  
\item The names and types \xcdmath"x$_1$:T$'_1$,$\ldots$, x$_f$:T$'_f$" of the
      actual parameters.
      If
      there are no actual parameters, {$f=0$}. In the case of an instance
      method, the receiver is the first actual parameter.
\end{enumerate}

The signature of the method resolution procedure is: 
\xcd`resolve(invo : Invocation, context: Set[Method]) : MethodID`.  
Given a particular invocation and the set \xcd`context` of all methods
which could be called at that point of code, method resolution either returns
the unique identifier of the method that should be called, or (conceptually)
throws an exception if the call cannot be resolved.

The procedure for computing \xcd`resolve(invo, context)` is: 
\begin{enumerate}
\item Eliminate from \xcd`context` those methods which are not {\em
      acceptable}; \viz, those whose name, type parameters, formal parameters,
      and constraint do not suitably match \xcd`invo`.  In more detail:
      \begin{itemize}
      \item The method name \xcd`m` must simply equal the invocation name \xcdmath"m$'$";
      \item X10 infers type parameters, by an algorithm given in \Sref{TypeParamInfer}.
      \item The method's type parameters are bound to the invocation's for the
            remainder of the acceptability test.
      \item The actual parameter types must be subtypes of the formal
            parameter types, or be coercible to such subtypes.  Parameter $i$
            is a subtype if \xcdmath"T$'_i$ <: T$_i$".  It is implicitly
            coercible to a subtype if there is an implicit coercion operator
            defined from \xcdmath"T$'_i$" to some type \xcd`U`, and 
            \xcdmath"U <: T$_i$". \index{method resolution!implicit coercions
            and} \index{implicit coercion}\index{coercion}.  If coercions are
            used to resolve the method, they will be called on the arguments
            before the method is invoked.
            
      \item The formal constraint \xcd`c` must be satisfied in the invoking
            context. 
      \end{itemize}
\item Eliminate from \xcd`context` those methods which are not {\em
      available}; \viz, those which cannot be called due to visibility
      constraints, such as methods from other classes marked \xcd`private`.
      The remaining methods are both acceptable and available; they might be
      the one that is intended.
\item From the remaining methods, find the unique \xcd`ms` which is more specific than all the
      others, \viz, for which \xcd`specific(ms,mo) = true` for all other
      methods \xcd`mo`.
      The specificity test \xcd`specific` is given next.
      \begin{itemize}
      \item If there is a unique such \xcd`ms`, then
            \xcd`resolve(invo,context)` returns the \xcd`id` of \xcd`ms`.  
      \item If there is not a unique such \xcd`ms`, then \xcd`resolve` reports
            an error.
      \end{itemize}

\end{enumerate}

The subsidiary procedure \xcd`specific(m1, m2)` determines whether method
\xcd`m1` is equally or more specific than \xcd`m2`.  \xcd`specific` is not a
total order: is is possible for each one to be considered more specific than
the other, or either to be more specific.  \xcd`specific` is computed as: 
\begin{enumerate}
\item Construct an invocation \xcd`invo1` based on \xcd`m1`: 
      \begin{itemize}
      \item \xcd`invo1`'s method name is \xcd`m1`'s method name;
      \item \xcd`invo1`'s generic parameters are those of \xcd`m1`--- simply
            some type variables.
      \item \xcd`invo1`'s parameters are those of \xcd`m1`.
      \end{itemize}
\item If \xcd`m2` is acceptable for the invocation \xcd`invo1`,
      \xcd`specific(m1,m2)` returns true; 
\item Construct an invocation \xcd`invo2p`, which is \xcd`invo1` with the
      generic parameters erased.  Let \xcd`invo2` be \xcd`invo2p` with generic
      parameters as inferred by X10's type inference algorithm.  If type
      inference fails, \xcd`specific(m1,m2)` returns false.
\item If \xcd`m2` is acceptable for the invocation \xcd`invo2`,
      \xcd`specific(m1,m2)` returns true; 
\item Otherwise, \xcd`specific(m1,m2)` returns false.
\end{enumerate}

\subsection{Other Disambiguations}

It is possible to have a field of the same name as a method.
Indeed, it is a common pattern to have private field and a public
method of the same name to access it:
\begin{ex}
%~~gen ^^^ MethodResolution_disamb_a
%package MethodResolution_disamb_a;
%~~vis
\begin{xten}
class Xhaver {
  private var x: Int = 0;
  public def x() = x;
  public def bumpX() { x ++; }
}
\end{xten}
%~~siv
%
%~~neg
\end{ex}

\begin{ex}
However, this can lead to syntactic ambiguity in the case where the field
\Xcd{f} of object \xcd`a` is a
function, array, list, or the like, and where \xcd`a` has a method also named
\xcd`f`.  The term \Xcd{a.f(b)} could either mean ``call method \xcd`f` of \xcd`a` upon
\xcd`b`'', or ``apply the function \xcd`a.f` to argument \xcd`b`''.  

%~~gen  ^^^ MethodResolution_disamb_b
%package MethodResolution_disamb_b;
%NOCOMPILE
%~~vis
\begin{xten}
class Ambig {
  public val f : (Int)=>Int =  (x:Int) => x*x;
  public def f(y:int) = y+1;
  public def example() {
      val v = this.f(10);
      // is v 100, or 11?
  }
}
\end{xten}
%~~siv
%
%~~neg
\end{ex}

In the case where a syntactic form \xcdmath"E.m(F$_1$, $\ldots$, F$_n$)" could
be resolved as either a method call, or the application of a field \xcd`E.m`
to some arguments, it will be treated as a method call.  
The application of \xcd`E.m` to some arguments can be specified by adding
parentheses:  \xcdmath"(E.m)(F$_1$, $\ldots$, F$_n$)".

\begin{ex}

%~~gen ^^^ MethodResolution_disamb_c
%package MethodResolution_disamb_c;
%NOCOMPILE
%~~vis
\begin{xten}
class Disambig {
  public val f : (Int)=>Int =  (x:Int) => x*x;
  public def f(y:int) = y+1;
  public def example() {
      assert(  this.f(10)  == 11  );
      assert( (this.f)(10) == 100 );
  }
}
\end{xten}
%~~siv
%
%~~neg

\end{ex}

Similarly, it is possible to have a method with the same name as a struct, say
\xcd`ambig`, giving an ambiguity as to whether \xcd`ambig()` is a struct
constructor invocation or a method invocation.  This ambiguity is resolved by
treating it as a method invocation.  If the constructor invocation is desired,
it can be achieved by including the optional \xcd`new`.  That is, 
\xcd`new ambig()` is struct constructor invocation; \xcd`ambig()` is a 
method invocation.


