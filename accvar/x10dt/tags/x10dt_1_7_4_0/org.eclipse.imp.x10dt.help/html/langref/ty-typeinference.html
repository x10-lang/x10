<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
<title>Type inference</title>
</head>

<body>
 <h2><a name="tth_sEc12">
12</a>&nbsp;&nbsp;Type inference</h2>
<a name="TypeInference">
</a>



<div class="p"><!----></div>
 X10 v1.7 supports limited local type inference, permitting
variable types and return types to be elided.
It is a static error if an omitted type cannot be inferred or
uniquely determined.

<div class="p"><!----></div>
     <h3><a name="tth_sEc12.1">
12.1</a>&nbsp;&nbsp;Variable declarations</h3>

<div class="p"><!----></div>
The type of a variable declaration can be omitted if the
declaration has an initializer.  The inferred type of the
variable is the computed type of the initializer.

<div class="p"><!----></div>
     <h3><a name="tth_sEc12.2">
12.2</a>&nbsp;&nbsp;Return types</h3>

<div class="p"><!----></div>
The return type of a method can be omitted if the method has a
body (i.e., is not &#228;bstract" or &#235;xtern").  The
inferred return type is the computed type of the body.

<div class="p"><!----></div>
The return type of a closure can be omitted.
The inferred return type is the computed type of the body.

<div class="p"><!----></div>
The return type of a constructor can be omitted if the
constructor has a body (i.e., is not &#235;xtern").
The inferred return type if the enclosing class type with
properties bound to the arguments in the constructor's "property"
statement, if any, or to the unconstrained class type.

<div class="p"><!----></div>
The inferred type of a method or closure body is the least common ancestor
of the types of the expressions in "return" statements
in the body.  If the method does not return a value, the
inferred type is "Void".

<div class="p"><!----></div>
     <h3><a name="tth_sEc12.3">
12.3</a>&nbsp;&nbsp;Type arguments</h3>

<div class="p"><!----></div>
A call to a polymorphic method, closure, or constructor may omit the
explicit type arguments.  If the method has a type parameter
"T", the type argument corresponding to "T" is inferred
to be the least common ancestor of the types of any formal
parameters of type "T".

<div class="p"><!----></div>
Consider the following method:
<pre>
def choose[T](a: T, b: T): T { ... }
</pre>
Given "Set[T] &lt;: Collection[T]"
and "List[T] &lt;: Collection[T]",
in the following snippet, the algorithm should infer the type
"Collection" for "x".
<pre>
intSet: Set[Int];
stringList: List[String];
val x = choose(intSet, stringList);
</pre>
And in this snippet, the algorithm should infer the type
"Collection[Int]" for &#255;".
<pre>
intSet: Set[Int];
intList: List[Int];
val y = choose(intSet, intList);
</pre>
Finally, in this snippet, the algorithm should infer the type
"CollectionT &lt;: Number" for "z".
<pre>
intSet: Set[Int];
numList: List{T &lt;: Number};
val z = choose(intSet, numList);
</pre>

<div class="p"><!----></div>
Now, consider the following example:
<pre>
def union[T](a: Set[T], b: Set[T]) : Set[T];
</pre>
The union method cannot be called with just arguments of type "Set".
<pre>
set1: Set;
set2: Set;
val a = union(set1, set2);
</pre>
This is illegal because the type system cannot demonstrate that
&#223;et1.T" and &#223;et2.T" are equal.
The following, however, is acceptable:
<pre>
set1: Set;
set2: Set[set1.T];
val a = union(set1, set2);
</pre>

<div class="p"><!----></div>
However, unlike &#252;nion" above,
the following method can be called with an argument of type "Set"
because there are no constraints on "T":
<pre>
def unmodifiableSet[T](set: Set[T]): Set[T];
</pre>

<div class="p"><!----></div>
Using desugared syntax, the method is
equivalent to: 
<pre>
def unmodifiableSet[T](set: Set{self.T==T}): Set{self.T==T};
</pre>
Any "Set" can be passed in: for an argument &#235;", the method
is instantiated on &#235;.T".
Note that if this method were defined as:
<pre>
def unmodifiableSet(set: Set): Set;
</pre>
then the connection between the element types of the
argument and of the return types would be broken.
However, one could use the following signature to keep the
connection, without introducing a method type parameter. 
<pre>
def unmodifiableSet(set: Set): Set[set.T];
</pre>
<hr /><h3>Footnotes:</h3>

<div class="p"><!----></div>
<a name="tthFtNtAAB"></a><a href="#tthFrefAAB"><sup>1</sup></a>In
order to allow this version of the language to focus on the core new
ideas,   X10 v1.7 does not have user-definable class loaders,
though there is no technical reason why they could not have been
added.

</body>
</html>