<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.89">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
 
      
<title>A Whirlwind Tour of X10</title>

<div class="p"><!----></div>
 <h1><a name="tth_chAp1">
Chapter 1 </a><br />A Whirlwind Tour of X10</h1>
In this chapter, we'll look at couple of quick examples that illustrate X10 in action.
The next two chapters will then fill in a lot of the details.

 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Hello!</h2>

<div class="p"><!----></div>
Enough suspense! You knew it was coming, so let's get right to it!

<pre>
1&nbsp;&nbsp;&nbsp;//&nbsp;file&nbsp;HelloWorld.x10
2&nbsp;&nbsp;&nbsp;public&nbsp;class&nbsp;HelloWorld&nbsp;{
3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;main(args:&nbsp;Array[String](1))&nbsp;{
4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x10.io.Console.OUT.println("Hello,&nbsp;World");
5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
6&nbsp;&nbsp;&nbsp;}&nbsp;

</pre>
Let's step through the program, a line at a time:

<div class="p"><!----></div>

<dl compact="compact">
 <dt><b>line 1:</b></dt>
	<dd> <tt>// file HelloWorld.x10 </tt><br />
Comments in X10 are the same as Java or C++: they either begin
with "<tt>//</tt>" and go through the end of the line, or begin with "<tt>/*</tt>"
and end at the <em>first</em> "<tt>*/</tt>" that follows.  Because the first "<tt>*/</tt>" 
ends the comment, "<tt>/*...*/</tt>" <em>comments do not nest</em>. 

<div class="p"><!----></div>
X10 also uses the same 
comment conventions for publishing APIs as Java does with JavaDoc.  
JavaDoc is a formalized comment style used to generate an
HTML site  that describes the API presented by a set of source code
files. X10 supports a similar system, called X10Doc, for <tt>.x10</tt> files. 
All of our sample code uses X10Doc documentation.<a href="#tthFtNtAAB" name="tthFrefAAB"><sup>1</sup></a>

<div class="p"><!----></div>
Our copy of this file is 
<a href="http://dist.codehaus.org/x10/documentation/guide/src/hello/HelloWorld.x10">hello/HelloWorld.x10</a>.</dd>
 <dt><b>line 2:</b></dt>
	<dd> <tt>class HelloWorld {... }</tt><br />
X10's classes serve essentially the same purposes as classes in other object
oriented languages, Java and C++ in particular.  There are some differences, of
course.  They are mainly due to two factors: X10's concern with
compile-time safety checks, and efficient access in a multi-processor
applications.  We'll point the differences out as we come on situations where
they show up naturally.

<div class="p"><!----></div>
A class normally will have the same name as the file in which is
declared- <tt>HelloWorld</tt> is found in <tt>HelloWorld.x10</tt>.  C++
programmers should realize that, unlike C++, X10 relies on file names to
find class declarations.  We'll go through the rules in detail in Chapter
.</dd>
 <dt><b>line 3:</b></dt>
	<dd> <tt>public static def main(args: Array[String](1))</tt><br />
Program execution starts, as in Java and C++,  with a method named
 <tt>main</tt>, which takes the command-line arguments as a collection of strings.
 But here we start to see some differences in syntax from Java and C++:

<ul>
<li> The keyword <tt>def</tt> begins a method declaration.   
This makes it easy to tell what's a method and what isn't.
<div class="p"><!----></div>
</li>

<li> There is no return type specified here.
In fact, <em>you don't normally need to specify the return
type for a method.</em> This is different from both Java (you must supply it) and C++,
(the default is <tt>int</tt>).  The X10 compiler looks for the return
statements in a method and normally is able to infer the return type.

<div class="p"><!----></div>
If you <em>do</em> wish to specify it, then, unlike Java and C++, it <em>follows</em> the
argument list.  For example, "<tt>def doIt(t: T): U {...}</tt>" declares a
method named <tt>doIt</tt> with one argument of type <tt>T</tt> and a return value of
type <tt>U</tt>.  Notice the `<tt>:</tt>' that preceeds the types in both places:
it is the required syntax.

<div class="p"><!----></div>
So why might you specify the return type, if you don't have to?  Basically,
just to save someone other than yourself who is reading the code the trouble of
figuring out what's returned. Occasionally, one does have to assert the return
type, but to tell you the truth, it's rare enough that coming up with a
convincing example is hard.
<div class="p"><!----></div>
</li>

<li> X10 has generic types, along the same general lines as Java and C++. 
X10 uses square brackets to hold the actual type, <em>e.g.</em> <tt>Array[String]</tt>
for declaring an array of <tt>String</tt>s.
<div class="p"><!----></div>
</li>

<li> X10 arrays, like FORTRAN arrays, may be multi-dimensional.  The "<tt>(1)</tt>" that
follows <tt>Array[String]</tt> asserts that the array is one-dimensional, or in other words,
is just like the usual Java or C++ array.
<div class="p"><!----></div>
</li>

<li> The general syntax for assigning a type to an identifier is 

<center><tt><em>identifier</em>: <em>type</em></tt>,</center>
as in <tt>args:Array[String](1)</tt>.  White space before or after the `<tt>:</tt>' is 
ignored by the compiler. In fact, white space in X10 is treated as it
is in Java and C++: normally ignored, except to the extent that it is needed to
separate tokens or appears in string literal constants.
<div class="p"><!----></div>
</li>
</ul></dd>
 <dt><b>line 4:</b></dt>
	<dd><tt>x10.io.Console.OUT.println("Hello, World");</tt><br />
Like Java, X10 groups classes into units called "packages".  For example, the input-output
classes in X10's standard library all belong to the package <tt>
x10.io</tt>. The class <tt>Console</tt> is part of that package.  
Package names are used both as prefixes to provide unique names for classes <em>
and to locate the classes</em>. 

<blockquote><tt>Console.IN</tt>,  <tt>Console.OUT</tt>, and  <tt>Console.ERR</tt></blockquote>
are the standard input, output, and error streams. 
The method  <tt>println</tt> prints a string, followed by an operating-system
dependent line-ender: either a single newline character for Unix based systems, 
or a carriage return-newline pair. If you don't want the newline, use <tt>print</tt> instead.

<div class="p"><!----></div>
We'll give some more details about packaging in chapter .</dd>
</dl>

<div class="p"><!----></div>
To compile the code for execution by a Java-based runtime, the command-line
looks like:

<pre>&nbsp;%&nbsp;x10c&nbsp;HelloWorld.x10
</pre>
To run it, you use <tt>x10</tt>:

<pre>%&nbsp;x10&nbsp;HelloWorld
Hello,&nbsp;World
</pre> 
There is also a C++
runtime.  To use it, you need to compile using <tt>x10c++</tt> rather than <tt>
x10c</tt>.  The usual C compiler convention <tt>-o <em>filename</em></tt> for naming the
executable is used.

<pre>
%&nbsp;x10c++&nbsp;HelloWorld.x10&nbsp;-o&nbsp;hello
%&nbsp;runx10&nbsp;hello
Hello,&nbsp;World

</pre> 
You'll need the <tt>runx10</tt>: you cannot invoke <tt>hello</tt> directly, because some special
setup is required to accommodate the concurrency and the possible distribution of the
execution across multiple machines.  We don't actually need anything special
for <tt>hello</tt>, but the code for booting an X10 program is generic.

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  

<div class="p"><!----></div>
    
<div class="p"><!----></div>

<div class="p"><!----></div>

`\`=13


<div class="p"><!----></div>
`^^M=13 

<div class="p"><!----></div>
`^^I=13 

<div class="p"><!----></div>
}}


<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
  




<div class="p"><!----></div>

<div class="p"><!----></div>
  
<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;Two CPUs Are Better Than One</h2>

<div class="p"><!----></div>
The point of X10 is concurrent programming: giving you control over clusters of 
multiprocessors.   We'll get started on this by parallelizing a simple piece of serial
code that computes an approximation to the number &#960;.  Along the way, we'll
introduce some more X10 syntax and write our first loops.

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;&#960; via Monte Carlo</h3>

<div class="p"><!----></div>
The unit circle is the set of points (x,y) in the plane that satisfy x<sup>2</sup> + y<sup>2</sup>  &#8804; 1,
and its area is &#960;.  We are going to explore a particularly simple method of estimating
&#960;.  Figure  shows the one-quarter of the unit circle that lies
in the unit square,  0  &#8804; x,y  &#8804; 1.  The unit square has area 1, and the
shaded part inside the circle has area &#960;/4.  

<div class="p"><!----></div>
<a name="tth_fIg1">
</a>   

<center>  
<img src="cis3.png" alt="Graph" />

<center>Figure 1: The intersection of the unit circle with the unit square</center>
<a name="fig:cis">
</a>
</center>

<div class="p"><!----></div>
Now imagine picking points at random in the unit square.  What fraction
will also lie in the unit circle?  If the points are really random, the
answer ought to be the fraction of the square that lies inside the unit circle,
namely: &#960;/4.

<div class="p"><!----></div>
One way to estimate &#960;/4, then, is to pick a
large number of points (x,y) in the unit square at random and see what fraction
actually land in the unit circle. This sort of process is called a "Monte
Carlo" algorithm.

<div class="p"><!----></div>
If ever there
were an easily parallelized type of algorithm, Monte Carlo is it: if we have 1,000
processors, we let each generate points independently, and at the end, we
just have to merge the results.  The only trick is to make sure that each of the 1,000
processors starts in a way genuinely random with respect to the others, so that
they don't just duplicate each other's efforts. 

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.2">
2.2</a>&nbsp;&nbsp;Getting Started: A Serial Version</h3>
Let's look first at a serial version in Figure , 
because it introduces a number of X10 idioms that we'll need in the
parallel version.  You can find the source in 
<a href="http://dist.codehaus.org/x10/documentation/guide/src/montePi/MontePi1.x10">montePi/MontePi1.x10</a>.


<div class="p"><!----></div>
<a name="tth_fIg2">
</a> <hr />

<pre>&nbsp;1&nbsp;/*&nbsp;Monte&nbsp;Carlo&nbsp;estimator&nbsp;for&nbsp;pi&nbsp;*/
&nbsp;2&nbsp;import&nbsp;x10.util.Random;
&nbsp;3&nbsp;public&nbsp;class&nbsp;MontePi&nbsp;{
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;val&nbsp;N&nbsp;=&nbsp;10000;
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;main(args:&nbsp;Array[String](1))&nbsp;{
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;r&nbsp;=&nbsp;new&nbsp;Random();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;inCircle:&nbsp;Double&nbsp;=&nbsp;0.0;
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(var&nbsp;j:&nbsp;Int&nbsp;=&nbsp;1;&nbsp;j&nbsp;&lt;=&nbsp;N;&nbsp;j++)&nbsp;&nbsp;{
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;x&nbsp;=&nbsp;r.nextDouble();
10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;y&nbsp;=&nbsp;r.nextDouble();
11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(x*x&nbsp;+y*y&nbsp;&lt;=&nbsp;1.0)&nbsp;inCircle++;
12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;pi&nbsp;=&nbsp;4&nbsp;*&nbsp;(inCircle&nbsp;/&nbsp;N);
14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.OUT.println("The&nbsp;value&nbsp;of&nbsp;pi&nbsp;is&nbsp;"+pi);
15&nbsp;&nbsp;&nbsp;&nbsp;}
16&nbsp;}
</pre>
<hr />


<center>Figure 2: Serial Monte Carlo Approximation of Pi</center><a name="fig:mcpi">
</a>

<div class="p"><!----></div>

<dl compact="compact">
 <dt><b>line 2:</b></dt>
	<dd> 
<tt>Console</tt> and <tt>Random</tt> are two classes from the X10
standard library. Whenever you need a class that is not implemented in the file
you are editing, you need to tell the compiler.  There are two ways to do so, which
are the same as in Java.  One option is to
specify the complete name of the class in an <tt>import</tt> statement, as line 2 does for
<tt>Random</tt>. The other way is to spell out the name at each use:  we could
have omitted this line by rewriting line 6 as "<tt>val r = new
x10.util.Random()</tt>".

<div class="p"><!----></div>
Types in the package <tt>x10.lang</tt>, like <tt>Int</tt>, are so commonly used that
the compiler is kind and does not force you to import them.  
<tt>Console</tt> also falls into this category.
<tt>Random</tt>, like most classes outside <tt>x10.lang</tt>, does not.</dd>
 <dt><b>lines 4, 6, 9, 10, 13</b></dt>
	<dd>
In line 4 we declare <tt>N</tt> to be a <tt>static val</tt>.
The keyword "<tt>val</tt>" means that <tt>N</tt> names a value,
<tt>10000</tt> in this case.  One cannot assign a new value to 
<tt>N</tt> later on in the code: it is a constant, in the same way the <tt>const</tt>
is used in C and <tt>final</tt> in Java.

<div class="p"><!----></div>
The keyword "<tt>static</tt>" means that the value is associated with the class
<tt>MontePi</tt> itself. The remaining <tt>val</tt>s, <tt>r</tt>, <tt>x</tt>, <tt>y</tt> and
<tt>pi</tt> are not part of the class: they are just local variables of the method
<tt>main()</tt>.

<div class="p"><!----></div>
The compiler will happily figure out the type of a <tt>val</tt> whose
value appears in its declaration, as it does in each of the five declarations
here. You can, if you wish, provide the type yourself.
For example, we could have written line 6 as

<blockquote><tt>val r:Random = new Random(); </tt></blockquote>
There's not much point in this case, though, to spelling things out.
Adding "<tt>:Random</tt>" helps neither people nor the compiler read the code. 

<blockquote>
<em>Most of the time, you should not
specify the type of a <tt>val</tt> whose initial value appears with its
declaration.</em>  Trust the compiler to do the work. This is not just a matter of
taste.  The compiler's notion of type may be more strict than yours,
particularly as a newcomer to X10.  When we get into the details of X10's
arrays, we'll illustrate the pitfalls, and you'll see what we mean.  
</blockquote>

<div class="p"><!----></div>
You <em>do</em> need to provide the type when you don't want to initialize
the <tt>val</tt> in the declaration itself.  Typically this happens when the <tt>val</tt>
depends on some choices that you can't neatly write in one line:

<pre>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;howMany:&nbsp;Int;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(aBoolean)&nbsp;{&nbsp;/*&nbsp;howMany&nbsp;gets&nbsp;set&nbsp;one&nbsp;way&nbsp;here&nbsp;*/&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{&nbsp;/*&nbsp;howMany&nbsp;gets&nbsp;set&nbsp;differently&nbsp;here&nbsp;*/&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;

</pre>
The <tt>if</tt> and <tt>else</tt> blocks are both free to do any calculation they
need to, so long as they don't try to use <tt>howMany</tt> before it has been set.  
The rule is

<blockquote><em>Control cannot reach a use of a <tt>val</tt> without first
reaching an assignment that sets the <tt>val</tt>'s value.</em> </blockquote>
In other words, there is no such thing as "default value" for a <tt>val</tt>.
It must be set explicitly by you, and once set, cannot be changed.

<div class="p"><!----></div>
The initializer for a <tt>val</tt> may be any legal X10 expression that can be
evaluated at run-time-they need not be compile-time constants.  Lines 9,
10, and 13 all show examples of initialization expressions.</dd>
 <dt><b>lines 7 and 8:</b></dt>
	<dd>  
The keyword <tt>var</tt> introduces the declaration of a variable.
A declaration like "<tt>var result:Double = 0.0;</tt>"  says that
<tt>result</tt> names some storage that holds a value of type <tt>Double</tt>
whose initial value is <tt>0.0</tt>, and this value
may be updated as the code runs.  In the lingo of the trade, one
says that "<tt>result</tt> <em>references</em> a <tt>Double</tt>".  

<div class="p"><!----></div>
<tt>Double</tt> values are double-precision IEEE floating points, exactly like Java's and C++'s
<tt>double</tt>.  

<div class="p"><!----></div>
You do need to supply
the type for a <tt>var</tt> even when an initial value is provided.
The rationale is a bit involved, so we ask you just to take our word for it that  
for now, the compiler needs to be told the type of every <tt>var</tt>.  Someday, the compiler
will get smarter, but that day is not today.</dd>
 <dt><b>lines 8-12:</b></dt>
	<dd>
Another new ingredient in the code is the "<tt>for</tt>"  loop, lines 8 through 12.

<div class="p"><!----></div>
The syntax in line 8 should be familiar.  It begins with the declaration and initialization
of the loop
variable <tt>j</tt>, "<tt>var j:Int = 1</tt>".  Important: you need the "<tt>var</tt>", because that
tells the compiler you want to declare a new variable. "<tt>j:Int = 1</tt>" by itself
won't do: the compiler will complain that <tt>j</tt> is a value, not a variable.

<div class="p"><!----></div>
As you might guess, "<tt>Int</tt>" is X10's
32-bit integer type. 

<div class="p"><!----></div>
The declaration for <tt>j</tt> is followed by the test "<tt>j &lt;= N</tt>" .  This expression is
evaluated at each iteration (including the first!) and the loop body will be executed
only so long as it evaluates to "true."  

<div class="p"><!----></div>
The third expression in line 8, "<tt>j++</tt>", is the re-initialization of the
loop variable. X10's binary and unary operators are the same as in all of the
languages in the tradition of C, so things like "<tt>-=</tt>" and "<tt>++</tt>"
mean exactly what most of you would expect, but just in case:

<blockquote>
The expression "<tt>a -= b</tt>" is a short-hand for "<tt>a = a-b</tt>".  This
works for any binary arithmetic operators,  <tt>a /= b</tt>.  Operators like
<tt>-=</tt> are often referred to as "update assignments"

<div class="p"><!----></div>
"<tt>n++</tt>" is another form of update assignement.  As an expression, the
value of <tt>n++</tt> is the <em>current</em> value of <tt>n</tt>. As a side-effect of
evaluating <tt>n++</tt>, though, <tt>n</tt>'s value is incremented by <tt>1</tt>.  The
expression <tt>n--</tt> is similiar, but (of course) subtracts <tt>1</tt>.

<div class="p"><!----></div>
"<tt>++n</tt>" is just a short-hand for "<tt>n = n+1</tt>".  That is: <tt>n</tt> is
incremented by <tt>1</tt> and the result is used as the value of the expression.
The expression <tt>--n</tt> is similar.
</blockquote>  

<div class="p"><!----></div>
Each time through the loop, we call the random number generator
<tt>r</tt> twice to get the coordinates of a point (lines 9 and 10).
Happily, <tt>r.nextDouble</tt>
returns a value between 0 and 1, so we can use it "as is."   In line 11,
we check whether the point lies in the unit circle, and if so, we increment
<tt>inCircle</tt> by 1. 

<div class="p"><!----></div>
As it happens here, we don't need <tt>j</tt> in the loop, but we do want to emphasize
that <em>the scope of <tt>j</tt>'s declaration is the loop and nothing but the
loop</em>, so when you leave the loop, <tt>j</tt> will be unavailable.  There is no rule, however,
that says you <em>have</em> to declare the loop variable in the <tt>for</tt> statement.
If you need the value once the loop completes, just declare it in a context surrounding
the loop, and set it to its initialize value wherever it is convenient to do so, :

<pre>&nbsp;&nbsp;&nbsp;var&nbsp;j:&nbsp;Int&nbsp;=&nbsp;1;
&nbsp;&nbsp;&nbsp;for(&nbsp;;&nbsp;j&nbsp;&lt;=&nbsp;N;&nbsp;j++)&nbsp;{&nbsp;...&nbsp;}
&nbsp;&nbsp;&nbsp;Console.OUT.println("Is&nbsp;"+j+"&nbsp;==&nbsp;"+(N+1)+"?");&nbsp;
</pre></dd>
 <dt><b>line 13:</b></dt>
	<dd>
On exit from the loop at line 13, <tt>inCircle/N</tt> is the fraction of points
in the circle, which is going to be a positive number less than 1, so we
have to use a <tt>Double</tt> (or if we don't care about the precision, a <tt>Float</tt>)
to capture the value.  
That's why we made <tt>inCircle</tt> a "<tt>Double</tt>" in line 7.
When we do the division here, the compiler will arrange to convert
<tt>N</tt> to a <tt>Double</tt>, too, and will use double precision floating
point division.  

<div class="p"><!----></div>
Suppose we had said to ourselves, "incrementing a <tt>Double</tt> by 1 inside that
loop has got to
be more expensive than incrementing an <tt>Int</tt>.  So let's declare <tt>inCircle</tt> to be
an <tt>Int</tt>."  That's fine, but when we get to line 13, we have to be careful to
convert it to a <tt>Double</tt>:

<pre>13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;pi&nbsp;=&nbsp;4&nbsp;*&nbsp;(inCircle&nbsp;as&nbsp;Double&nbsp;/&nbsp;N);
</pre>
Of course, we could also have been polite and written "4.0" instead of "4",
which would have saved the compiler some work and might have been
better for readability.  Adding an "<tt>as Double</tt>" to force the conversion
of <tt>N</tt> explicitly as well would also have helped the compiler, and is a
perfectly reasonable thing to do, but probably doesn't make the whole expression
more readable.</dd>
</dl>

<div class="p"><!----></div>
Time to try compiling and running the code.  Here is our console log for the
run:

<pre>%&nbsp;x10&nbsp;MonteCarloPi
The&nbsp;value&nbsp;of&nbsp;pi&nbsp;is&nbsp;3.1368
</pre>
Not a brilliant guess at &#960;, but we didn't really try all that many points.  Your
answer might vary: in fact, the answer will vary with each run because, whenever
<tt>Random</tt> creates a new generator, it
uses the current time to create a new starting point for computing its values.
The first two digits, 3.1, though, should be stable.  Good luck!

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.3">
2.3</a>&nbsp;&nbsp;We Can Do Better</h3><a name="subs:wcdb">
</a>

<div class="p"><!----></div>
There are some pretty primitive aspects to our first cut at &#960;.  In this section
we'll introduce a few features of X10 that will help us spruce up the code a
little bit.

<div class="p"><!----></div>
To begin with, that "<tt>static val N = 10000;</tt>" in line 4 is really, truly rigid. 
We have a perfectly good set of command line arguments.  Why not use the first, if
supplied, to set the number of points to try?  That would have let us try 1,000,000
points right away to see how much better we could do than 10,000.
The code we need is simple enough:

<pre>
&nbsp;1&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;main(args:&nbsp;Array[String](1))&nbsp;{
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;N&nbsp;=&nbsp;args.size()&nbsp;&#62;&nbsp;0&nbsp;?&nbsp;Int.parse(args(0))&nbsp;:&nbsp;10000;

</pre>
Some comments:

<dl compact="compact">
 <dt><b>line 1:</b></dt>
	<dd>
The command line arguments come in as the array <tt>args</tt>.  The declaration

<blockquote> <tt>args:Array[String](1)</tt>  </blockquote>
should, as we have already mentioned, be read: "<tt>args</tt> <em>is a value whose type
is an array of strings indexed by a single integer.</em>"   X10 arrays, unlike Java
or C++ arrays, may be indexed by arbitrarily many integers, so you have to 
tell the compiler what sort of indexing you want.  Don't be confused here: the
"<tt>(1)</tt>" is not the size of the array: it is how you index it.</dd>
 <dt><b>line 2:</b></dt>
	<dd>
 X10 uses a call to the method <tt>size</tt> to get the number of elements in
an array.  You can also write simply <tt>args.size</tt> as well: the size of an
X10 array is one of its properties. Using "<tt>length</tt>", as Java does,
would be misleading, because X10 arrays can be n-dimensional, not just
1-dimensional.

<div class="p"><!----></div>
X10 uses ordinary parentheses, and not square brackets, to access array elements.  
Thus, since <tt>args</tt> is indexed by a single integer, <tt>args(k)</tt> is the
entry in <tt>args</tt> indexed by the integer <tt>k</tt>.  X10, like most other
languages, normally starts array indexing from 0, although the X10 programmer can
specify other index domains. There is no reason to get fancy about <tt>args</tt>, however,
so its first element is <tt>args(0)</tt>. Arrays in X10 are a whole subject unto
themselves that we will get to in Chapter .

<div class="p"><!----></div>
We use <tt>Int</tt>'s static method <tt>parse</tt> to convert the command line input
from a <tt>String</tt> to an <tt>Int</tt>.  Then the conditional operator, 
"<tt>?:</tt>" allows us to choose a value:
it begins by testing its first operand, which must must evaluate to "true" or
"false",  a <tt>Boolean</tt>: if it evaluates to "true", the value of the
expression is the second operand; otherwise the value is the third.
Once again, X10 tries to be consistent with Java and C++.</dd>
</dl> 
The next step is a little more involved.  We used a random number generator
that the X10 library provided for us.  Suppose we were disappointed in
it for some reason and wanted to try another.  It would be nice if the generator
were a parameter to the computation.  To get there, we have to pull the main loop
out of <tt>main</tt> and put it in its own method, one parameter of which is the generator:

<pre>
&nbsp;1&nbsp;public&nbsp;static&nbsp;def&nbsp;countPoints(n:&nbsp;Int,&nbsp;rand:&nbsp;()=&#62;Double)&nbsp;{
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;inCircle:&nbsp;Double&nbsp;=&nbsp;0.0;
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(var&nbsp;j:Long&nbsp;=&nbsp;1;&nbsp;j&lt;=n;&nbsp;j++)&nbsp;{
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;x&nbsp;=&nbsp;rand();
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;y&nbsp;=&nbsp;rand();
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(x*x&nbsp;+y*y&nbsp;&lt;=&nbsp;1.0)&nbsp;inCircle++;
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;inCircle;
&nbsp;9&nbsp;}&nbsp;
</pre>

<div class="p"><!----></div>
The new ingredient here is the declaration of <tt>rand</tt>.  As usual, its type follows
a colon (":"), but what's there is not just a name: the syntax for the type
"<tt>()=&#62;Double</tt>"
 is read: "<em>a function that takes no arguments and returns a <tt>Double</tt>.</em>"
There is no strictly analogous construct yet in Java, although one is planned, 
and the closest thing in C++ is the "function pointer" <tt>double (*rand)()</tt>.    

<div class="p"><!----></div>
How do we create the function to pass in as <tt>rand</tt>?  Here's one approach: in
<tt>main()</tt>, put
 
<pre>&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;r&nbsp;=&nbsp;new&nbsp;Random();
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;rand&nbsp;=&nbsp;()&nbsp;=&#62;&nbsp;r.nextDouble();
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;inCircle&nbsp;=&nbsp;countPoints(N,&nbsp;&nbsp;rand);&nbsp;&nbsp;
</pre>
The new lines are 2 and 3: 

<dl compact="compact">
 <dt><b>line 2</b></dt>
	<dd> says that <tt>rand</tt> is a function with no arguments whose body
is the expression <tt>r.nextDouble()</tt>, which is its return value.  This is, as you would guess,
just a simple example of a much more general facility, and we'll see a lot of 
examples later that will flesh out how to use it. 

<div class="p"><!----></div>
One important thing to understand is that the declaration of <tt>rand</tt> captures the
runtime value of <tt>r</tt>.  If we put this code in the body of a loop, then each time through
the loop, <tt>rand</tt> would use the new value of <tt>r</tt> that is yielded by the constructor
<tt>new Random()</tt>.

<div class="p"><!----></div>
The right-hand side of the declaration is often called a
"closure" in the literature (because of the way variables from the surrounding
context (like <tt>r</tt> here) are captured and kept until needed).  You'll also
see languages like X10 describing themselves as supporting "first-class functions",
which is simply a way of saying that they allow you to work with closures
in exactly the same way you would with any other sort of value, like an Int: you
can assign one, pass it as an argument, </dd>
 <dt><b>line 3</b></dt>
	<dd> replaces the whole loop in lines 8 through 12 of
our original with the call to our new method <tt>countPoints</tt>.</dd>
</dl>  

<div class="p"><!----></div>
The cleaned-up version of this code is
<a href="http://dist.codehaus.org/x10/documentation/guide/src/montePi/MontePi2.x10">montePi/MontePi2.x10</a>.

<div class="p"><!----></div>
There are one or two things we could do the pretty it up even more, but enough for now.
It is time to look at how to parallelize it.

     <h3><a name="tth_sEc2.4">
2.4</a>&nbsp;&nbsp;Enter The Second Processor</h3><a name="sec:esp">
</a>
We are going to present several parallel versions of our code.  We'll begin with
a version that assumes shared memory: multiple threads running on a single
machine.  Most PCs these days have
dual-processor CPUs, so a factor of 2 speedup is available right out of the box,
<em>if</em> your code can effectively use both processors.

<div class="p"><!----></div>
For our &#960; calculator, the changes are simple: we just have to be able to
say "start n threads going, each with its own independent random number
generator, and when each has done it's share of the work, sum the hits from all
n and divide by the total number of points tried."  

<div class="p"><!----></div>
X10 avoids the term "thread", because it (together with "process" ) has
a variety of meanings in different contexts.  Instead, X10 uses the term 
<em>activity</em> to mean a sequential thread of control. We'll be more loose here
and use whichever term seems more natural (to us!) at the moment, but you
should be aware of X10's convention when reading other literature.

<div class="p"><!----></div>
Figure  shows the relevant part of our new, parallel <tt>main</tt>.
We'll go through it line by line.

<div class="p"><!----></div>
<a name="tth_fIg3">
</a> <hr />

<pre>&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;N&nbsp;=&nbsp;args.size()&nbsp;&#62;&nbsp;0&nbsp;?&nbsp;Long.parse(args(0))&nbsp;:&nbsp;100000;
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;THREADS&nbsp;=&nbsp;args.size()&nbsp;&#62;&nbsp;1&nbsp;?&nbsp;Int.parse(args(1))&nbsp;:&nbsp;&nbsp;4;
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;nPerThread&nbsp;=&nbsp;N/THREADS;
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;inCircle&nbsp;=&nbsp;new&nbsp;Array[Long](1..THREADS);
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finish&nbsp;for(var&nbsp;k:&nbsp;Int&nbsp;=1;&nbsp;k&lt;=THREADS;&nbsp;k++)&nbsp;{
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;r&nbsp;=&nbsp;new&nbsp;Random(k*k&nbsp;+&nbsp;k&nbsp;+&nbsp;1);&nbsp;&nbsp;&nbsp;
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;rand&nbsp;=&nbsp;()&nbsp;=&#62;&nbsp;r.nextDouble();
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;kk&nbsp;=&nbsp;k;
&nbsp;9&nbsp;&nbsp;&nbsp;	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async&nbsp;inCircle(kk)&nbsp;=&nbsp;countPoints(nPerThread,rand);
10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;totalInCircle:&nbsp;Long&nbsp;=&nbsp;0;
12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(var&nbsp;k:&nbsp;Int&nbsp;=1;&nbsp;k&lt;=THREADS;&nbsp;k++)&nbsp;{
13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totalInCircle&nbsp;+=&nbsp;inCircle(k);
14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;pi&nbsp;=&nbsp;(4.0*totalInCircle)/N;
</pre>
<hr />


<center>Figure 3: Shared memory parallel code for computing &#960;</center><a name="fig:mcpm">
</a>

<div class="p"><!----></div>

<dl compact="compact">
 <dt><b>lines 1-3:</b></dt>
	<dd> We read the number of points to try, <tt>N</tt>, and
the number of threads to use, <tt>THREADS</tt>, from the command-line arguments, if
they are supplied; otherwise we just use 100,000 points and 4 threads as the
default. The number of points each thread will try is <tt>nPerThread</tt>.</dd>
 <dt><b>line 4:</b></dt>
	<dd>
The right-hand side is the X10 idiom for constructing an array that is indexed
by a single integer running from <tt>1</tt> to <tt>THREADS</tt>.  
The
entries in the array are initialized to <tt>0</tt>.   You might wonder what
declaring <tt>inCircle</tt> here to be a "<tt>val</tt>" implies: what is
it that cannot be changed because <tt>inCircle</tt> is a <tt>val</tt>?  The answer
is that <tt>inCircle</tt>'s value is always going to be the array it is initialized to
by the right-hand side of this line, but during the program's run, the individual
elements of that array may be assigned to as needed.

<div class="p"><!----></div>
The array elements are going to be <tt>Long</tt>s, which are 64-bit integers.</dd>
 <dt><b>line 5:</b></dt>
	<dd> There is nothing unusual about the "<tt>for</tt>" loop part of
this line. The interesting part is the "<tt>finish</tt>".  The whole
point of this loop is to spawn some number of
independent activities, each computing how many hits
out of a possible  <tt>nPerThread</tt> land in the circle.  We can't do any
further processing until we are sure that all of these activities have run to
completion.  That is what "<tt>finish</tt>" guarantees: control will not reach
the statement after that guarded by a <tt>finish</tt> until all of the activities
spawned in the <tt>finish</tt>'s statement have completed.  So when we get to line
11, we can be sure that every entry in <tt>inCircle</tt> has been correctly set.</dd>
 <dt><b>line 6:</b></dt>
	<dd>  The constructor <tt>Random()</tt>, if called with no arguments,
uses the number of milliseconds from some fixed time as the "seed" to begin
generating its random numbers. Alas, less than a millisecond may elapse between
the creation of two or more of our threads, and when that happens, we get the
same sequences in several threads.  So we've spiced things up by using the loop
counter <tt>k</tt> to generate a unique seed for each activity.</dd>
 <dt><b>lines 8 and 9:</b></dt>
	<dd>
The idiom for spawning an activity
at the current processor is "<tt>async <em>statement</em></tt>".
The statement is queued for execution, and control may then be returned to the
originating activity whenever the X10 runtime's activity manager wishes: it
could be immediately, or it could be after the new activity has been allowed some time.
The important point is that we do not have to wait for the new activity to complete
before returning control to the original activity.  The effect of the <tt>for</tt>
loop is, therefore, to get <tt>THREADS</tt> activities up and running <em>
concurrently</em>.

<div class="p"><!----></div>
Why do we introduce <tt>kk</tt> in line 8?  Using <tt>kk</tt> rather than <tt>k</tt> in
the <tt>async</tt> ensures that that activity is using the value of <tt>
k</tt> in force when the <tt>async</tt> is spawned.  Were we to use <tt>k</tt> inside the
<tt>async</tt>, and it happened that the execution of the <tt>async</tt> got
sufficiently delayed, the <tt>async</tt> could see a value of <tt>k</tt> greater than
that at time of the <tt>async</tt>'s creation, and then it would set the wrong
array entry in line 9.

<div class="p"><!----></div>
Line 9 ends by calling <tt>countPoints</tt>, as in our serial code.
We've allowed its first argument, the number of points to try, to be a <tt>Long</tt>.
As we have seen, <tt>Longs</tt> are 64-bit integers.
With all these threads at our command, we can afford to think <em>big</em> when it comes
to trying lots of points, but
otherwise, the method <tt>countPoints</tt> is unchanged from before.

<div class="p"><!----></div>

<pre>
public&nbsp;static&nbsp;def&nbsp;countPoints(n:Long,&nbsp;rand:()=&#62;Double){
&nbsp;&nbsp;...
}
</pre></dd>
 <dt><b>lines 11-14: </b></dt>
	<dd> When we get to line 11, we can compute the total number
of hits in the circle out of the <tt>N</tt> points we generated, because we can be sure that every entry in
<tt>inCircle</tt> has been correctly set.</dd>
 <dt><b>line 15: </b></dt>
	<dd>
Once the loop in lines 12-14 has computed the total number of hits in the circle, 
we have to normalize the result to get the final answer.  <tt>N</tt> is the total number of points
we tried (each thread got <tt>N/THREADS == nPerThread</tt> points to try).
Using a <tt>Double</tt>, <tt>4.0</tt>, as the first term in the right hand side forces
the compiler to generate code for converting the two <tt>Long</tt>s to <tt>Doubles</tt> before
the arithmetic is performed.</dd>
</dl>

<div class="p"><!----></div>
Here's our console log for running the code from a Unix-style terminal window.
The Unix <tt>time</tt> command
executes the program and then produces three time estimates: total CPU usage ("real"),
wall-clock elapsed time ("user"), and system overhead ("sys").
This timing is for a 3GHz dual-processor laptop.   

<pre>%&nbsp;time&nbsp;x10&nbsp;MontePiAsync&nbsp;10000000&nbsp;1
The&nbsp;value&nbsp;of&nbsp;pi&nbsp;is&nbsp;3.1402504

real	0m2.426s
user	0m3.368s
sys	0m0.165s
%&nbsp;time&nbsp;x10&nbsp;MontePiAsync&nbsp;10000000&nbsp;2
The&nbsp;value&nbsp;of&nbsp;pi&nbsp;is&nbsp;3.1405268

real	0m1.370s
user	0m1.893s
sys	0m0.109s
</pre>
Not bad: an overall factor of  3.368/1.893 = 1.78 speed-up for the observed time-to-completion
out of a best possible of 2.  

<div class="p"><!----></div>
You can find the whole program in
<a href="http://dist.codehaus.org/x10/documentation/guide/src/montePi/MontePiAsync.x10"><tt>montePi/MontePiAsync.x10</a></tt>.

<div class="p"><!----></div>
 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;A Thousand CPUs Are Better Than Two</h2>

     <h3><a name="tth_sEc3.1">
3.1</a>&nbsp;&nbsp;Distributing Work</h3><a name="sec:distwork">
</a>
To get heavy-duty concurrency, we have to distribute work across many
processors, which usually means we have to scale out to more than one
(shared-memory) machine.

<div class="p"><!----></div>
To this end, X10 provides a type, <tt>Place</tt>, that is best thought of as
an address space in which activities may run.
The physical reality is that different <tt>Place</tt>s may refer to the same
physical processor and may share physical memory, but from the programmer's
point of view:

<ul>
<li> The running program has a single address space.
<div class="p"><!----></div>
</li>

<li> The distinct <tt>Places</tt> partition that address space: no two <tt>
Places</tt> have any storage in common.
<div class="p"><!----></div>
</li>

<li> But, since there is a single global address space, an activity at one
<tt>Place</tt> may refer directly to storage at another.
<div class="p"><!----></div>
</li>
</ul>   

<div class="p"><!----></div>
<tt>Place.MAX_PLACES</tt> is the number of <tt>Places</tt> available to a program.  It is fixed
at program start-up and cannot be altered thereafter.

<div class="p"><!----></div>
Each <tt>Place</tt> has an integer id:
if <tt>p</tt> is a <tt>Place</tt>, then <tt>p.id</tt> is its id.  An activity can find
out at which <tt>Place</tt> it is executing by evaluating the expression <tt>
here</tt>.  The keyword <tt>here</tt> is reserved for this purpose alone.  The id of
the current activity's <tt>Place</tt> is <tt>here.id</tt>. The <tt>Place</tt> whose id 
is "<tt>i</tt>" can be got by evaluating <tt>Place.place(i)</tt>.<a href="#tthFtNtAAC" name="tthFrefAAC"><sup>2</sup></a>

<div class="p"><!----></div>
The X10 runtime begins a program's execution by creating a single activity, the
"root" activity, that calls
the program's <tt>main()</tt>.  The root activity's home <tt>Place</tt> is called
<tt>Place.FIRST_PLACE</tt>, and by convention, it is the <tt>Place</tt> whose id is
<tt>0</tt>.

<div class="p"><!----></div>
 So the question is: how does information at one <tt>Place</tt> get to another? 
 One simple way is to use an "<tt>at(p)</tt>"  statement: if the identifier <tt>
 p</tt> names a <tt>Place</tt>, and if <tt>computeAnInt()</tt> is a method that
 computes an <tt>Int</tt>, then
 
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;anInt&nbsp;=&nbsp;at(p)&nbsp;computeAnInt();&nbsp;
</pre> 
 means: 
 
<blockquote>
 Pause this activity.  Go to the <tt>Place p</tt>, and then call <tt>computeAnInt()</tt>.
 Send the result back here to this <tt>Place</tt>, assign the value to <tt>anInt</tt>,
 and then let this activity continue.
 </blockquote>
 The requesting activity is
 blocked while the remote activity computes the needed value.

<div class="p"><!----></div>
 If you do not want to wait around yet for the value to be computed and assigned,
 things are not so simple.  You might think, for instance,
 that something like the obvious "<tt>async val anInt =  at(p) computeAnInt();</tt>"
 might work, but it doesn't.   Just as with variables declared in <tt>for</tt>  loops,
 the declaration of <tt>anInt</tt> 
 in an <tt>async</tt>'s body means that it is not available outside of it.  This
 is consistent with Java and C++ (and just about every other language): a
 declaration within a statement's body is visible only in that body.

<div class="p"><!----></div>
The secret is to separate the assignment from the declaration:
 
<pre>
&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;anInt:&nbsp;Int;
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;finish&nbsp;{&nbsp;
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;some&nbsp;code&nbsp;not&nbsp;using&nbsp;anInt&nbsp;can&nbsp;go&nbsp;here&nbsp;*/
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;async&nbsp;{&nbsp;anInt&nbsp;=&nbsp;at(p)&nbsp;computeAnInt();&nbsp;}
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;maybe&nbsp;more&nbsp;code&nbsp;not&nbsp;using&nbsp;anInt&nbsp;here,&nbsp;too!&nbsp;*/
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;at&nbsp;last:&nbsp;anInt&nbsp;can&nbsp;be&nbsp;used&nbsp;here!&nbsp;*/&nbsp;
</pre> 
As the comments in this code suggest, the <tt>async</tt> has to be inside a
 <tt>finish</tt> block, and  <tt>anInt</tt> cannot be used until control leaves the block.

<div class="p"><!----></div>
Passing a "<tt>var</tt>" into an <tt>async</tt>'s block is also possible, but (of
course) risky because of the possibility of race conditions, an example of which
we'll discuss in the next section. If you change <tt>val</tt> to <tt>var</tt> in
line 1, the code works as before, but be aware that the <tt>finish</tt> must be
present in the same scope as the <tt>var</tt> that is used in the <tt>async</tt>. 
That is, you cannot just spawn an activity into which you pass a variable 
unless that activity has a visible bound on its lifetime.  For example, the
code

<pre>&nbsp;
&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;syncIt()&nbsp;{
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;anInt:&nbsp;Int;
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async&nbsp;anInt&nbsp;=&nbsp;3;
&nbsp;4&nbsp;&nbsp;&nbsp;}

</pre>
will cause the compiler to complain:

<blockquote><tt>
Local variable &#228;nInt" cannot be captured in an async if<br />
there is no enclosing finish in the same scoping-level<br />
as &#228;nInt"; consider changing &#228;nInt" from var to val.</tt>
</blockquote>
What the compiler wants is a <tt>finish</tt> surrounding the <tt>async</tt> within the
scope of the declaration of <tt>anInt</tt>.  To be precise, what will <em>not</em>
work is:

<pre>&nbsp;
&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;syncIt()&nbsp;{
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finish&nbsp;{
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;anInt:&nbsp;Int;
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async&nbsp;anInt&nbsp;=&nbsp;3;
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;}

</pre>
What <em>will</em> work is inserting the <tt>finish</tt> so that <tt>anInt</tt> is alive
and visible when the <tt>finish</tt> completes:

<pre>&nbsp;
&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;syncIt()&nbsp;{
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;anInt:&nbsp;Int;
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finish&nbsp;{
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async&nbsp;anInt&nbsp;=&nbsp;3;
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;}

</pre>

<div class="p"><!----></div>
Now that we know how to move data around and in and out of <tt>asyncs</tt>, we are
ready to rework our code.

<div class="p"><!----></div>
      <h3><a name="tth_sEc3.2">
3.2</a>&nbsp;&nbsp; Don't Try This On <em>Your</em> Computer</h3>
Let's get started with our multi-processor code with some high-level pseudo-code.
We are going to go all out and not only use several <tt>Places</tt>, but at each
<tt>Place</tt>, we'll use several activities.  Here we go:

<dl compact="compact">
<a name="lbl:mpchl">
</a>
	<dd><tt>main</tt>:
      Read the command line to get the number of places to use.
      For each <tt>Place</tt>, call the function <tt>countAtP</tt> to get
      that one <tt>Place</tt>'s contribution, and add up all of them
      to get the final answer.</dd>

	<dd><tt>countAtP</tt>:
      Essentially the same as the loop over the set of threads
      in <tt>MontePiAsync</tt>'s <tt>main</tt>: 
      add up the counts from several threads at one <tt>Place</tt>, as
     returned by <tt>countPoints</tt>.  See Figure <a href="#fig:mcpm">3</a>;</dd>

	<dd><tt>countPoints</tt>:
      Called once per thread, and really <em>is</em> the same as its namesake in
      <tt>MontePi2</tt> and <tt>MontePiAsync</tt>: here is where we actually call
      the random number generator.</dd>
</dl>

<div class="p"><!----></div>
In thinking about this code, keep in mind that a really high-performance computer
can provide literally thousands of <tt>Place</tt>s, but,
for this sort of CPU-intensive activity, at any given <tt>Place</tt>, it is likely
to be worthwhile running at most a dozen or so threads, probably fewer.  That
said, we might ask ourselves whether it makes sense to use different strategies
for accumulating our results in <tt>countAtP</tt>,  which we expect to have very
few contributors, versus <tt>main</tt>, which may have thousands.

<div class="p"><!----></div>
When we only have two or three integers to add together, it might make sense to
use a single <tt>var count:Long</tt> to accumulate the total count, rather than using
an array (as we did in the <tt>main</tt> for <tt>MontePiAsync</tt>).
Here's a first cut:

<pre>&nbsp;1&nbsp;public&nbsp;static&nbsp;def&nbsp;countAtP(pId:Int,&nbsp;threads:Int,&nbsp;n:Long)&nbsp;{
&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;count:&nbsp;Long&nbsp;=&nbsp;0L;
&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;finish&nbsp;for&nbsp;(var&nbsp;j:&nbsp;Int&nbsp;=&nbsp;1;&nbsp;j&lt;=&nbsp;threads;&nbsp;j++)&nbsp;&nbsp;{
&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;jj&nbsp;=&nbsp;j;
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async&nbsp;{
&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;r&nbsp;=&nbsp;new&nbsp;Random(jj*Place.MAX_PLACES&nbsp;+&nbsp;pId));
&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;rand&nbsp;=&nbsp;()&nbsp;=&#62;&nbsp;r.nextDouble();
&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;+=&nbsp;&nbsp;countPoints(n,&nbsp;rand);
&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
10&nbsp;&nbsp;&nbsp;&nbsp;}
11&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;count;
12&nbsp;}
</pre>
Sadly, this approach is just plain wrong.

<div class="p"><!----></div>
The trouble is in line 8, where <tt>count</tt>'s value is updated.  If you are a
veteran of the parallel programming wars, you will recognize this as a classic
<em>race</em> condition. For the newcomers, here is a scenario that shows what's wrong:

<blockquote>
We begin with <tt>count</tt>'s value is initially set to 0.
Suppose that we are going to use just two threads, <tt>T1</tt> and <tt>T2</tt>.

<div class="p"><!----></div>
<tt>T1</tt> begins
executing first.  When it gets to line 7, it loads the value of <tt>count</tt>,
which is still 0, into the CPU. Just after the load completes,
the operating system's thread manager suspends <tt>T1</tt> for some reason. 

<div class="p"><!----></div>
A few nanoseconds later, the system lets <tt>T2</tt> start, and <tt>T2</tt> also gets
to line 7, where it loads  <tt>count</tt>.   Because <tt>T1</tt>
never completed updating <tt>count</tt>, <tt>T2</tt> finds 0 stored there, just as
<tt>T1</tt> did. So <tt>T2</tt> adds its value to 0, and stores the result back into
<tt>count</tt>'s value: <tt>count</tt> now is whatever <tt>T2</tt> computed.

<div class="p"><!----></div>
Once  <tt>T1</tt> is restarted, it adds its contribution to the value of <tt>
count</tt> that it has already loaded, namely, 0-it doesn't
do the load again.  But that means that it does not see the effect of
<tt>T2</tt>'s update. 
Therefore, what <tt>T1</tt> stores into <tt>count</tt> is just <tt>T1</tt>'s own
contribution, <em>and not its sum with <tt>T2</tt>'s</em>.  <tt>T2</tt>'s
contribution has been lost.

<div class="p"><!----></div>
Disaster!
</blockquote>
You can see why this is called a race. It is a particularly insidious sort of bug,
because sometimes you get the right answers, and sometimes you don't.
After all, the operating system did not <em>have</em> to suspend <tt>T1</tt> at just
the wrong moment.  It just happened to: the interrupt that
affected <tt>T1</tt> may have come from an external event having nothing to
do with <tt>MontePi</tt>.  Servicing the interrupt simply had to take precedence
over <tt>T1</tt>, so too bad, <tt>T1</tt> loses: that's life.

<div class="p"><!----></div>
The cure is simple enough: we just need to replace line 8 with

<pre>&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;atomic&nbsp;count&nbsp;+=&nbsp;countPoints(n,&nbsp;rand));
</pre>
When an X10 statement is guarded this way by the keyword <tt>atomic</tt>,
it is guaranteed that once a thread enters the statement,
no other thread may enter it until the original thread completes it.  

<div class="p"><!----></div>
In our original scenario, this means that once the first thread, <tt>T1</tt>,
starts executing line 8,  <tt>T2</tt> will be blocked from entering
line 8, while <tt>T1</tt> is still active there, even if for some reason the
operating system suspends <tt>T1</tt> for a while.  <tt>T2</tt> will be
suspended until <tt>T1</tt> finishes the assignment.  It slows things down,
but you get the right answer.

<div class="p"><!----></div>
Our new line 8 really is not a good solution, though, because
virtually all the time spent executing the statement is
in the expensive call to <tt>countPoints</tt>.  <tt>countPoints</tt>
does not depend on any resources shared by the two threads,
so there is no problem about the
two executing the call to <tt>countPoints</tt> concurrently.
The only shared resource is <tt>count</tt>, which
doesn't appear in <tt>countPoints</tt> at all.  So what we really want is:

<pre>&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;ourCount&nbsp;=&nbsp;&nbsp;countPoints(n,&nbsp;rand);
&nbsp;8*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;atomic&nbsp;count&nbsp;+=&nbsp;ourCount;
</pre>
Because only one activity at a time can execute an atomic statement,
clearly the smart thing is to keep it as small as possible.

<div class="p"><!----></div>
Races occur when multiple activities share a resource.  In this example, they share 
a piece of storage, but they could equally well share an output stream.  For
instance, suppose two activities
call <tt>Console.OUT.println</tt> at the same time.  What happens?  Answer:
it depends!  Sometimes each line will print as desired, sometimes the 
two lines will be interleaved, just like shuffling a deck of cards.  Try
the following code, for example:

<pre>public&nbsp;class&nbsp;HelloAsync&nbsp;{
&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;main(argv:Rail[String]!)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async&nbsp;Console.OUT.println("Hello,&nbsp;World");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async&nbsp;Console.OUT.println("Hola,&nbsp;Mundo");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async&nbsp;Console.OUT.println("Bonjour,&nbsp;Monde");
&nbsp;&nbsp;&nbsp;}
}
</pre>
Here's our console log for one shot at running it:

<pre>%&nbsp;x10&nbsp;HelloAsync
BHelonlo,j&nbsp;oWuorr,l&nbsp;dM
onde
Hola,&nbsp;Mundo
</pre>
The Spanish, "Hola, Mundo," got delivered in one shot, but the English
and French got a pretty well interleaved.  Who knows what might have happened
on another run!  Even more amusing: why was the <em>second</em> <tt>async</tt> the
one that wasn't interrupted?  The first, maybe-the last, not too surprising-but,
the <em>second</em>?

<div class="p"><!----></div>
Putting all this discussion to use, we get a first cut at <tt>MontePiCluster</tt>
in Figure  on the next page.

<div class="p"><!----></div>
<a name="tth_fIg4">
</a> <hr />

<pre>import&nbsp;x10.util.Random;
import&nbsp;x10.util.Timer;
public&nbsp;class&nbsp;MontePiCluster&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;countAtP(pId:&nbsp;Int,&nbsp;threads:&nbsp;Int,&nbsp;n:&nbsp;Long)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;count:&nbsp;Long&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finish&nbsp;for&nbsp;(var&nbsp;j:&nbsp;Int&nbsp;=&nbsp;1;&nbsp;j&lt;=&nbsp;threads;&nbsp;j++)&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;jj&nbsp;=&nbsp;j;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;r&nbsp;=&nbsp;new&nbsp;Random(jj*Place.MAX_PLACES&nbsp;+&nbsp;pId);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;rand&nbsp;=&nbsp;()&nbsp;=&#62;&nbsp;r.nextDouble();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;jCount&nbsp;=&nbsp;countPoints(n,&nbsp;rand);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;atomic&nbsp;count&nbsp;+=&nbsp;jCount;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;count;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;countPoints(n:Long,&nbsp;rand:()=&#62;Double)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;inCircle:&nbsp;Long&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(var&nbsp;j:&nbsp;Long=1;&nbsp;j&lt;=n;&nbsp;j++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;x&nbsp;=&nbsp;rand();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;y&nbsp;=&nbsp;rand();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(x*x&nbsp;+y*y&nbsp;&lt;=&nbsp;1.0)&nbsp;inCircle++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;inCircle;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;main(args:&nbsp;Array[String](1))&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;N&nbsp;=&nbsp;args.size()&nbsp;&#62;&nbsp;0&nbsp;?&nbsp;Long.parse(args(0))&nbsp;:&nbsp;1000000L;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;np&nbsp;=&nbsp;args.size()&nbsp;&#62;&nbsp;1&nbsp;?&nbsp;Int.parse(args(1))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&nbsp;Place.MAX_PLACES;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;tPerP&nbsp;=&nbsp;args.size()&nbsp;&#62;&nbsp;2&nbsp;?&nbsp;Int.parse(args(2))&nbsp;:&nbsp;4;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;nPerT&nbsp;=&nbsp;N/(np&nbsp;*&nbsp;tPerP);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;inCircle&nbsp;=&nbsp;new&nbsp;Array[Long](1..np);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finish&nbsp;for(var&nbsp;k:&nbsp;Int&nbsp;=&nbsp;1;&nbsp;k&lt;=np;&nbsp;k++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;kk&nbsp;=&nbsp;k;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;pk&nbsp;=&nbsp;Place.place(k-1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async&nbsp;inCircle(kk)&nbsp;=&nbsp;at(pk)&nbsp;countAtP(kk,tPerP,nPerT);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;totalInCircle:&nbsp;Long&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(var&nbsp;k:&nbsp;Int&nbsp;=1;&nbsp;k&lt;=np;&nbsp;k++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;totalInCircle&nbsp;+=&nbsp;inCircle(k);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;pi&nbsp;=&nbsp;(4.0*totalInCircle)/N;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.OUT.println("The&nbsp;value&nbsp;of&nbsp;pi&nbsp;is&nbsp;"&nbsp;+&nbsp;pi);
&nbsp;&nbsp;&nbsp;&nbsp;}
</pre>
<hr />


<center>Figure 4: Multi-place, multi-threaded Monte Carlo:
<a href="http://dist.codehaus.org/x10/documentation/guide/src/montePi/MontePiCluster.x10"><em>
montePi/MontePiCluster.x10</a></em></center><a name="fig:mpmtmc">
</a>

<div class="p"><!----></div>
     <h3><a name="tth_sEc3.3">
3.3</a>&nbsp;&nbsp;Once Again, We Can Do Better</h3><a name="sce:oawcdb">
</a> 

<div class="p"><!----></div>
First a simple piece of clean-up:
the idiom "<tt>atomic x += y</tt>" is so common, and more generally,
the situation where there is a single variable has to be updated atomically,
that X10 provides a set of types to help you out: <tt>AtomicInteger</tt>,
<tt>AtomicLong</tt>, <tt>AtomicBoolean</tt> and <tt>AtomicReference</tt> in
the package <tt>x10.util.concurrent. atomic</tt>.  Here's how one uses them.

<div class="p"><!----></div>
In the method <tt>countAtP</tt>, instead of declaring "<tt>var count:Long =
0L;</tt>", we use

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;count&nbsp;=&nbsp;new&nbsp;AtomicLong(0);
</pre>
Then, inside the loop body, we replace the pair of assignments 

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;ourCount&nbsp;=&nbsp;countPoints(n,&nbsp;rand);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;atomic&nbsp;count&nbsp;+=&nbsp;ourCount;

</pre> 
with the single method call, which the class <tt>AtomicLong</tt> guarantees to be
atomic:

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count.addAndGet(ourCount);
</pre>
Which is better, the <tt>atomic</tt> version
or the <tt>AtomicLong</tt>? From the point of view of performance, <tt>AtomicLong</tt>
should be a better choice, because, being more specialized, it should be able to
use the CPU's instruction set better to achieve the synchronization more cheaply
than the generic <tt>atomic</tt> statement. 

<div class="p"><!----></div>
Time now for something more substantial.  From the beginning we have been
talking about points in a circle.  But not a single point, as such, has occurred among
our data types.  It is time to remedy that and to make a start into exploiting
X10 as an object-oriented language.

<div class="p"><!----></div>
X10 actually provides more than one way to describe structured data.  Right now,
we'll work with the one closest to what you would see in Java and C++:

<pre>&nbsp;1&nbsp;public&nbsp;class&nbsp;Point2D&nbsp;{
&nbsp;2&nbsp;&nbsp;&nbsp;public&nbsp;val&nbsp;x:&nbsp;Double;
&nbsp;3&nbsp;&nbsp;&nbsp;public&nbsp;val&nbsp;y:&nbsp;Double;
&nbsp;4&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;this(x:&nbsp;Double,&nbsp;y:&nbsp;Double)&nbsp;{
&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.x&nbsp;=&nbsp;x;&nbsp;&nbsp;this.y&nbsp;=&nbsp;y;
&nbsp;6&nbsp;&nbsp;&nbsp;}
&nbsp;7&nbsp;&nbsp;&nbsp;public&nbsp;def&nbsp;magnitude()&nbsp;=&nbsp;x*x&nbsp;+&nbsp;y*y;
&nbsp;8&nbsp;}
</pre>
As usual, let's work our way line by line through this code.

<dl compact="compact">
 <dt><b>line 1:</b></dt>
	<dd>  This is how we would declare the class if we wanted it to be a top-level
class in its own file.  If we want to put the declaration in the file for <tt>MontePiCluster</tt>,
would use "<tt>public <em>static</em> class Point2D {...}</tt>" and include it as part of the
body of <tt>MontePiCluster</tt>.  The reason for adding "<tt>static</tt>" is that the
declaration is for something that is associated with the class <tt>
MontePiCluster</tt> and need not be aware of what is involved with individual
<em>instances</em> of <tt>MontePiCluster</tt>.

<div class="p"><!----></div>
By the way, X10 has a class called "<tt>Point</tt>" that is fundamental for working
with general arrays.  We
shall eventually have a lot to say a lot about it, but for now, we just wanted you to
know that we're using 
"<tt>Point2D</tt>" here, rather than the more natural "<tt>Point</tt>"
to avoid confusion with X10's (much more important and very
different) class. <dt><b>lines 2 and 3:</b></dt>
	<dd> We declare two instance fields here, both double-precision
numbers, <tt>x</tt> and <tt>y</tt>.  What "<tt>val</tt>" means in this context is that a value will be
assigned to the identifier in the constructor, and once assigned, cannot be
changed. Because both are declared "<tt>public</tt>",  any class that constructs
an instance <tt>pt</tt> of <tt>Point2D</tt> can use <tt>pt.x</tt> and <tt>pt.y</tt> to
access their values.</dd>
 <dt><b>line 4:</b></dt>
	<dd>  This is the X10 idiom for a constructor.
The keyword <tt>def</tt>, as noted before, signals a method declaration.  When one writes

<pre>&nbsp;&nbsp;&nbsp;val&nbsp;pt&nbsp;=&nbsp;new&nbsp;Point2D(3.0,&nbsp;5.1);
</pre>
it is this method that will get called.</dd>
 <dt><b>line 5:</b></dt>
	<dd> An argument like <tt>x</tt> that has the same name as a member
field will hide that field, so you need to say <tt>this.x</tt> in this context
when what you mean is the field, and not the argument.  Some people prefer to
say "shadows" rather than "hides."</dd>
 <dt><b>line 7:</b></dt>
	<dd>  Another method declaration: <tt>magnitude</tt> returns the
(squared!) magnitude, x<sup>2</sup> + y<sup>2</sup>, of the point.  In simple cases like this, where the
function is just returning the value of an expression, you don't need to write
out the function body as

<pre>&nbsp;&nbsp;&nbsp;{&nbsp;return&nbsp;x*x&nbsp;+&nbsp;y*y;&nbsp;}
</pre>
As in this example, the expression to be returned after an "=" sign will do.</dd>
</dl>
Let's rewrite <tt>countPoints</tt> using our new class:

<pre>&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;def&nbsp;countPoints(n:Long,&nbsp;rand:()=&#62;Double)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;inCircle:&nbsp;Long&nbsp;=&nbsp;0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(var&nbsp;j:&nbsp;Long=1;&nbsp;j&lt;=n;&nbsp;j++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val&nbsp;pt&nbsp;=&nbsp;new&nbsp;Point2D(rand(),&nbsp;rand());
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pt.magnitude()&nbsp;&lt;=&nbsp;1.0)&nbsp;inCircle++;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;inCircle;
&nbsp;&nbsp;&nbsp;}
</pre>
We could even go further and instead of using <tt>rand</tt>, we could replace <tt>rand</tt>
with a function <tt>rpt</tt> that returns exactly the random point we need: 

<pre>public&nbsp;static&nbsp;def&nbsp;countPoints(n:Long,&nbsp;rpt:()=&#62;Point2D)&nbsp;{
</pre>
To do this, we have to replace the definition of <tt>rand</tt> in <tt>countAtP</tt> with 
the definition for our new function, <tt>rpt</tt>:

<pre>val&nbsp;rpt&nbsp;=&nbsp;()=&#62;new&nbsp;Point2D(r.nextDouble(),r.nextDouble());
</pre>

<div class="p"><!----></div>
You can find the final version in
<a href="http://dist.codehaus.org/x10/documentation/guide/src/montePi/MontePiCluster2.x10"><em>
montePi/MontePiCluster2.x10</a></em>.

<div class="p"><!----></div>
<b>Exercise:</b> You might want to try a slight variation on this theme:  write a method that
uses one or more <tt>Place</tt>s to sum the values of a function  <tt>f:(d:Double)=&#62;Double</tt> over a 
sequence of <tt>n Doubles</tt>  <tt>d, d+delta, ... d+n*delta</tt>:

<div class="p"><!----></div>

<blockquote>
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center" cellspacing="0"  cellpadding="2"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<small>n&#8722;1</small><!--sup
--><br /><font size="+3">&#8721;<br />
</font><small>k=0</small>&nbsp;<br /></td><td nowrap="nowrap" align="center">
f(d + k&#948;)</td></tr></table>
</td><td width="1%">(1)</td></tr></table>

</blockquote>

<div class="p"><!----></div>
For debugging sake, try some simple <tt>f</tt>'s to begin, like <tt>(d:Double) =&#62; 1.0</tt>.  Then you
can go hog-wild using your own functions ( <tt>(d:Double)=&#62;d*d</tt>), or
the functions in <tt>x10.Math</tt>, like <tt>sin</tt>, <tt>log</tt>, and 
<tt>sqrt</tt>.

<div class="p"><!----></div>
The amusing questions are: what part of the sum is a given activity responsible for,
and how do we combine the partial results?  Combining the results is essentially
the same as as what we've done for <tt>MontePiCluster</tt> here.  Splitting up the
sum, though, requires some thought.  Here's one approach:

<div class="p"><!----></div>
If there are p<sub>all</sub> <tt>Place</tt>s in all, and there are a activities
in parallel at each <tt>Place</tt>, there will be ap<sub>all</sub> = a<sub>all</sub>
activities in all. Since there are
n values to be summed, each activity should handle roughly n/a<sub>all</sub>
additions-"roughly" because a<sub>all</sub> might not divide n evenly.
One solution is to let the j-th
activity ( j=0,1,...,a&#8722;1) at the <tt>Place</tt> whose id is <tt>p</tt>  take care of the values 
d+k&#948;, where k runs over (p a+j)+h a<sub>all</sub> for h = 0,1,...

<div class="p"><!----></div>
We'll come back to this sort of loop in gory detail in the advanced examples.

</tt><hr /><h3>Footnotes:</h3>

<div class="p"><!----></div>
<a name="tthFtNtAAB"></a><a href="#tthFrefAAB"><sup>1</sup></a>The home
page for JavaDoc is hosted at 
<a href="http://www.oracle.com/technetwork/java/javase/documentation/index-jsp-135444.html">oracle.com</a>,
but for a quick executive summary, see
<a href="http://en.wikipedia.org/wiki/Javadoc">the Wikipedia entry</a>. 
<div class="p"><!----></div>
<a name="tthFtNtAAC"></a><a href="#tthFrefAAC"><sup>2</sup></a>
If you've programmed using the MPI
library,  <tt>Place.MAX_PLACES</tt> is analogous to
what you get by calling <tt>MPI_Comm_size</tt> and the <tt>id</tt> is analogous to
what <tt>MPI_Comm_rank</tt> gives you.  The UPC equivalents are THREADS and MYTHREAD.

<br /><br /><hr />
</html>
