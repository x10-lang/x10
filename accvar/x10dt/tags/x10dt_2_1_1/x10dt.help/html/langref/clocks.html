<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>Clocks</title>
</head>

<body>
 <h1><a name="tth_chAp1">
Chapter 15 </a><br />Clocks</h1><a name="XtenClocks">
</a>

<div class="p"><!----></div>
Many concurrent algorithms proceed in phases: in phase k, several
activities work independently, but synchronize together before proceeding on
to phase k+1. X10 supports this communication structure (and many
variations on it) with a generalization of barriers 
called <em>clocks</em>. Clocks are designed so that programs which follow a
simple syntactic discipline will not have either deadlocks or race conditions.

<div class="p"><!----></div>
The following minimalist example of clocked code has two worker activities A
and B, and three phases. In the first phase, each worker activity says its
name followed by 1; in the second phase, by a 2, and in the third, by a 3.  
So, if <b>say</b> prints its argument, 
<b>A-1 B-1 A-2 B-2 B-3 A-3</b>
would be a legitimate run of the program, but
<b>A-1 A-2 B-1 B-2 A-3 B-3</b>
(with <b>A-2</b> before <b>B-1</b>) would not.

<div class="p"><!----></div>
The program creates a clock <b>cl</b> to manage the phases.  Each participating
activity does
the work of its first phase, and then executes <b>next;</b> to signal that it
is finished with that work. <b>next;</b> is blocking, and causes the participant to
wait until all participant have finished with the phase - as measured by the
clock <b>cl</b> to which they are both registered.  
Then they do the second phase, and another <b>next;</b> to make sure that
neither proceeds to the third phase until both are ready.  This example uses
<b>finish</b> to wait for both particiants to finish.  

<div class="p"><!----></div>

<div class="p"><!----></div>
<pre>
class ClockEx {
  static def say(s:String) = 
     { atomic{x10.io.Console.OUT.println(s);} }
  public static def main(argv:Rail[String]) {
    finish async{
      val cl = Clock.make();
      async clocked(cl) {// Activity A
        say(&#196;-1");
        next;
        say(&#196;-2");
        next;
        say(&#196;-3"); 
      }// Activity A

<div class="p"><!----></div>
      async clocked(cl) {// Activity B
        say("B-1");
        next;
        say("B-2");
        next;
        say("B-3"); 
      }// Activity B
    }
  }
 }
</pre>

<div class="p"><!----></div>
This chapter describes the syntax and semantics of clocks and
statements in the language that have parameters of type <b>Clock</b>. 

<div class="p"><!----></div>
The key invariants associated with clocks are as follows.  At any
stage of the computation, a clock has zero or more <em>registered</em>
activities. An activity may perform operations only on those clocks it
is registered with (these clocks constitute its <em>clock set</em>). 
An attempt by an activity to operate on a clock it is not registered with
will cause a 
<b>ClockUseException</b>
to be thrown.  
An activity is registered with zero or more clocks when it is created.
During its lifetime the only additional clocks it can possibly be registered with
are exactly those that it creates. In particular it is not possible
for an activity to register itself with a clock it discovers by
reading a data structure.

<div class="p"><!----></div>
The primary operations that an activity <b>a</b> may perform on a clock <b>c</b>
that it is registered upon are: 

<ul>
<li> It may spawn and simultaneously  <em>register</em> a new activity on
      <b>c</b>, with the statement       <b>async clocked(c)S</b>.
<div class="p"><!----></div>
</li>

<li> It may <em>unregister</em> itself from <b>c</b>, with <b>c.drop()</b>.  After
      doing so, it can no longer use most primary operations on <b>c</b>.
<div class="p"><!----></div>
</li>

<li> It may <em>resume</em> the clock, with <b>c.resume()</b>, indicating that it
      has finished with the current phase associated with <b>c</b> and is ready
      to move on to the next one.
<div class="p"><!----></div>
</li>

<li> It may <em>wait</em> on the clock, with <b>c.next()</b>.  This first does
      <b>c.resume()</b>, and then blocks the current activity until the start
      of the next phase, <em>viz</em>, until all other activities registered on that
      clock have called <b>c.resume()</b>.
<div class="p"><!----></div>
</li>

<li> It may <em>block</em> on all the clocks it is registered with
      simultaneously, by the command <b>next;</b>.  This, in effect, calls
      <b>c.next()</b> simultaneously 
      on all clocks <b>c</b> that the current activity is registered with.
<div class="p"><!----></div>
</li>

<li> Other miscellaneous operations are available as well; see the
      <b>Clock</b> API.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>

</body>
</html>