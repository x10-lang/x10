<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>Method Resolution</title>
</head>

<body>
 <h2><a name="tth_sEc1">
21</a>&nbsp;&nbsp;Method Resolution</h2>

<div class="p"><!----></div>
Method resolution is the problem of determining, statically, which method (or
constructor or operator)
should be invoked, when there are several choices that could be invoked.  For
example, the following class has two overloaded <b>zap</b> methods, one taking
an <b>Object</b>, and the other a <b>Resolve</b>.  Method resolution will figure
out that the call <b>zap(1..4)</b> should call <b>zap(Object)</b>, and
<b>zap(new Resolve())</b> should call <b>zap(Resolve)</b>.  

<div class="p"><!----></div>
<pre>
class Resolve {
  static def zap(Object) = &#214;bject";
  static def zap(Resolve) = "Resolve";
  public static def main(argv:Array[String](1)) {
    Console.OUT.println(zap(1..4));
    Console.OUT.println(zap(new Resolve()));
  }
}
</pre>

<div class="p"><!----></div>
The basic concept of method resolution is quite straightforward: 

<ol type="1">
<li> List all the methods that could possibly be used;
<div class="p"><!----></div>
</li>

<li> Pick the most specific one;
<div class="p"><!----></div>
</li>

<li> Fail if there is not a unique most specific one.
<div class="p"><!----></div>
</li>
</ol>

In the presence of X10's highly-detailed type system, some subtleties arise. 
One point, at least, is <em>not</em> subtle. The same procedure is used, <em>
mutatis mutandis</em> for method, constructor, and operator resolution.  

<div class="p"><!----></div>
Generics introduce several subtleties, especially with the inference of
generic types. 

<div class="p"><!----></div>
For the purposes of method resolution, all that matters about a method,
constructor, or operator <b>M</b> - we use the word method" to include all
three choices for this section - is: 

<ol type="1">
<li> The method name <b>m</b>;
<div class="p"><!----></div>
</li>

<li> The generic type parameters "G<sub>1</sub>,&#8230;, G<sub>g</sub>".  If there
      are no generic type parameters, x=0.
<div class="p"><!----></div>
</li>

<li> The types "x<sub>1</sub>:T<sub>1</sub>,&#8230;, x<sub>f</sub>:T<sub>f</sub>" of the formal parameters.  If
      there are no formal parameters, f=0. In the case of an instance
      method, the receiver will be the first formal parameter.<a href="#tthFtNtAAB" name="tthFrefAAB"><sup>1</sup></a>
<div class="p"><!----></div>
</li>

<li> The constraint <b>c</b>. If no constraint is specified, <b>c</b> is
      <b>true</b>.
<div class="p"><!----></div>
</li>

<li> A <em>unique identifier</em> <b>id</b>, sufficient to tell the compiler
      which method body is intended.  A file name and position in that file
      would suffice.  The details of the identifier are not relevant.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
For the purposes of understanding method resolution, we assume that all the
actual parameters of an invocation are simply variables: <b>x1.meth(x2,x3)</b>.
This is done routinely by the compiler in any case; the code 
<b>tbl(i).meth(true, a+1)</b> would be treated roughly as 
<pre>
val x1 = tbl(i);
val x2 = true;
val x3 = a+1;
x1.meth(x2,x3);
</pre>

<div class="p"><!----></div>
All that matters about an invocation <b>I</b> is: 

<ol type="1">
<li> The method name "m&#8242;";
<div class="p"><!----></div>
</li>

<li> The generic type parameters "G&#8242;<sub>1</sub>,&#8230;, G&#8242;<sub>g</sub>".  If there
      are no generic type parameters, x=0.
<div class="p"><!----></div>
</li>

<li> The names and types "x<sub>1</sub>:T&#8242;<sub>1</sub>,&#8230;, x<sub>f</sub>:T&#8242;<sub>f</sub>" of the actual parameters.  If
      there are no actual parameters, f=0. In the case of an instance
      method, the receiver is the first actual parameter.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
The signature of the method resolution procedure is: 
<b>resolve(invo : Invocation, context: Set[Method]) : MethodID</b>.  
Given a particular invocation and the set <b>context</b> of all methods
which could be called at that point of code, method resolution either returns
the unique identifier of the method that should be called, or (conceptually)
throws an exception if the call cannot be resolved.

<div class="p"><!----></div>
The procedure for computing <b>resolve(invo, context)</b> is: 

<ol type="1">
<li> Eliminate from <b>context</b> those methods which are not <em>
      acceptable</em>; , those whose name, type parameters, formal parameters,
      and constraint do not suitably match <b>invo</b>.  In more detail:
      
<ul>
<li> The method name <b>m</b> must simply equal the invocation name "m&#8242;";
<div class="p"><!----></div>
</li>

<li> X10 infers type parameters, by an algorithm given in &#167;.
<div class="p"><!----></div>
</li>

<li> The method's type parameters are bound to the invocation's for the
            remainder of the acceptability test.
<div class="p"><!----></div>
</li>

<li> The actual parameter types must be subtypes of the formal
            parameter types:  "T&#8242;<sub>i</sub> &lt;: Ti<sub>i</sub>" for each <em>i</em>.
<div class="p"><!----></div>
</li>

<li> The formal constraint <b>c</b> must be satisfied in the invoking
            context.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>

<li> Eliminate from <b>context</b> those methods which are not <em>
      available</em>; , those which cannot be called due to visibility
      constraints, such as methods from other classes marked <b>private</b>.
      The remaining methods are both acceptable and available; they might be
      the one that is intended.
<div class="p"><!----></div>
</li>

<li> From the remaining methods, find the unique <b>ms</b> which is more specific than all the
      others, , for which <b>specific(ms,mo) = true</b> for all other
      methods <b>mo</b>
      The specificity test <b>specific</b> is given next.
      
<ul>
<li> If there is a unique such <b>ms</b>, then
            <b>resolve(invo,context)</b> returns the <b>id</b> of <b>ms</b>.
<div class="p"><!----></div>
</li>

<li> If there is not a unique such <b>ms</b>, then <b>resolve</b> reports
            an error.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
The subsidiary procedure <b>specific(m1, m2)</b> determines whether method
<b>m1</b> is equally or more specific than <b>m2</b>.  <b>specific</b> is not a
total order: is is possible for each one to be considered more specific than
the other, or either to be more specific.  <b>specific</b> is computed as: 

<ol type="1">
<li> Construct an invocation <b>invo1</b> based on <b>m1</b>: 
      
<ul>
<li> <b>invo1</b>'s method name is <b>m1</b>'s method name;
<div class="p"><!----></div>
</li>

<li> <b>invo1</b>'s generic parameters are those of <b>m1</b>- simply
            some type variables.
<div class="p"><!----></div>
</li>

<li> <b>invo1</b>'s parameters are those of <b>m1</b>.
<div class="p"><!----></div>
</li>
</ul>
<div class="p"><!----></div>
</li>

<li> If <b>m2</b> is acceptable for the invocation <b>invo1</b>,
      <b>specific(m1,m2)</b> returns true; otherwise, it returns false.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
<hr /><h3>Footnotes:</h3>

<div class="p"><!----></div>
<a name="tthFtNtAAB"></a><a href="#tthFrefAAB"><sup>1</sup></a>The
      variable names are relevant because one formal can be mentioned in a
      later type, or even a constraint: <tt>def f(a:Int, b:Point{rank==a})=...</tt>.
<br /><br />

</body>
</html>