<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>Definite Assignment</title>
</head>

<body>
 <h1><a name="tth_chAp1">
Chapter 19 </a><br />Definite Assignment</h1>
<a name="sect:DefiniteAssignment">
</a>





<div class="p"><!----></div>
X10 requires, reasonably enough, that every variable be set before it is read.
Sometimes this is easy, as when a variable is declared and assigned together: 
<pre>
  var x : Int = 0;
  assert x == 0;
</pre>
However, it is convenient to allow programs to make decisions before
initializing variables.
<pre>
def example(a:Int, b:Int) {
  val max:Int;
  // max cannot be read here.
  if (a &#62; b) max = a;
  else max = b;
  assert max &#62;= a &amp;&amp; max &#62;= b;
}
</pre>
This is particularly useful for <b>val</b> variables.  <b>var</b>s could be
initialized to a default value and then reassigned with the right value, but
<b>val</b>s must be initialized once correctly and cannot be changed. 

<div class="p"><!----></div>
However, one must be careful - and the X10 compiler enforces this care.
Without the <b>else</b> clause, the preceding code might not give <b>max</b> a
value by the <b>assert</b>.  

<div class="p"><!----></div>
This leads to the concept of <em>definite assignment</em> [].
A variable is definitely assigned at a point in code if, no matter how that
point in code is reached, the variable has been assigned to.  In X10,
variables must be definitely assigned before they can be read.

<div class="p"><!----></div>
As X10 requires that <b>val</b> variables <em>not</em> be initialized
twice,  we need the dual concept as well.  A variable is <em>definitely
unassigned</em> at a point in code if it cannot have been assigned there.  For
example, immediately after <b>val x:Int</b>, <b>x</b> is definitely unassigned.  

<div class="p"><!----></div>
At some points in code, a variable might be neither definitely assigned nor
definitely unassigned.    Such states are not always useful.  
<pre>
def example(flag : Boolean) {
  var x : Int;
  if (flag) x = 1;
  // x is neither def. assigned nor unassigned.
  x = 2; 
  // x is def. assigned.
</pre>
This shows that we cannot simply define "definitely unassigned" as "not
definitely assigned".   If <b>x</b> had been a <b>val</b> rather than a
<b>var</b>, the previous example would not be allowed.  

<div class="p"><!----></div>
Unfortunately, a completely accurate definition of "definitely assigned"
or "definitely unassigned" is undecidable - impossible for the compiler to
determine.  So, X10 takes a <em>conservative approximation</em> of these
concepts.  If X10's definition says that <b>x</b> is definitely assigned (or
definitely unassigned), then it will be assigned (or not assigned) in every
execution of the program.  

<div class="p"><!----></div>
However, there are programs which X10's algorithm says are incorrect, but
which actually would behave properly if they were executed.   In the following
example, <b>flag</b> is either <b>true</b> or <b>false</b>, and in either case
<b>x</b> will be initialized.  However, X10's analysis does not understand this
- thought it <em>would</em> understand if the example were coded with an
<b>if-else</b> rather than a pair of <b>if</b>s.  So, after the two <b>if</b>
statements, <b>x</b> is not definitely assigned, and thus the <b>assert</b>
statement, which reads it, is forbidden.  
<pre>
def example(flag:Boolean) {
  var x : Int;
  if (flag) x = 1;
  if (!flag) x = 2;
  // Not Allowed: assert x &lt; 3;
}
</pre>

<div class="p"><!----></div>
 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Technical Details of Definite Assignment</h2>

<div class="p"><!----></div>
Definite assignedness for local variables is determined by one algorithm;
definited assignedness for fields by a different one.  

<div class="p"><!----></div>
Local variables (but not fields) allow <em>asynchronous assignment</em>. A local
variable can be assigned in an <b>async</b> statement, and, when the
<b>async</b> is <b>finish</b>ed, the variable is definitely assigned.  

<pre>
val a : Int;
finish {
  async {
    a = 1;
  } 
  // a is not definitely assigned here
}
assert a==1;
</pre>

<div class="p"><!----></div>

</body>
</html>