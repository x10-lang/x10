<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
<title>Subtyping and type equivalence</title>
</head>

<body>
 <h2><a name="tth_sEc8">
8</a>&nbsp;&nbsp;Subtyping and type equivalence</h2><a name="DepType:Equivalence">
</a>



<div class="p"><!----></div>
Intuitively, type "T<sub>1</sub>" is a subtype of type "T<sub>2</sub>", 
written "T<sub>1</sub> &lt;: T<sub>2</sub>", 
if
every instance of "T<sub>1</sub>" is also an instance of "T<sub>2</sub>".  For
example, <b>Child</b> is a subtype of <b>Person</b> (assuming a suitably defined
class hierarchy): every child is a person.  Similarly, <b>Int{self != 0}</b>
is a subtype of <b>Int</b> - every non-zero integer is an integer.  

<div class="p"><!----></div>
This section formalizes the concept of subtyping. Subtyping of types depends
on a <em>type context</em>, <em>viz</em>. a set of constraints on type parameters
and variables that occur in the type.
For example: 

<div class="p"><!----></div>
<pre>
class ConsTy[T,U] {
   def upcast(t:T){T &lt;: U} :U = t;
}
</pre>

Inside <b>upcast</b>, <b>T</b> is constrained to be a subtype of <b>U</b>, and so
<b>T &lt;: U</b> is true, and <b>t</b> can be treated as a value of type <b>U</b>.  
Outside of <b>upcast</b>, there is no reason to expect any relationship between
them, and <b>T &lt;: U</b> may be false.
However, subtyping of types that have no free variables does not depend
on the context.    <b>Int{self != 0} &lt;: Int</b> is always
true.

<div class="p"><!----></div>
<em><em>Limitation</em> Subtyping of type variables does not currently work.</em>

<div class="p"><!----></div>

<ul>
<li> <b>Reflexivity:</b> Every type <b>T</b> is a subtype of itself: <b>T &lt;: T</b>.
<div class="p"><!----></div>
</li>

<li> <b>Transitivity:</b> If <b>T &lt;: U</b> and <b>U &lt;: V</b>, then <b>T &lt;: V</b>. 

<div class="p"><!----></div>

<div class="p"><!----></div>
</li>

<li> <b>Direct Subclassing:</b> 
Let <span class="overacc2">&#8594;</span>X be a (possibly empty) vector of type variables, and
<span class="overacc2">&#8594;</span>Y, <span class="overacc2">&#8594;</span>Y<sub>i</sub> be vectors of type terms over <span class="overacc2">&#8594;</span>X.
Let <span class="overacc2">&#8594;</span>T be an instantiation of <span class="overacc2">&#8594;</span>X, 
and <span class="overacc2">&#8594;</span>U, <span class="overacc2">&#8594;</span>U<sub>i</sub> the corresponding instantiation of 
<span class="overacc2">&#8594;</span>Y, <span class="overacc2">&#8594;</span>Y<sub>i</sub>.  Let <b>c</b> be a constraint, and "c&#8242;"
be the corresponding instantiation.
We elide properties, and interpret empty vectors as absence of the relevant
clauses. 
Suppose that <b>C</b> is declared by one of the
forms: 

<ol type="1">
<li> "class C[<span class="overacc2">&#8594;</span>X]{c} extends D[<span class="overacc2">&#8594;</span>Y]{d} implements I<sub>1</sub>[<span class="overacc2">&#8594;</span>Y<sub>1</sub>]{i<sub>1</sub>},...,I<sub>n</sub>[<span class="overacc2">&#8594;</span>Y<sub>n</sub>]{i<sub>n</sub>}"
<li> &#239;nterface C[<span class="overacc2">&#8594;</span>X]{c} extends I<sub>1</sub>[<span class="overacc2">&#8594;</span>Y<sub>1</sub>]{i<sub>1</sub>},...,I<sub>n</sub>[<span class="overacc2">&#8594;</span>Y<sub>n</sub>]{i<sub>n</sub>}"
<li> &#223;truct C[<span class="overacc2">&#8594;</span>X]{c} implements I<sub>1</sub>[<span class="overacc2">&#8594;</span>Y<sub>1</sub>]{i<sub>1</sub>},...,I<sub>n</sub>[<span class="overacc2">&#8594;</span>Y<sub>n</sub>]{i<sub>n</sub>}"</ol>
Then: 

<ol type="1">
<li> "C[<span class="overacc2">&#8594;</span>T] &lt;: D[<span class="overacc2">&#8594;</span>U]{d}" for a class
<div class="p"><!----></div>
</li>

<li> "C[<span class="overacc2">&#8594;</span>T] &lt;: I<sub>i</sub>[<span class="overacc2">&#8594;</span>U<sub>i</sub>]{i<sub>i</sub>}" for all cases.
<div class="p"><!----></div>
</li>

<li> "C[<span class="overacc2">&#8594;</span>T] &lt;: C[<span class="overacc2">&#8594;</span>T]{c&#8242;}" for all cases.
<div class="p"><!----></div>
</li>
</ol>
<div class="p"><!----></div>
</li>

<li>
<b>Function types:</b>
"(x<sub>1</sub>: T<sub>1</sub>, ..., x<sub>n</sub>: T<sub>n</sub>){c} =&#62; T"
is a  subtype of 
"(x&#8242;<sub>1</sub>: T&#8242;<sub>1</sub>, ..., x&#8242;<sub>n</sub>: T&#8242;<sub>n</sub>){c&#8242;} =&#62; T&#8242; "
if: 

<ol type="1">
<li> Each "T<sub>i</sub> &lt;: T&#8242;<sub>i</sub>";
<div class="p"><!----></div>
</li>

<li> <b>c</b> entails "c&#8242;";
<div class="p"><!----></div>
</li>

<li> "T&#8242; &lt;: T";
<div class="p"><!----></div>
</li>
</ol>
<div class="p"><!----></div>
</li>

<li>
<b>Constrained types:</b>
<b>T{c}</b> is a subtype of <b>T{d}</b> if <b>c</b> entails <b>d</b>.
<div class="p"><!----></div>
</li>

<li> <b>Any:</b> 
Every type <b>T</b> is a subtype of <b>x10.lang.Any</b>.
<div class="p"><!----></div>
</li>

<li> 
<b>Type Variables:</b>
Inside the scope of a constraint <b>c</b> which entails <b>A &lt;: B</b>, we have
<b>A &lt;: B</b>.  <em>e.g.</em>, <b>upcast</b> above.
<div class="p"><!----></div>
</li>

<li> 
<b>Covariant Generic Types:</b> 
If <b>C</b> is a generic type whose ith type parameter is covariant, 
and "T&#8242;<sub>i</sub> &lt;: T<sub>i</sub>"
and  "T&#8242;<sub>j</sub> == T<sub>j</sub>" for all j  &#8800; i, 
then "C[T&#8242;<sub>1</sub>, &#8230;, T&#8242;<sub>n</sub>] &lt;: C[T&#8242;<sub>1</sub>, &#8230;, T&#8242;<sub>n</sub>]".
<em>E.g.</em>, <b>class C[T1, +T2, T3]</b> with i=2, and <b>U2 &lt;: T2</b>, then
<b>C[T1,U2,T3] &lt;: C[T1,T2,T3]</b>.
<div class="p"><!----></div>
</li>

<li> 
<b>Contravariant Generic Types:</b> 
If <b>C</b> is a generic type whose ith type parameter is contravariant, 
and "T&#8242;<sub>i</sub> &lt;: T<sub>i</sub>"
and  "T&#8242;<sub>j</sub> == T<sub>j</sub>" for all j  &#8800; i, 
then "C[T&#8242;<sub>1</sub>, &#8230;, T&#8242;<sub>n</sub>] :&#62; C[T&#8242;<sub>1</sub>, &#8230;, T&#8242;<sub>n</sub>]".
<em>E.g.</em>, <b>class C[T1, -T2, T3]</b> with i=2, and &#220;2 &lt;: T2", then
<b>C[T1,U2,T3] :&#62; C[T1,T2,T3]</b>.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
Two types are <em>equivalent</em>, <b>T == U</b>, if <b>T &lt;: U</b> and <b>U &lt;: T</b>. 

<div class="p"><!----></div>

</body>
</html>