<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>User-Defined Operators</title>
</head>

<body>
 <h2><a name="tth_sEc7">
7</a>&nbsp;&nbsp;User-Defined Operators</h2>



<div class="p"><!----></div>
It is often convenient to have methods named by symbols rather than words.
For example, suppose that we wish to define a <b>Poly</b> class of
polynomials - for the sake of illustration, single-variable polynomials with
<b>Int</b> coefficients.  It would be very nice to be able to manipulate these
polynomials by the usual operations: <b>+</b> to add, <b>*</b> to multiply,
<b>-</b> to subtract, and <b>p(x)</b> to compute the value of the polynomial at
argument <b>x</b>.  We would like to write code thus: 

<div class="p"><!----></div>

<div class="p"><!----></div>
<pre>
  public static def main(Array[String](1)):void {
     val X = new Poly([0,1]);
     val t &lt;: Poly = 7 * X + 6 * X * X * X; 
     val u &lt;: Poly = 3 + 5*X - 7*X*X;
     val v &lt;: Poly = t * u - 1;
     for( [i] in -3 .. 3) {
       x10.io.Console.OUT.println(
         "" + i + "	X:" + X(i) + "	t:" + t(i) 
         + "	u:" + u(i) + "	v:" + v(i)
         );
     }
  }

<div class="p"><!----></div>
</pre>

<div class="p"><!----></div>
Writing the same code with method calls, while possible, is far less elegant: 

<div class="p"><!----></div>

<div class="p"><!----></div>
<pre>
  public static def uglymain() {
     val X = new UglyPoly([0,1]);
     val t &lt;: UglyPoly = X.mult(7).plus(X.mult(X).mult(X).mult(6));  
     val u &lt;: UglyPoly = const(3).plus(X.mult(5)).minus(X.mult(X).mult(7));
     val v &lt;: UglyPoly = t.mult(u).minus(1);
     for( [i] in -3 .. 3) {
       x10.io.Console.OUT.println(
         "" + i + "	X:" + X.apply(i) + "	t:" + t.apply(i) 
          + "	u:" + u.apply(i) + "	v:" + v.apply(i)
         );
     }
  }
</pre>

<div class="p"><!----></div>
The operator-using code can be written in X10, though a few variations are
necessary to handle such exotic cases as <b>1+X</b>.

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.1">
7.1</a>&nbsp;&nbsp;Binary Operators</h3>

<div class="p"><!----></div>
Defining the sum <b>P+Q</b> of two polynomials looks much like a method
definition.  It uses the <b>operator</b> keyword instead of <b>def</b>, and
<b>this</b> appears in the definition in the place that a <b>Poly</b> would
appear in a use of the operator.  So, 
<b>operator this + (p:Poly)</b> explains how to add <b>this</b> to a
<b>Poly</b> value.
<pre>
class Poly {
  public val coeff : Array[Int](1);
  public def this(coeff: Array[Int](1)) { this.coeff = coeff;}
  public def degree() = coeff.size()-1;
  public def  a(i:Int) = (i&lt;0 </td><td width="150">
&#124;</td><td width="150">
&#124; i&#62;this.degree()) ? 0 : coeff(i);

<div class="p"><!----></div>
  public operator this + (p:Poly) =  new Poly(
     new Array[Int](
        Math.max(this.coeff.size(), p.coeff.size()),
        (i:Int) =&#62; this.a(i) + p.a(i)
     )); 
  // ... 
</pre>

<div class="p"><!----></div>
The sum of a polynomial and an integer, <b>P+3</b>, looks like
an overloaded method definition.  
<pre>
   public operator this + (n : Int) = new Poly([n]) + this;
</pre>

<div class="p"><!----></div>
However, we want to allow the sum of an integer and a polynomial as well:
<b>3+P</b>.  It would be quite inconvenient to have to define this as a method
on <b>Int</b>; changing <b>Int</b> is far outside of normal coding.  So, we
allow it as a method on <b>Poly</b> as well.

<div class="p"><!----></div>
<pre>
   public operator (n : Int) + this = new Poly([n]) + this;
</pre>

<div class="p"><!----></div>
Furthermore, it is sometimes convenient to express a binary operation as a
static method on a class. 
The definition for the sum of two
<b>Poly</b>s could have been written:
<pre>
  public static operator (p:Poly) + (q:Poly) =  new Poly(
     new Array[Int](
        Math.max(q.coeff.size(), p.coeff.size()),
        (i:Int) =&#62; q.a(i) + p.a(i)
     ));
</pre>

<div class="p"><!----></div>
This requires the following grammar: <br />
<em>  
<table>

<tr><td align="right">MethodDecl ::= MethMods <b>def</b> Id TypeParams<sup>?</sup>&nbsp;FormalParams WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>(</b> FormalParam  <b>)</b> BinOp <b>(</b> FormalParam  <b>)</b> WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;PrefixOp <b>(</b> FormalParam  <b>)</b> WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>this</b> BinOp <b>(</b> FormalParam  <b>)</b> WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>(</b> FormalParam  <b>)</b> BinOp <b>this</b> WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;PrefixOp <b>this</b> WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> <b>this</b> TypeParams<sup>?</sup>&nbsp;FormalParams WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> <b>this</b> TypeParams<sup>?</sup>&nbsp;FormalParams <b>=</b> <b>(</b> FormalParam  <b>)</b> WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>(</b> FormalParam  <b>)</b> <b>as</b> Type WhereClause<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>(</b> FormalParam  <b>)</b> <b>as</b> <b>?</b> WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right">&#124; MethMods <b>operator</b> TypeParams<sup>?</sup>&nbsp;<b>(</b> FormalParam  <b>)</b> WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;MethodBody </td></tr>
<tr><td align="right"></td></tr></table>
</em>
When X10 attempts to typecheck a binary operator expression like <b>P+Q</b>, it
first typechecks <b>P</b> and <b>Q</b>. Then, it looks for operator declarations
for <b>+</b> in the types of <b>P</b> and <b>Q</b>. If there are none, it is a
static error. If there is precisely one, that one will be used. If there are
several, X10 looks for a <em>best-matching</em> operation, <em>viz</em> one which does
not require the operands to be converted to another type. For example,
<b>operator this + (n:Long)</b> and <b>operator this + (n:Int)</b> both apply to
<b>p+1</b>, because <b>1</b> can be converted from an <b>Int</b> to a <b>Long</b>.
However, the <b>Int</b> version will be chosen because it does not require a
conversion. If even the best-matching operation is not uniquely determined,
the compiler will report a static error.

<div class="p"><!----></div>
The main difference between expressing a binary operation as an instance
method (with a <b>this</b> in the definition) and a static one (no <b>this</b>)
is that instance methods don't apply any conversions, while static methods
attempt to convert both arguments. 


<div class="p"><!----></div>
     <h3><a name="tth_sEc7.2">
7.2</a>&nbsp;&nbsp;Unary Operators</h3>

<div class="p"><!----></div>
Unary operators are defined in a similar way, with <b>this</b> appearing in the
<b>operator</b> definition where an actual value would occur in a unary
expression.  The operator to negate a polynomial is: 

<div class="p"><!----></div>
<pre>
  public operator - this = new Poly(
    new Array[Int](coeff.size(), (i:Int) =&#62; -coeff(i))
    );
</pre>

<div class="p"><!----></div>
The rules for typechecking a unary operation are the same as for methods; the
complexities of binary operations are not needed.

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.3">
7.3</a>&nbsp;&nbsp;Type Conversions</h3>


<div class="p"><!----></div>
Explicit type conversions, <b>e as T{c}</b>, can be defined as operators on
class <b>T</b>.

<div class="p"><!----></div>
<pre>
class Poly {
  public val coeff : Array[Int](1);
  public def this(coeff: Array[Int](1)) { this.coeff = coeff;}
  public static operator (a:Int) as Poly = new Poly([a]);
  public static def main(Array[String](1)):void {
     val three : Poly = 3 as Poly;
  }
}
</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
<pre>
</pre>


<div class="p"><!----></div>
     <h3><a name="tth_sEc7.4">
7.4</a>&nbsp;&nbsp;Implicit Type Coercions</h3>


<div class="p"><!----></div>
You may also define <em>implicit</em> type coercions to <b>T{c}</b> as static
operators in class <b>T</b>.  The syntax for this is
<b>static operator (x:U) : T{c} = e</b>.
Implicit coercions are used automatically by the compiler.  


<div class="p"><!----></div>
For example, we can define an implicit coercion from <b>Int</b> to <b>Poly</b>,
and avoid having to define the sum of an integer and a polynomial
as many special cases.  In the following example, we only define <b>+</b> on
two polynomials (using a <b>static</b> operator, so that implicit coercions
will be used - they would not be for an instance method operator).  The
calculation <b>1+x</b> coerces <b>1</b> to a polynomial and uses polynomial
addition to add it to <b>x</b>.

<div class="p"><!----></div>

<div class="p"><!----></div>
<pre>
  public static operator (c : Int) : Poly = new Poly([c]);

<div class="p"><!----></div>
  public static operator (p:Poly) + (q:Poly) = new Poly(
      new Array[Int](
        Math.max(p.coeff.size(), q.coeff.size()),
        (i:Int) =&#62; p.a(i) + q.a(i)
     ));

<div class="p"><!----></div>
  public static def main(Array[String](1)):void {
     val x = new Poly([0,1]);
     x10.io.Console.OUT.println("1+x=" + (1+x));
  }
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.5">
7.5</a>&nbsp;&nbsp;<b>set</b> and <b>apply</b></h3>




<a name="set-and-apply">
</a>
X10 allows types to implement the subscripting / function application
operator, and indexed assignment.  The <b>Array</b>-like classes take advantage
of both of these in <b>a(i) = a(i) + 1</b>.  Unlike unary and binary operators,
subscripting and indexed assignment are done by methods, <b>apply</b> and
<b>set</b> respectively.

<div class="p"><!----></div>
<b>a(b,c,d)</b> is short for the method call <b>a.apply(b,c,d)</b>.  Since it is
possible to overload methods, the application syntax can be overloaded.  For
example, an ordered dictionary structure could allow subscripting by numbers
with <b>def apply(i:Int)</b>, and by string-valued keys with 
<b>def apply(s:String)</b>.  

<div class="p"><!----></div>
<b>a(i)=b</b> is short for the method call <b>a.set(b,i)</b>, with one or more
indices <b>i</b>. (This has a
possibly surprising consequence for the order of evaluation: in <b>a(i)=b</b>,
as in <b>a.set(b,i)</b>, <b>a</b> is evaluated first, then <b>b</b>, and finally
<b>i</b>.)  Again, it is possible to overload <b>set</b> to provide a variety of
subscripting operations.  Each <b>set</b> method must have a corresponding
<b>apply</b> method; that is, <b>a(i,j)=b</b> is only defined when <b>a(i,j)</b>
is defined, despite the fact that <b>a(i,j)=b</b> does not evaluate <b>a(i,j)</b>.

<div class="p"><!----></div>
The <b>Oddvec</b> class of somewhat peculiar vectors illustrates this.
<b>a()</b> returns a string representation of the oddvec, which probably should
be done by <b>toString()</b> instead.  <b>a(i)</b> picks out one of the three
coordinates of <b>a</b>, which is sensible.  <b>a(i)=b</b> assigns to one of the
coordinates.  <b>a(i,j)=b</b> assigns different values to <b>a(i)</b> and
<b>a(j)</b>, purely for the sake of the example.

<div class="p"><!----></div>
<pre>
class Oddvec {
  var v : Array[Int](1) = new Array[Int](3, (Int)=&#62;0);
  public def apply() = "(" + v(0) + "," + v(1) + "," + v(2) + ")";
  public def apply(i:Int) = v(i);
  public def apply(i:Int, j:Int) = [v(i),v(j)];
  public def set(newval:Int, i:Int) = {v(i) = newval;}
  public def set(newval:Int, i:Int, j:Int) = {
       v(i) = newval; v(j) = newval+1;} 
  // ... 
</pre>

<div class="p"><!----></div>

</body>
</html>