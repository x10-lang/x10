<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>Class Guards and Invariants</title>
</head>

<body>
 <h2><a name="tth_sEc8">
8</a>&nbsp;&nbsp;Class Guards and Invariants</h2><a name="DepType:ClassGuard">
</a>






<div class="p"><!----></div>
Classes (and structs and interfaces) may specify a <em>class guard</em>, a
constraint which must hold on all values of the class.    In the following
example, a <b>Line</b> is defined by two distinct <b>Pt</b>s<a href="#tthFtNtAAC" name="tthFrefAAC"><sup>2</sup></a>
<pre>
class Pt(x:Int, y:Int){}
class Line(a:Pt, b:Pt){a != b} {}
</pre>

<div class="p"><!----></div>
In most cases the class guard could be phrased as a type constraint on a property of
the class instead, if preferred.  Arguably, a symmetric constraint like two
points being different is better expressed as a class guard, rather than
asymmetrically as a constraint on one type: 
<pre>
class Line(a:Pt, b:Pt{a != b}) {}
</pre>

<div class="p"><!----></div>
<a name="DepType:TypeInvariant">
</a><a name="DepType:ClassGuardDef">
</a>With every defined class, struct,  or interface <b>T</b> we associate a <em>type
invariant</em> <i>inv</i>(<b>T</b>), which describes the guarantees on the
properties of values of type <b>T</b>.  

<div class="p"><!----></div>
Every value of <b>T</b> satisfies <i>inv</i>(<b>T</b>) at all times.  This
is somewhat stronger than the concept of type invariant in most languages
(which only requires that the invariant holds when no method calls are
active).  X10 invariants only concern properties, which are immutable; thus,
once established, they cannot be falsified.

<div class="p"><!----></div>
The type
invariant associated with <b>x10.lang.Any</b>
is 
<b>true</b>.

<div class="p"><!----></div>
The type invariant associated with any interface or struct <b>I</b> that extends
interfaces &#207;<sub>1</sub>, ..., I<sub>k</sub>" and defines properties
"x<sub>1</sub>: P<sub>1</sub>, ..., x<sub>n</sub>: P<sub>n</sub>" and
specifies a guard <b>c</b> is given by:

<div class="p"><!----></div>
<pre>
{inv}(I<sub>1</sub>) &amp;&amp; ... &amp;&amp; {inv}(I<sub>k</sub>) 
    &amp;&amp; self.x<sub>1</sub> instanceof P<sub>1</sub> &amp;&amp;  ... &amp;&amp;  self.x<sub>n</sub> instanceof P<sub>n</sub> 
    &amp;&amp; c  
</pre>

<div class="p"><!----></div>
Similarly the type invariant associated with any class <b>C</b> that
implements interfaces &#207;<sub>1</sub>, ..., I<sub>k</sub>",
extends class <b>D</b> and defines properties
"x<sub>1</sub>: P<sub>1</sub>, ..., x<sub>n</sub>: P<sub>n</sub>" and
specifies a guard <b>c</b> is
given by the same thing with the invariant of the superclass <b>D</b> conjoined:
<pre>
{inv}(I<sub>1</sub>) &amp;&amp; ... &amp;&amp; {inv}(I<sub>k</sub>) 
    &amp;&amp; self.x<sub>1</sub> instanceof P<sub>1</sub> &amp;&amp;  ... &amp;&amp;  self.x<sub>n</sub> instanceof P<sub>n</sub> 
    &amp;&amp; c  
    &amp;&amp; {inv}(D)
</pre>

<div class="p"><!----></div>
Note that the type invariant associated with a class entails the type
invariants of each interface that it implements (directly or indirectly), and
the type invariant of each ancestor class.
It is guaranteed that for any variable <b>v</b> of
type <b>T{c}</b> (where <b>T</b> is an interface name or a class name) the only
objects <b>o</b> that may be stored in <b>v</b> are such that <b>o</b> satisfies
<i>inv</i>(T[o/this])&#8743;c[o/self].

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.1">
8.1</a>&nbsp;&nbsp;Invariants for <b>implements</b> and <b>extends</b> clauses</h3><a name="DepType:Implements">
</a>
<a name="DepType:Extends">
</a>




Consider a class definition
<pre>
ClassModifiers<sup>?</sup>
class C(x<sub>1</sub>: P<sub>1</sub>, ..., x<sub>n</sub>: P<sub>n</sub>) extends D{d}
   implements I<sub>1</sub>{c<sub>1</sub>}, ..., I<sub>k</sub>{c<sub>k</sub>}
ClassBody
</pre>

<div class="p"><!----></div>
Each of the following static semantics rules must be satisfied:

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font> (Int-implements):
The type invariant  of <b>C</b> must entail
"c<sub>i</sub>[this/self]" for each i in {{1, ..., k}}


<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font> (Super-extends):
The return type <b>c</b> of each constructor in a class <b>C</b>
must entail the invariant "<i>inv</i>(C)".


<div class="p"><!----></div>
     <h3><a name="tth_sEc8.2">
8.2</a>&nbsp;&nbsp;Invariants and constructor definitions</h3>



<div class="p"><!----></div>
A constructor for a class <b>C</b> is guaranteed to return an object of the
class on successful termination. This object must satisfy  "<i>inv</i>(C)", the
class invariant associated with <b>C</b> (&#167;<a href="#DepType:TypeInvariant">7</a>).
However,
often the objects returned by a constructor may satisfy <em>stronger</em>
properties than the class invariant. X10's dependent type system
permits these extra properties to be asserted with the constructor in
the form of a constrained type (the "return type" of the constructor):

<div class="p"><!----></div>
<em>  
<table>

<tr><td align="right">CtorDecl ::= Mods<sup>?</sup>&nbsp;<b>def</b> <b>this</b> TypeParams<sup>?</sup>&nbsp;FormalParams WhereClause<sup>?</sup>&nbsp;HasResultType<sup>?</sup>&nbsp;Offers<sup>?</sup>&nbsp;CtorBody </td></tr>
<tr><td align="right"></td></tr></table>
</em>

<div class="p"><!----></div>
<a name="ConstructorGuard">
</a>The parameter list for the constructor
may specify a <em>guard</em> that is to be satisfied by the parameters
to the list.

<div class="p"><!----></div>
Here is another example, constructed as a simplified 
version of <b>x10.array.Region</b>.  The <b>mockUnion</b> method 
has the type that a true <b>union</b> method would have.

<div class="p"><!----></div>
<pre>
class MyRegion(rank:Int) {
  static type MyRegion(n:Int)=MyRegion{rank==n};
  def this(r:Int):MyRegion(r) {
    property(r);
  }
  def this(diag:Array[Int](1)):MyRegion(diag.size){ 
    property(diag.size);
  }
  def mockUnion(r:MyRegion(rank)):MyRegion(rank) = this;
  def example() {
    val R1 : MyRegion(3) = new MyRegion([4,4,4]); 
    val R2 : MyRegion(3) = new MyRegion([5,4,1]); 
    val R3 = R1.mockUnion(R2); // inferred type MyRegion(3)
  }
}
</pre>
The first constructor returns the empty region of rank <b>r</b>.  The
second constructor takes a <b>Array[Int](1)</b> of arbitrary length
<b>n</b> and returns a <b>MyRegion(n)</b> (intended to represent the set
of points in the rectangular parallelopiped between the origin and the
<b>diag</b>.)

<div class="p"><!----></div>
The code in <b>example</b> typechecks, and <b>R3</b>'s type is inferred as
<b>MyRegion(3)</b>.  

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font> (Super-invoke):
   Let <b>C</b> be a class with properties
   , invariant <b>c</b>
   extending the constrained type <b>D{d}</b> (where <b>D</b> is the name of a class).

<div class="p"><!----></div>
   For every constructor in <b>C</b> the compiler checks that the call to
   super invokes a constructor for <b>D</b> whose return type is strong enough
   to entail <b>d</b>. Specifically, if the call to super is of the form 
     &#223;uper(e<sub>1</sub>, ..., e<sub>k</sub>)"
   and the static type of each expression &#235;<sub>i</sub>" is
   "S<sub>i</sub>", and the invocation
   is statically resolved to a constructor
"def this(x<sub>1</sub>: T<sub>1</sub>, ..., x<sub>k</sub>: T<sub>k</sub>){c}: D{d<sub>1</sub>}"
   then it must be the case that 
<pre>
x<sub>1</sub>: S<sub>1</sub>, ..., x<sub>i</sub>: S<sub>i</sub> &#124;&mdash; x<sub>i</sub>: T<sub>i</sub>  (for i  &#8712; {1, ..., k})
x<sub>1</sub>: S<sub>1</sub>, ..., x<sub>k</sub>: S<sub>k</sub> &#124;&mdash; c  
d<sub>1</sub>[a/self], x<sub>1</sub>: S<sub>1</sub>, ..., x<sub>k</sub>: S<sub>k</sub> &#124;&mdash; d[a/self]      
</pre>
 where <b>a</b> is a constant that does not appear in 
"x<sub>1</sub>: S<sub>1</sub> &#8743; ... &#8743; x<sub>k</sub>: S<sub>k</sub>".


<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font> (Constructor return):
   The compiler checks that every constructor for <b>C</b> ensures that
   the properties "p<sub>1</sub>,..., p<sub>n</sub>" are initialized with values which satisfy
   , and its own return type <b>c'</b> as follows.  In each constructor, the
   compiler checks that the static types "T<sub>i</sub>" of the expressions &#235;<sub>i</sub>"
   assigned to "p<sub>i</sub>" are such that the following is
   true:
<pre>
p<sub>1</sub>: T<sub>1</sub>, ..., p<sub>n</sub>: T<sub>n</sub> &#124;&mdash; t(C) &#8743; c'     
</pre>

(Note that for the assignment of &#235;<sub>i</sub>" to "p<sub>i</sub>"
to be type-correct it must be the
    case that "p<sub>i</sub>: T<sub>i</sub> &#8743; p<sub>i</sub>: P<sub>i</sub>".) 

<div class="p"><!----></div>
 S<font size="-2">TATIC</font> S<font size="-2">EMANTICS</font> R<font size="-2">ULE</font> (Constructor invocation):
The compiler must check that every invocation "C(e<sub>1</sub>, ..., e<sub>n</sub>)" to a
constructor is type correct: each argument &#235;<sub>i</sub>" must have a static type
that is a subtype of the declared type "T<sub>i</sub>" for the ith
argument of the
constructor, and the conjunction of static types of the argument must
entail the constraint in the parameter list of the constructor.

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.3">
8.3</a>&nbsp;&nbsp;Object Initialization</h3>





<div class="p"><!----></div>
X10 does object initialization safely.  It avoids a few classes of bad things: 

<ol type="1">
<li> Use of a field before the field has been initialized.
<div class="p"><!----></div>
</li>

<li> <b>this</b> escaping from a constructor;
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
It should be unsurprising that fields must not be used before they are
initialized. At best, it is uncertain what value will be in them, as in
<b>x</b> below. Worse, the value might not even be an allowable value; <b>y</b>,
declared to be nonzero in the following example, might be zero before it is
initialized. 
<pre>
// Not correct X10
class ThisIsWrong {
  val x : Int;
  val y : Int{y != 0};
  def this() {
    x10.io.Console.OUT.println("x=" + x + "; y=" + y);
    x = 1; y = 2;
  }
}
</pre>

<div class="p"><!----></div>
One particularly insidious way to read uninitialized fields is to allow
<b>this</b> to escape from a constructor. For example, the constructor could
put <b>this</b> into a data structure before initializing it, and another
activity could read it from the data structure and look at its fields: 
<pre>
class Wrong {
  val shouldBe8 : Int;
  static Cell[Wrong] wrongCell = new Cell[Wrong]();
  static def doItWrong() {
     finish { 
       async { new Wrong(); } // (A)
       assert( wrongCell().shouldBe8 == 8); // (B)
     }
  }
  def this() {
     wrongCell.set(this); // (C) - ILLEGAL 
     this.shouldBe8 = 8; // (D)
  }
}
</pre>

In this example, the underconstructed <b>Wrong</b> object is leaked into a
storage cell at line <b>(C)</b>, and then initialized.  The <b>doItWrong</b>
method constructs a new <b>Wrong</b> object, and looks at the <b>Wrong</b>
object in the storage cell to check on its <b>shouldBe8</b> field.  One
possible order of events is the following: 

<ol type="1">
<li> <b>doItWrong()</b> is called.
<div class="p"><!----></div>
</li>

<li> <b>(A)</b> is started.  Space for a new <b>Wrong</b> object is allocated.
      Its <b>shouldBe8</b> field, not yet initialized, contains some garbage
      value.
<div class="p"><!----></div>
</li>

<li> <b>(C)</b> is executed, as part of the process of constructing a new
      <b>Wrong</b> object.  The new, uninitialized object is stored in
      <b>wrongCell</b>.
<div class="p"><!----></div>
</li>

<li> Now, the initialization activity is paused, and execution of the main activity 
      proceeds from <b>(B)</b>.
<div class="p"><!----></div>
</li>

<li> The value in <b>wrongCell</b> is retrieved, and is <b>shouldBe8</b> field
      is read.  This field contains garbage, and the assertion fails.
<div class="p"><!----></div>
</li>

<li> Now let the initialization activity proceed with <b>(D)</b>,
      initializing <b>shouldBe8</b> - too late.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
The <b>at</b> statement (&#167;) introduces the potential for
escape as well. The following class prints an uninitialized value: 
<pre>
class Example {
  val a: Int;
  def this() { 
    at(here.next()) {
      // Recall that 'this' is a copy of 'this' outside 'at'.
      Console.OUT.println("this.a = " + this.a);
    }
    this.a = 1;
  }
}
</pre>

<div class="p"><!----></div>
X10 must protect against such possibilities.  The rules explaining how
constructors can be written are somewhat intricate; they are designed to allow
as much programming as possible without leading to potential problems.
Ultimately, they simply are elaborations of the fundamental principles that
uninitialized fields must never be read, and <b>this</b> must never be leaked.  

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.4">
8.4</a>&nbsp;&nbsp;Constructors and NonEscaping Methods</h3>

<div class="p"><!----></div>
In general, constructors must not be allowed to call methods with<b>this</b> as
an argument or receiver. Such calls could leak references to <b>this</b>,
either directly from a call to <b>cell.set(this)</b>, or indirectly because
<b>toString</b> leaks <b>this</b>, and the concatenation 
`&#203;scaper = "+this` calls <b>toString</b>.<a href="#tthFtNtAAD" name="tthFrefAAD"><sup>3</sup></a>
<pre>
class Escaper {
  static val Cell[Escaper] cell = new Cell[Escaper]();
  def toString() {
    cell.set(this);
    return &#203;vil!";
  }
  def this() {
    cell.set(this);
    x10.io.Console.OUT.println(&#203;scaper = " + this);
  }
}
</pre>

<div class="p"><!----></div>
However, it is convenient to be able to call methods from constructors; <em>
e.g.</em>, a class might have eleven constructors whose common behavior is best
described by three methods.  
Under certain stringent conditions, it <em>is</em>
safe to call a method: the method called must not leak references to
<b>this</b>, and must not read <b>val</b>s or <b>var</b>s which might not have
been assigned.   

<div class="p"><!----></div>
So, X10 performs a static dataflow analysis, sufficient to guarantee that
method calls in constructors are safe.  This analysis requires having access
to or guarantees about all the code that could possibly be called.  This can
be accomplished in two ways: 

<ol type="1">
<li> Ensuring that only code from the class itself can be called, by 
      forbidding overriding of
      methods called from the constructor: they can be marked <b>final</b> or
      <b>private</b>, or the whole class can be <b>final</b>.
<div class="p"><!----></div>
</li>

<li> Marking the methods called from the constructor by
      <b>@NonEscaping</b>.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
      <h4><a name="tth_sEc8.4.1">
8.4.1</a>&nbsp;&nbsp;Non-Escaping Methods</h4>








<div class="p"><!----></div>
A method may be annotated with <b>@NonEscaping</b>.  This
imposes several restrictions on the method body, and on all methods overriding
it.  However, it is the only way that a method can be called from
constructors.  The
<b>@NonEscaping</b> annotation makes explicit all the X10 compiler's needs for
constructor-safety.  

<div class="p"><!----></div>
A method can, however, be safe to call from constructors without being marked
<b>@NonEscaping</b>. We call such methods <em>implicitly non-escaping</em>.
Implicitly non-escaping methods need to obey the same constraints on
<b>this</b>, <b>super</b>, and variable usage as <b>@NonEscaping</b> methods. An
implicitly non-escaping method <em>could</em> be marked as
<b>@NonEscaping</b> for some list of variables; the compiler, in
effect, infers the annotation. In addition, implicitly non-escaping methods
must be <b>private</b> or <b>final</b> or members of a <b>final</b> class; this
corresponds to the hereditary nature of <b>@NonEscaping</b> (by forbidding
inheritance of implicitly non-escaping methods).

<div class="p"><!----></div>
We say that a method is <em>non-escaping</em> if it is either implicitly
non-escaping, or annotated <b>@NonEscaping</b>.

<div class="p"><!----></div>
The first requirement on non-escaping methods is that they do not allow
<b>this</b> to escape. Inside of their bodies, <b>this</b> and <b>super</b> may
only be used for field access and assignment, and as the receiver of
non-escaping methods.

<div class="p"><!----></div>
Finally, if a method <b>m</b> in class <b>C</b> is marked
<b>@NonEscaping</b>, then every method which overrides <b>m</b> in any
subclass of <b>C</b> must be annotated with precisely the same annotation,
<b>@NonEscaping</b>, as well.  

<div class="p"><!----></div>
The following example uses most of the possible variations (leaving out
<b>final</b> class).  <b>aplomb()</b> explicitly forbids reading any field but
<b>a</b>. <b>boric()</b> is called after <b>a</b> and <b>b</b> are set, but
{c} is not. 
The <b>@NonEscaping</b> annotation on <b>boric()</b> is optional, but the
compiler will print a warning if it is left out.
<b>cajoled()</b> is only called after all fields are set, so it
can read anything; its annotation, too, is not required.   <b>SeeAlso</b> is able to override <b>aplomb()</b>, because
<b>aplomb()</b> is <b>@NonEscaping(&#228;")</b>; it cannot override the final method
<b>boric()</b> or the private one <b>cajoled()</b>.  Even for overriding
<b>aplomb()</b>, it is crucial that <b>SeeAlso.aplomb()</b> be 
declared <b>@NonEscaping(&#228;")</b>, just like <b>C2.aplomb()</b>.
<pre>
import x10.compiler.*;

<div class="p"><!----></div>
final class C2 {
  protected val a:Int, b:Int, c:Int;
  protected var x:Int, y:Int, z:Int;
  def this() {
    a = 1;
    this.aplomb();
    b = 2;
    this.boric();
    c = 3;
    this.cajoled();
  }
  @NonEscaping def aplomb() {
    x = a;
    // this.boric(); // not allowed; boric reads b.
    // z = b; // not allowed - only 'a' can be read here
  }
  @NonEscaping final def boric() {
    y = b;
    this.aplomb(); // allowed; a is definitely set before boric is called
    // z = c; // not allowed; c is not definitely written 
  }
  @NonEscaping private def cajoled() {
    z = c;
  }  
}

<div class="p"><!----></div>
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.5">
8.5</a>&nbsp;&nbsp;Fine Structure of Constructors</h3>
<a name="SFineStructCtors">
</a>

<div class="p"><!----></div>
The code of a constructor consists of four segments, three of them optional
and one of them implicit.

<ol type="1">
<li> The first segment is an optional call to <b>this(...)</b> or
      <b>super(...)</b>.  If this is supplied, it must be the first statement
      of the constructor.  If it is not supplied, the compiler treats it as a
      nullary super-call <b>super()</b>;
<div class="p"><!----></div>
</li>

<li> If the class or struct has properties, there must be a single
      <b>property(...)</b> command in the constructor.  Every execution path
      through the constructor must go through this <b>property(...)</b> command
      precisely once.   The second segment of the constructor is the code
      following the first segment, up to and including the <b>property()</b>
      statement.  

<div class="p"><!----></div>
      If the class or struct has no properties, the <b>property()</b> call must
      be omitted. If it is present, the second segment is defined as before.  If
      it is absent, the second segment is empty.
<div class="p"><!----></div>
</li>

<li> The third segment is automatically generated.  Fields with initializers
      are initialized immediately after the <b>property</b> statement.  
      In the following example, <b>b</b> is initialized to <b>y*9000</b> in
      segment three.  The initialization makes sense and does the right
      thing; <b>b</b> will be <b>y*9000</b> for every <b>Overdone</b> object. 
      (This would not be possible if field initializers were processed
      earlier, before properties were set.)
<div class="p"><!----></div>
</li>

<li> The fourth segment is the remainder of the constructor body.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
The segments in the following code are shown in the comments.
<pre>
class Overlord(x:Int) {
  def this(x:Int) { property(x); }
}//Overlord
class Overdone(y:Int) extends Overlord  {
  val a : Int;
  val b =  y * 9000;
  def this(r:Int) {
    super(r);                      // (1)
    x10.io.Console.OUT.println(r); // (2)
    property(r+1);                 // (2)
    // field initializations here  // (3)
    a = r + 2;                     // (4)
  }
}//Overdone
</pre>

<div class="p"><!----></div>
The rules of what is allowed in the three segments are different, though
unsurprising.  For example, properties of the current class can only be read
in segment 3 or 4-naturally, because they are set at the end of segment 2.  

<div class="p"><!----></div>
      <h4><a name="tth_sEc8.5.1">
8.5.1</a>&nbsp;&nbsp;Initialization and Inner Classses</h4>


<div class="p"><!----></div>
Constructors of inner classes are tantamount to method calls on <b>this</b>.  
For example, the constructor for Inner <b>is</b> acceptable.  It does not leak
<b>this</b>.  It leaks <b>Outer.this</b>, which is an utterly different object.  
So, the call to <b>this.new Inner()</b> in the <b>Outer</b> constructor <em>
is</em> illegal.  It would leak <b>this</b>.  There is no special rule in effect
preventing this; a constructor call of an inner class is no 
different from a method as far as leaking is concerned.
<pre>
class Outer {
  static val leak : Cell[Outer] = new Cell[Outer](null);
  class Inner {
     def this() {Outer.leak.set(Outer.this);}
  }
  def /*Outer*/this() {
     //ILLEGAL: val inner = this.new Inner(); 
  }
}
</pre>

<div class="p"><!----></div>
      <h4><a name="tth_sEc8.5.2">
8.5.2</a>&nbsp;&nbsp;Initialization and Closures</h4>


<div class="p"><!----></div>
Closures in constructors may not refer to <b>this</b>.  They may not even refer
to fields of <b>this</b> that have been initialized.   For example, the
closure <b>bad1</b> is not allowed because it refers to <b>this</b>; <b>bad2</b>
is not allowed because it mentions <b>a</b> - which is, of course, identical
to <b>this.a</b>. 

<div class="p"><!----></div>
<pre>
class C {
  val a:Int;
  def this() {
    this.a = 1;
    // val bad1 = () =&#62; this; 
    // val bad2 = () =&#62; a*10;
  }
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.6">
8.6</a>&nbsp;&nbsp;Definite Initialization in Constructors</h3>

<div class="p"><!----></div>
An instance field <b>var x:T</b>, when <b>T</b> has a default value, need not be
explicitly initialized.  In this case, <b>x</b> will be initialized to the
default value of type <b>T</b>.  For example, a <b>Score</b> object will have
its <b>currently</b> field initialized to zero, below:
<pre>
class Score {
  public var currently : Int;
}
</pre>

<div class="p"><!----></div>
All other sorts of instance fields do need to be initialized before they can
be used.  <b>val</b> fields must be initialized, even if their type has a
default value.  It would be silly to have a field <b>val z : Int</b> that was
always given default value of <b>0</b> and, since it is <b>val</b>, can never be
changed.  <b>var</b> fields whose type has no default value must be initialized
as well, such as <b>var y : Int{y != 0}</b>, since it cannot be assigned a
sensible initial value. 

<div class="p"><!----></div>
The fundamental principles are: 

<ol type="1">
<li> <b>val</b> fields must be assigned precisely once in each constructor on every
possible execution path.
<div class="p"><!----></div>
</li>

<li> <b>var</b> fields of defaultless type must be
assigned at least once on every possible execution path, but may be assigned
more than once.
<div class="p"><!----></div>
</li>

<li> No variable may be read before it is guaranteed to have been
assigned.
<div class="p"><!----></div>
</li>

<li> Initialization may be by field initialization expressions (<b>val x :
      Int = y+z</b>), or by uninitialized fields <b>val x : Int;</b> plus
an initializing assignment <b>x = y+z</b>.  Recall that field initialization
expressions are performed after the <b>property</b> statement, in segment 3 in
the terminology of &#167;<a href="#SFineStructCtors">7.5</a>.
<div class="p"><!----></div>
</li>
</ol>

<div class="p"><!----></div>
     <h3><a name="tth_sEc8.7">
8.7</a>&nbsp;&nbsp;Summary of Restrictions on Classes and Constructors</h3>

<div class="p"><!----></div>
The following table tells whether a given feature is (yes), is not (no) or is
with some conditions (note) allowed in a given context.   For example, a
property method is allowed with the type of another property, as long as it
only mentions the preceding properties. The first column of the table gives
examples, by line of the following code body.

<div class="p"><!----></div>

<table border=1>
<tr><td align="left">&nbsp;</td>
  <td><b>Example</b></td>
  <td><b>Prop.</b></td>
  <td><b><tt><font size="-1">self==this</font></tt>(1)</b></td>
  <td><b>Prop.Meth.</b></td>
  <td><b><tt>this</tt></b></td>
  <td><b>fields</b></td>
</td></tr>
<tr><td align="left">Type of property</td> 
  <td>(A)</td> 
  
  <td>yes (2)</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Class Invariant</td>
  <td>(B)</td> 
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Supertype (3)</td>
  <td>(C), (D)</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Property Method Body</td>
  <td>(E)</td> 
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Static field (4)</td>
  <td>(F) (G)</td> 
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Instance field (5)</td>
  <td>(H), (I)</td> 
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
</td></tr>
<tr><td align="left">Constructor arg. type</td>
  <td>(J)</td> 
  <td>no</td>
  <td>yes</td>
  <td>no</td>
  <td>yes</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Constructor guard</td>
  <td>(K)</td> 
  <td>no</td>
  <td>yes</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Constructor ret. type</td>
  <td>(L)</td> 
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Constructor segment 1</td> 
  <td>(M)</td> 
  <td>no</td>
  <td>yes</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Constructor segment 2</td>
  <td>(N)</td> 
  <td>no</td>
  <td>yes</td>
  <td>no</td>
  <td>no</td>
  <td>no</td>
</td></tr>
<tr><td align="left">Constructor segment 4</td>
  <td>(O)</td> 
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
</td></tr>
<tr><td align="left">Methods</td>
  <td>(P)</td> 
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
  <td>yes</td>
</td></tr>
<!--
<tr><td align="left">place</td>
  <td>(pos)</td> 
  
  <td>&nbsp;</td>
  <td>&nbsp;</td>
  <td>&nbsp;</td>
  <td>&nbsp;</td>
</td></tr>
-->
</table>


<div class="p"><!----></div>
Details:

<div class="p"><!----></div>

<ul>
<li> (1) Top-level <tt>self</tt> only.
<div class="p"><!----></div>
</li>

<li> (2) The type of the i<sup>th</sup> property may only mention
                 properties 1 through i.
<div class="p"><!----></div>
</li>

<li> (3) Super-interfaces follow the same rules as supertypes.
<div class="p"><!----></div>
</li>

<li> (4) The same rules apply to types and initializers.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
The example indices refer to the following code: 
<pre>
class Example (
   prop : Int,
   proq : Int{prop != proq},                    // (A)
   pror : Int
   )
   {prop != 0}                                  // (B)
   extends Supertype[Int{self != prop}]         // (C)
   implements SuperInterface[Int{self != prop}] // (D)
{
   property def propmeth() = (prop == pror);    // (E)
   static staticField 
      : Cell[Int{self != 0}]                    // (F)
      = new Cell[Int{self != 0}](1);            // (G)
   var instanceField                            
      : Int {self != prop}                      // (H)
      = (prop + 1) as Int{self != prop};        // (I)
   def this(
      a : Int{a != 0},
      b : Int{b != a}                           // (J)
      )
      {a != b}                                  // (K)
      : Example{self.prop == a &amp;&amp; self.proq==b} // (L)
   {
      super();                                  // (M)
      property(a,b,a);                          // (N)
      // fields initialized here
      instanceField = b as Int{self != prop};   // (O)
   }

<div class="p"><!----></div>
   def someMethod() = 
        prop + staticField + instanceField;     // (P)
}
</pre>


<div class="p"><!----></div>

</body>
</html>