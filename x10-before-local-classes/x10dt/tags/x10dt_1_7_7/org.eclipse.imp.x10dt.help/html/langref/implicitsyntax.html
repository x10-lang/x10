<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>Implicit Syntax</title>
</head>

<body>
 <h2><a name="tth_sEc15">
15</a>&nbsp;&nbsp;Implicit Syntax</h2><a name="ImplicitSyntax">
</a>

<div class="p"><!----></div>
Recall that the explicit syntax for  X10 requires the programmer to use
asyncs/future to ensure the Locality Principle: An activity accesses
only those mutable locations that reside in the same place as the
activity. 

<div class="p"><!----></div>
Explicit syntax has the advantage that the performance model for  X10
is explicit from the syntax. It has the disadvantage that the
programmer has to manually reason about the placement of various
objects. If the programmer reasons incorrectly then computation may
abort at runtime with an exception.

<div class="p"><!----></div>
The place-based type system enables the compiler to support the
Locality principle. The programmer uses the type system to establish
that the types of various objects are local. These assertions are
checked by the compiler (as a side-effect of checking dependent
types). Additionally, the programmer may now use normal variable
syntax to access (read/write) variables, and invoke methods on
objects. Suppose the type of the variable v is C(:c). If c establishes
loc==here then the compiler generates code for performing the relevant
operation on the local variable (read, write, method invocation)
synchronously. 

<div class="p"><!----></div>
Otherwise the compiler generates code in explicit syntax as
follows. If the operation is a read, the compiler generates code to
perform a future/force on the variable

<div class="p"><!----></div>
<pre>
  future(v)v.force();  
</pre>

<div class="p"><!----></div>
If the operation is a write  - v=e - , the compiler generates code to perform
the write synchronously:

<div class="p"><!----></div>
<pre>
  final T temp = e;
  finish async (v) v = w;
</pre>

<div class="p"><!----></div>
If the operation is a read on an array variable a[p] the compiler
generates the code:

<div class="p"><!----></div>
<pre>
  future(a.dist[p]) a[p].force();  
</pre>

<div class="p"><!----></div>
If the operation is a write  - a[p]=e - , the compiler generates code to perform
the write synchronously:

<div class="p"><!----></div>
<pre>
  final point tp = p;
  final T t = e;
  finish async (a.dist[tp]) a[tp] = t;
</pre>

<div class="p"><!----></div>
If the operation is a method invocation  - e.m(e1,..., en) -  for a void
method, the compiler generates code to perform the method invocation
synchronously:

<div class="p"><!----></div>
<pre>
  final T@ t = e;
  final P1@ t1 = e1;
  ...
  final Pn@ tn = en;
  finish async (t) 
    t.m(t1,..., tn);
    
</pre>

<div class="p"><!----></div>
If the operation is a method invocation  - e.m(e1,...,en) -  for a method
that returns a value of type E, then the compiler generates the
following code:

<div class="p"><!----></div>
<pre>
  new Runnable() 
  public E run() 
    final T@ t = e;
    final P1@ t1 = e1;
    ...
    final Pn@ tn = en;

<div class="p"><!----></div>
    return future(t)t.m(t1,...tn).force();
  .run()
</pre>

<div class="p"><!----></div>
</body>
</html>