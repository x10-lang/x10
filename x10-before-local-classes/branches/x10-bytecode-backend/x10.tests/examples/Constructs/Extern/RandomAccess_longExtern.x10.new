/*
 *
 * (C) Copyright IBM Corporation 2006
 *
 *  This file is part of X10 Test.
 *
 */
import harness.x10Test;;
import x10.array.Dist;
import x10.array.Array;

/**
 * RandomAccess benchmark.
 *
 * Based on HPCC 0.5beta
 *
 * The external "starts" routine is written in C.
 *
 * @author kemal
 * @author vj approx 7/2004
 * New version, 11/2004
 */
public class RandomAccess_longExtern extends x10Test {

	// Set places.MAX_PLACES to 128 to match original
	// Set LOG2_TABLE_SIZE to 25 to match original

	public const MAX_PLACES: int = x10.lang.place.MAX_PLACES;
	public const LOG2_TABLE_SIZE: int = 5;
	public const LOG2_S_TABLE_SIZE: int = 4;
	public const TABLE_SIZE: int = (1<<LOG2_TABLE_SIZE);
	public const S_TABLE_SIZE: int = (1<<LOG2_S_TABLE_SIZE);
	public const N_UPDATES: int = (4*TABLE_SIZE);
	public const N_UPDATES_PER_PLACE: int = (N_UPDATES/MAX_PLACES);
	public const WORD_SIZE: int = 64;
	public const POLY: long = 7;
	public const S_TABLE_INIT: long = 0x0123456789abcdefL;
	// expected result with LOG2_S_TABLE_SIZE = 5,
	// LOG2_S_TABLE_SIZE = 4
	public const EXPECTED_RESULT: long = 1973902911463121104L;

	/** Get the value as a table index.
	 */
	def f(var val: long): int = { return (int) (val & (TABLE_SIZE-1)); }
	/** Get the value as an index into the small table.
	 */
	def g(var val: long): int = { return (int)(val>>>(WORD_SIZE-LOG2_S_TABLE_SIZE)); }

	/** Return the next number following this one.
	 * Actually the next item in the sequence generated
	 * by a primitive polynomial over GF(2).)
	 */
	def nextRandom(var val: long): long = { return ((val << 1) ^ (val < 0 ? POLY : 0)); }

	/*
	 * Utility routines to create simple common dists
	 */
	/**
	 * create a simple 1D blocked dist
	 */
	def block(var arraySize: int): dist = {
		return distmakeBlock([0..(arraySize-1)]);
	}

	/**
	 * create a unique dist (mapping each i to place i)
	 */
	def unique(): dist = {
		return distmakeUnique(x10.lang.place.places);
	}

	/**
	 * The random number "starts" routine is in external C code
	 */
	native static def starts(var n: long): long;
	static { System.loadLibrary("RandomAccessLong"); }

	/**
	 * main RandomAccess routine
	 */
	public def run(): boolean = {

		// A small value table that will be copied to all processors
		final val smallTable: Array[long] = new Array[long](Dist.makeConstant([0..S_TABLE_SIZE-1], here), (var p: point[i]): long => { return i*S_TABLE_INIT; });
		// distributed histogram table
		final val table: Array[long] = new Array[long](block(TABLE_SIZE), (var p: point[i]): long => { return i; });
		// random number starting seeds for each place
		final val ranStarts: Array[long] = new Array[long](unique(), (var p: point[i]): long => { return starts(N_UPDATES_PER_PLACE*i); });

		// In all places in parallel, repeatedly generate random indices
		// and do remote atomic updates on corresponding table elements
		finish ateach (val p: point[i] in ranStarts) {
			var ran: long = nextRandom(ranStarts(i));
			for (val q: point[n] in [1..N_UPDATES_PER_PLACE]) {
				System.out.println("Place "+i+ " iteration "+n);
				final val j: int = f(ran);
				final val k: long = smallTable(g(ran));
				async(table.dist(j)) atomic table(j) ^= k;
				ran = nextRandom(ran);
			}
		}
		final val sum: long = table.sum();
		System.out.println("Check sum = "+sum);
		return sum == EXPECTED_RESULT;
	}

	public static def main(var args: Rail[String]): void = {
		new RandomAccess_longExtern().execute();
	}
}
