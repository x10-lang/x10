
The basic idea is to allow classes to have type properties as well as
value properties. A type property is declared similarly to a type
parameter in Java. For example, the following code declares a class List
with type property T:

class List<T> { T get(int i) { ... } }

Type properties of a class C are type members of C. Like type members
defined using typedefs, type properties can be referred to from outside:

final List xs = ...;
xs.T x = xs.get(0);

Type properties are superficially similar to virtual types, but for
Java-friendliness are declared like type parameters. Type properties can
be declared invariant, covariant, or contravariant. Virtual types are
(historically) not contravariant.

Application of a type to anything is interpreted as refinement. That is,
List<int> is equivalent to List(:self.T = int) and thus is a subtype of
List.

[edit </mediawiki/index.php?title=X10_1.5_Design&action=edit&section=29>]


    Class definitions

Grammar extensions:

ClassDeclaration ::=
  ClassModifiersopt class Identifier
    TypePropertyListopt PropertyListopt
    Superopt Interfacesopt ClassBody
TypePropertyList ::= < TypeProperties WhereClauseopt >
TypeProperties ::= TypeProperty
                 | TypeProperties , TypeProperty
TypeProperty ::= Varianceopt Identifier DepParametersopt
               | Varianceopt Identifier <= Type
               | Varianceopt Identifier >= Type
Variance ::= + | -
WhereClause ::= : Expression

A + variance tag means the class is covariant on the property: the
property must appear in positive positions in the class body (e.g.,
method return types and the types of final fields and properties). A -
variance tag means the class is contravariant in the property.
Contravariant properties may appear only as method or constructor
arguments. No tag means the class is invariant in the property.

The TypeProperty syntax |<X <= T, Y >= U, Z>| is sugar for |<X, Y, Z : X
<= T && Y >= U>|

[edit </mediawiki/index.php?title=X10_1.5_Design&action=edit&section=30>]


    Types

The type syntax allows properties:

ClassOrInterfaceType ::=
  TypeName TypeParametersopt DepParametersopt PlaceTypeSpecifieropt
TypeParameters ::= < TypeArgumentList WhereClauseopt >

Examples:

List<C>
List<C>(3)
List<C>(:n==3)         // same as previous
List<:T == C>(:n == 3) // same as previous
List<:T <= C>          // similar to List<? extends C>

Methods may be parameterized, using similar syntax to Java:

MethodHeader ::=
  MethodModifiersopt TypeParameterListopt
  ResultType MethodDeclarator Throwsopt
TypeParameterList ::= < TypeParameters >
TypeParameters ::= Identifier
                 | TypeParameters, Identifier

<A,B> Pair<A,B> pair(A a, B b);
<S> List<S> map(Mapper<T,S> f);
<S <= T> S downCast(T x);

Variance tags are not allowed in method declarations.

Calls may instantiate type parameters:

List<String> ys = xs.<String>map(f);

The method type parameters may be inferred using the static type of the
arguments (and possibly the return type). It is a static error if
inference is impossible. We could possibly do more inference, but this
little bit is enough (I think) to match what Java does.


[edit </mediawiki/index.php?title=X10_1.5_Design&action=edit&section=31>]


    Constraints


Types may be constrained by a predicate on the type's properties. These
constraints are of the form:

c ::= T1 == T2
    | T1 <= T2
    | T1 => T2
    | e instanceof T
    | e1 == e2
    | c1 && c2

Types are:

T ::= C | p.X | C<:c1>(:c2) | p.X<:c1>(:c2)

c1 constrains the type properties of the base type, c2 constrains the
value properties.

The type C<T1..Tk>(e1..en) is equivalent to (:self.class <= C && self.X1
== T1 && ... && self.Xk == Tk && self.p1 == e1 && ... && self.pn == en)
where T1..Tk are type properties and p1..pn are value properties.

Objects have an implicit type property 'class' bound to the base class
of the type, and an implicit property 'type' bound to the return type of
the constructor.

For class C<X1,...,Xn>, C<T1,...,Tn> is sugar for C<:self.X1==T1 && ...
&& self.Xn==Tn> Just as with the value property constraints, self refers
to the object whose type is being defined.

A positional actual Ti produces the constraint self.Xi==Ti if Xi is
invariant, self.Xi<=Ti if covariant, and self.Xi>=Ti if contravariant.

[edit </mediawiki/index.php?title=X10_1.5_Design&action=edit&section=32>]


    Variance annotation

[edit </mediawiki/index.php?title=X10_1.5_Design&action=edit&section=33>]


      Definition-side variance

Type properties may be annotated at their declaration as either
covariant or contravariant using the following syntax:

interface Iterator<+T> { T next(); }
interface Sink<-T> { void put(T x); }

When a variance annotation is given, positional actuals are interpreted
as <= or >= type bound constraints rather than as type equality
constraints. That is, for class C<X1,...,Xn> and type C<T1,..,Tn>, the
positional actual Ti produces the constraint self.Xi==Ti if Xi is
invariant, self.Xi<=Ti if covariant, and self.Xi>=Ti if contravariant.

It is a static error for a covariant type property to appear in a
negative position in the class declaration or a contravariant property
to appear in a positive position.

[edit </mediawiki/index.php?title=X10_1.5_Design&action=edit&section=34>]


      Use-side variance

Variance annotations can be used at type uses as well.

In Java, one writes:

// assuming C extends B and List<T> is invariant on T
List<? extends B> bs;
List<C> cs;
bs = cs; // ok

The equivalent in X10:

List<:T <= B> bs;
List<C> cs;
bs = cs; // ok

Or with variance annotations:

List<+B> bs;
List<C> cs;
bs = cs; // ok

List<T==C> is a subtype of List<T <= B> because T==C entails T <= B.

Design note: It is permitted for a use-side variance annotation to flip
the variance of a definition-side annotation. Thus, C<+X> can be
instantiated as C<-T>. The resulting type is C<X <= T & X >= T>, or
simply C<X = T>. Perhaps this should be made illegal to avoid confusion.

[edit </mediawiki/index.php?title=X10_1.5_Design&action=edit&section=35>]


    Constructors

Constructors can take type parameters:

class C<T>(int n) {
   <S> C<S>(int n) {
       property<S>(n);
   }
}

Type parameters can be omitted. In this case, the parameters are
implicit and passed through to the property call. This following is
equivalent to the above code:

class C<T>(int n) {
   C(int n) {
       property(n);
   }
}

As is:

class C<T>(int n) {
   C<T>(int n) {
       property<T>(n);
   }
}

This might be confusing though:

class C<S,T> {
   <U,V> C<V,U>() {
      property<V,U>();
   }
}

C<A,B> = new C<A,B>; // no!
C<A,B> = new C<B,A>; // ok!

Of course, you can shoot yourself in the foot with any language. Perhaps
only implicit type parameters should be allowed; this would be
compatible with Java.


[edit </mediawiki/index.php?title=X10_1.5_Design&action=edit&section=36>]


    Examples

More examples at: Generics examples
</mediawiki/index.php/Generics_examples>

Now let us look at the definitions of some classes to get a feel for the
new syntax.

[edit </mediawiki/index.php?title=X10_1.5_Design&action=edit&section=37>]


      Lists

abstract class List<+T>(int n: n >= 0) {
  List() { }
  abstract T get(int i: 0 <= i && i < n);
  abstract <S> List<S>(n) map(Mapper<T,S> m);
  abstract List<T>(n) reverse();
  abstract List<T>(n+a.n) append(List<T> a);
}

class Nil extends List(0) {
  Nil<S>() { super<S>(); }
  T get(int i: 0 <= i && i < n) { assert false; }
  <S> List<S>(n) map(Mapper<T,S> m) { return new Nil<S>(); }
  List<T>(0) reverse() { return this; }
  List<T>(a.n) append(List<T> a) { return a; }
}

class Cons extends List {
  T head;
  List<T> tail;

  Cons(:n == xs.n+1)(T x, List<T> xs) {
    super<T>();
    property(xs.n+1);
    head = x; tail = xs;
  }

  Cons(1)(T x) {
    this(head, new Nil());
  }

  T get(int i: 0 <= i && i < n) {
    if (i == 0) return head;
    return tail.get(i-1);
  }
 
  <S> List<S>(n) map(Mapper<T,S> m) {
    return new Cons(m.map(head), tail.map(m));
  }

  List<T>(n) reverse() {
    return tail.reverse().append(new Cons(head, new Nil<T>()));
  }
  
  List<T>(n+a.n) append(List<T> a) {
    return new Cons(head, tail.append(a));
  }
}

[edit </mediawiki/index.php?title=X10_1.5_Design&action=edit&section=38>]


      More examples

Generic methods are permitted with the same syntax as Java:

 class Foo {
  <T> List<T>(m.n) sort(List<T> m) {...} // sort is of type <T>List<T>(m.n)(List<T>m)
 }

Another example:

 class Matrix<T>(int m, int n) { 
   Matrix<T>(m,a.n) multiply(Matrix<T> n) { ...}

 interface Possession<T <= Owner>(T owner){}
 class Stockade<T,S <= Possession>(T owner) {
   public type MyS = S(:owner==this.owner);
   Set<MyS> value = new EmptySet<MyS>();
   public void add(MyS v) { value.add(v); }
   public boolean inStockade(myS o) { return value.contains(o);}
   public boolean isOwner(T o1) { return owner.equals(o1);}
 }
 class Person extends Owner {}
 class Horse(Person p) extends Possession(p) {...} // Possession<Person>(p) inferred
 Person sam = new Person();
 Person jim = new Person();
 Stockade<Person,Horse>(sam) c = 
   new Stockade<Person,Horse>(sam); // this stockade only contains horses owned by sam.
 
 Horse(sam) h1 = new Horse(sam);
 Horse(jim) h2 = new Horse(jim);
 c.add(h1); // ok: c's type is Stockade<Person,Horse>(sam), 
            // expected arg type is Horse(sam)
 c.add(h2); // compile-time type check error.

[edit </mediawiki/index.php?title=X10_1.5_Design&action=edit&section=39>]


      Queues

interface Queue<E: E <= Object> {
  E get();
  void put(E e);
}

[edit </mediawiki/index.php?title=X10_1.5_Design&action=edit&section=40>]


      Comparators

interface Ordered<S: S <= Object> {
  boolean leq(S o);
}

interface Comparator<M: M <= Ordered<M>> {
  boolean compare(M e, M f) { return e.leq(f); }
}

class Point implements Ordered<Point>
  int x, y;
  boolean leq(Point o) { return x.leq(o.x) && y.leq(o.y); }
}

Comparator<Point> cp;
Point p1 = new Point();
Point p2 = new Point();
if (cp.compare(p1, p2)) ...

[edit </mediawiki/index.php?title=X10_1.5_Design&action=edit&section=41>]


      Model/view

class ModelViewFW<M, V: M <= Model, V <= View> {
  class Model {
    ViewSet vs = new ViewList();
    void registerView(V v) { vs.append(v); }
    void changed() {
      for (V v : vs) {
        v.update(this);
      } 
    }
  }  
       
  abstract class View {
    void update(M m);
  }

  type ViewList = List<V>;
}  
 
class DrawFW extends ModelViewFW<DrawModel, DrawView> {
  class DrawModel extends Model {
    Text getFigure() { ... }
  }

  class DrawView extends View {
    void update(M m) {
      ... m.getFigure() ...
    }
  }
}  

final DrawFW draw = new DrawFW();
draw.M model = new DrawFW.DrawModel();
draw.V view = new DrawFW.DrawView();

model.registerView(view);
model.changed();

[edit </mediawiki/index.php?title=X10_1.5_Design&action=edit&section=42>]


      Binary methods

interface Set {
  void union(Set<:class==this.class> s);
}

class BitSet extends Set {
  long bits;
  void union(Set<:class==this.class> s) {
    bits |= s.bits; // ok!
  }
}

Set<:class==this.class> is a subtype of BitSet when this : BitSet. This
is because Set<:c> is really sugar for <:c, self.class <= Set>

[edit </mediawiki/index.php?title=X10_1.5_Design&action=edit&section=43>]


    Run-time semantics

Unlike Java, type properties and members are not erased at run-time.
Following PolyJ, each instance of a parameterized class has an adapter
object that assists in implementing the 'instanceof' and 'cast'
operations. The adapter can also be used for creating instances of
arrays of the parameter. For example:

class List<T> {
  T[] x;
  List() { x = new T[10]; }
}

new List<int>();
new List<int(:self == 3)>();

is translated to:

class List {
  Object x;
  T$adapter a;

  List(T$adapter a) { this.a = a; x = a.newArray(10); }

  abstract static class T$adapter {
    abstract Object newArray(int n);
    abstract boolean instanceof$T(Object o);   // o instanceof T
    abstract boolean instanceof$List(List o);  // o instanceof List<T>
  }
}

class int$adapter extends List.T$adapter {
  static int$adapter singleton = new int$adapter();
  Object newArray(int n) { return new int[n]; }
  boolean instanceof$T(Object o) { return o instanceof IntWrapper; }
  boolean instanceof$List(List o) { return o.a == this; }
}

class int3$adapter extends List.T$adapter {
  static int3$adapter singleton = new int3$adapter();
  Object newArray(int n) { return new int[n]; } // FIXME: need to supply initializer to ensure invariant
  boolean instanceof$T(Object o) { return o instanceof IntWrapper && ((IntWrapper) o).value == 3; }
  boolean instanceof$List(List o) { return o.a.entails(this); }
    // just need o.a == this if only used invariantly
}

new List(int$adapter.singleton);
new List(int3$adapter.singleton);

Note we need to do run-time constraint solving to implements casts and
instanceof List<T>. This could be avoided when the type property T is
invariantâ€”the adapters just need to be compared for equality. We could
statically disallow casts and instanceof to C<T> when T is not invariant.

A class C might instantiate another class D on one of its type
properties T. Thus, C needs to be able to locate the D<T> adapter. We
need some mechanism for this. C's adapter for T could work if we do not
have instanceof$C method (only instanceof$T). D cannot call any more
methods of T than C can. Disallowing all casts to C<T> would allow the C
adapter to be usable by D.


NextGen is implemented by generating abstract snippet methods in List.
Instantiations of List override the snippet methods. I'm not sure we can
use this approach.

/Question: Do Type properties have a run-time representation?/

Types need a run-time representation to support instanceof and casts. A
type property can be represented as a Type-value field in an object.
Several (all?) type properties might be bundled together into a single
object to avoid a large per-object overhead. Maybe the properties can be
outlined altogether and passed around as a separate object. For example:

   void m(List l) {
      if (l.T == int)
          l.add(1);
   }

might be implemented as:

    void m(List l, [[ Type ]] LT) {
       if (LT == [[ int ]])
           l.add(1);
    }

This would be the same implementation as for:

    void m(List(:self.T == LT) l, Type LT) {
       if (LT == int) l.add(1);
    }

The advantage of this approach is that the per-object overhead is zero
when the type parameter is used only locally. There is extra call
overhead, however, and this could be a problem with heavily
parameterized classes and methods. We could do this for value properties
as well as type properties.


*Question:* Do we want structural constraints, so can do |new T()|?

*Question:* Perhaps use reflection rather than adapter objects. Get
around polymorphic recursion problems: |class C<T> { ... C<List<T>> ...
C<T[]> ... }|

[edit </mediawiki/index.php?title=X10_1.5_Design&action=edit&section=44>]


    Exceptions

/Question: Should we allow parameterized exceptions?/ Catching them will
have to test the properties.

For example:

   class E<T> extends Exception { ... }
   try {
      ... throw new E<A>;
      ... throw new E<B>;
   }
   catch (E<A> e) { S1 }
   catch (E<B> e) { S2 }

might be translated to:

   class E extends Exception { T$adapter T; ... }
   try {
      ... throw new E<A>;
      ... throw new E<B>;
   }
   catch (E e) { if (e.T <= A) S1
                 else if (e.T <= B) S2
                 else throw e; // rethrow
   }

/Question: Should we allow throwing type parameters?/ For example:

   class C<E <= Exception> {
      void m() throws E { ... throw new E(); ... }
      <F <= Exception> void n() throws F { ... throw new F(); ... }
   }

[edit </mediawiki/index.php?title=X10_1.5_Design&action=edit&section=45>]


    Function type properties

Can override behavior of type properties using value properties of
function types.

   public class HashMap<-K,+V>
       (int(K) hashCode, boolean(K,K) kequals)
   {
       // default constructor
       HashMap<A,B>() { property<A,B>(A.hashCode, A.equals); }

       // non-default constructor
       HashMap<A,B>(int(A) h, boolean(A,A) eq) {
           property<A,B>(h, eq);
       }

       V get(K key) { ... hashCode(key) ... kequals(key, e.key) ... }
   }

This lets you do:

   new HashMap<String, int>()  // as usual

   new HashMap<String, int>(
       int(String s) { s.toLowerCase().hashCode(); },
       String.equalsIgnoreCase)   // ignoring case

Type defs are really desired for this.

Structural constraints on type properties can be translated into
function properties. We might even do this desugaring for cast and
instanceof for type properties. For example:

   class C<T> {
       T x;
       void m(Object o) { x = (T) o; }
   }

   new C<String>()

translates to:

   class C<T>(T(Object) cast) {
       T x;
       void m(Object o) { x = cast(o); }
   }

   new C<String>(String(Object o) { (String) o })

Adapter objects are not needed, then.


[edit </mediawiki/index.php?title=X10_1.5_Design&action=edit&section=46>]


    Formalization

Type properties calculus
</mediawiki/index.php?title=Type_properties_calculus&action=edit>

[edit </mediawiki/index.php?title=X10_1.5_Design&action=edit&section=47>]


    Issues

Do we want structural constraints?

    * has method m
    * has constructor C -- would enable new T 

Can we ensure run-time constraint solving are not needed?

    * need to handle casts to T
          o can be done with adapter object 
    * need to handle casts to C<T>
          o may need to do run-time constraint solving to check if
            run-time type is subtype of C<T>
          o if T is invariant, can just check if adapter objects are equal 

Polymorphic recursion:

    * can C<T> use C<C<T>> 

Adapter objects:

    * need to create adapter class for each instantiation
    * can these be shared? 

