\chapter{Clocks}\label{XtenClocks}\index{clocks}

Many concurrent algorithms proceed in phases: in phase {$k$}, several
activities work independently, but synchronize together before proceeding on
to phase {$k+1$}. X10 supports this communication structure (and many
variations on it) with a generalization of barriers \bard{cite something}
called {\em clocks}. Clocks are designed so that programs which follow a
simple syntactic discipline will not have either deadlocks or race conditions.


The following minimalist example of clocked code has two worker activities A
and B, and three phases. In the first phase, each worker activity says its
name followed by 1; in the second phase, by a 2, and in the third, by a 3.  
So, if \xcd`say` prints its argument, 
\xcd`A-1 B-1 A-2 B-2 A-3 B-3`
would be a legitimate run of the program, but
\xcd`A-1 A-2 B-1 B-2 A-3 B-3`
(with \xcd`A-2` before \xcd`B-1`) would not.

The program creates a clock \xcd`cl` to manage the phases.  Each worker does
the work of its first phase, and then executes \xcd`next;` to signal that it
is finished with that work. \xcd`next;` is blocking, and causes the worker to
wait until all workers have finished with the phase -- as measured by the
clock \xcd`cl` to which they are both registered.  
Then they do the second phase, and another \xcd`next;` to make sure that
neither proceeds to the third phase until both are ready.  This example uses
\xcd`finish` to wait for both workers to finish.  The parent thread is also
registered on the clock just as the workers are, and executes \xcd`next;next;`
to run through the phases.


%%TODO -- put the 'atomic' back in when that's legal.

%~~gen
%package Clocks.For.Spock;
%class ClockEx {
%  static def say(s:String) = 
% { /*atomic{x10.io.Console.OUT.println(s);}*/ }
%  public static def main(argv:Rail[String]!) {
%~~vis
\begin{xten}
    val cl = Clock.make();
    finish{
      async clocked(cl) {// Activity A
        say("A-1");
        next;
        say("A-2");
        next;
        say("A-3"); 
      }// Activity A

      async clocked(cl) {// Activity B
        say("B-1");
        next;
        say("B-2");
        next;
        say("B-3"); 
      }// Activity B
      next;next;       
    }
    say("All done");

\end{xten}
%~~siv
%  }
% }
%~~neg

This chapter describes the syntax and semantics of clocks and
statements in the language that have parameters of type \xcd"Clock". 

The key invariants associated with clocks are as follows.  At any
stage of the computation, a clock has zero or more {\em registered}
activities. An activity may perform operations only on those clocks it
is registered with (these clocks constitute its {\em clock set}).  An
activity is registered with one or more clocks when it is created.
During its lifetime the only additional clocks it is registered with
are exactly those that it creates. In particular it is not possible
for an activity to register itself with a clock it discovers by
reading a data-structure.

The primary operations that an activity \xcd`a` may perform on a clock \xcd`c`
that it is registered upon are: 
\begin{itemize}
\item It may {\em register} a newly-created activity on \xcd`c`: 
      \xcd`async clocked(c){S}`.
\item It may {\em unregister} itself from \xcd`c`, with \xcd`c.drop()`.  After
      doing so, it can no longer use most primary operations on \xcd`c`.
\item It may {\em resume} the clock, with \xcd`c.resume()`, indicating that it
      has finished with the current phase associated with \xcd`c` and is ready
      to move on to the next one.
\item It may {\em wait} on the clock, with \xcd`c.next()`.  This first does
      \xcd`c.resume()`, and then blocks the current activity until the start
      of the next phase, \viz, until all other activities registered on that
      clock have called \xcd`c.resume()`.
\item It may {\em block} on all the clocks it is registered with
      simultaneously, by the command \xcd`next;`.  This calls \xcd`c.next()`
      on all clocks \xcd`c` that the current activity is registered with.
\item Other miscellaneous operations are available as well; see the
      \xcd`Clock` API.
\end{itemize}

%%CLOCK%% An activity may perform the following operations on a clock \xcd"c".
%%CLOCK%% It may {\em unregister} with \xcd"c" by executing \xcd"c.drop();".
%%CLOCK%% After this, it may perform no further actions on \xcd"c"
%%CLOCK%% for its lifetime. It may {\em check} to see if it is unregistered on a
%%CLOCK%% clock. It may {\em register} a newly forked activity with \xcd"c".
%%CLOCK%% %% It may {\em post} a statement \xcd"S" for completion in the current phase
%%CLOCK%% %% of \xcd"c" by executing the statement \xcd"now(c) S". 
%%CLOCK%% Once registered and "active" (see below), it may also perform the following operations.
%%CLOCK%% It may {\em resume} the clock by executing \xcd"c.resume();". This
%%CLOCK%% indicates to \xcd"c" that it has finished posting all statements it
%%CLOCK%% wishes to perform in the current phase. Finally, it may {\em block}
%%CLOCK%% (by executing \xcd"next;") on all the clocks that it is registered
%%CLOCK%% with. (This operation implicitly \xcd"resume"'s all clocks for the
%%CLOCK%% activity.) It will resume from this statement only when all these
%%CLOCK%% clocks are ready to advance to the next phase.

%%CLOCK%% A clock becomes ready to advance to the next phase when every activity
%%CLOCK%% registered with the clock has executed at least one \xcd"resume"
%%CLOCK%% operation on that clock and all statements posted for completion in
%%CLOCK%% the current phase have been completed.

Though clocks introduce a blocking statement (\xcd"next") an important
property of \Xten{} is that clocks -- when used with the \xcd`next;` {\em
  statement} only, without the \xcd`c.next()` method call -- cannot introduce
deadlocks. That is, the system cannot reach a quiescent state (in which no
activity is progressing) from which it is unable to progress. For, before
blocking each activity resumes all clocks it is registered with. Thus if a
configuration were to be stuck (that is, no activity can progress) all clocks
will have been resumed. But this implies that all activities blocked on
\xcd"next" may continue and the configuration is not stuck. The only other
possibility is that an activity may be stuck on \xcd"finish". But the
interaction rule between \xcd"finish" and clocks
(\Sref{sec:finish:clock-rule}) guarantees that this cannot cause a cycle in
the wait-for graph. A more rigorous proof may be found in \cite{X10-concur05}.

\section{Clock operations}\label{sec:clock}
There are two language constructs for working with clocks. 
\xcd`async clocked(cl) S` starts a new activity registered on one or more
clocks.  \xcd`next;` blocks the current activity until all the activities
sharing clocks with it are ready to proceed. 
Clocks are objects, and have a number of useful methods on them as well.

\subsection{Creating new clocks}\index{clock!creation}\label{sec:clock:create}

Clocks are created using a factory method on \xcd"x10.lang.Clock":


%~~gen
% package Clocks.For.Spocks;
%class Clockuser {
% def example() {
%~~vis
\begin{xten}
val timeSynchronizer: Clock = Clock.make();
\end{xten}
%~~siv
%}}
%~~neg

%%CLOCKVAR%% \eat{All clocked variables are implicitly \xcd`val`. The initializer for a
%%CLOCKVAR%% local variable declaration of type \xcd"Clock" must be a new clock
%%CLOCKVAR%% expression. Thus \Xten{} does not permit aliasing of clocks.
%%CLOCKVAR%% Clocks are created in the place global heap and hence outlive the
%%CLOCKVAR%% lifetime of the creating activity.  Clocks are structs, hence may be freely
%%CLOCKVAR%% copied from place to 
%%CLOCKVAR%% place. (Clock instances typically contain references to mutable state
%%CLOCKVAR%% that maintains the current state of the clock.)
%%CLOCKVAR%% }

The current activity is automatically registered with the newly
created clock.  It may deregister using the \xcd"drop" method on
clocks (see the documentation of \xcd"x10.lang.Clock"). All activities
are automatically deregistered from all clocks they are registered
with on termination (normal or abrupt).

\subsection{Registering new activities on clocks}
\index{clock!clocked statements}\label{sec:clock:register}

The statement 

%~~gen
%package Clocks.For.Jocks;
%class Qlocked{
%static def S():Void{}
%static def flock() { 
% val c1 = Clock.make(), c2 = Clock.make(), c3 = Clock.make();
%~~vis
\begin{xten}
  async clocked (c1, c2, c3) S
\end{xten}
%~~siv
%();
%}}
%~~neg
starts a new activity, initially registered with
clocks \xcd`c1`, \xcd`c2`, and \xcd`c3`, and  running \xcd`S`. The activity running this code must
be registered on those clocks. Furthermore, it cannot be quiescent on any of
them (see \Sref{resume}), because that would introduce a race condition.
Violations of these conditions are punished by the throwing of a
\xcd"ClockUseException"\index{clock!ClockUseException}. 

% An activity may transmit only those clocks that are registered with and
% has not quiesced on (\Sref{resume}). 
% A \xcd"ClockUseException"\index{clock!ClockUseException} is
%thrown if (and when) this condition is violated.

An activity may check that it is registered on a clock \xcd"c" by
%~~exp~~`~~`~~c:Clock ~~
the predicate \xcd`c.registered()`


\begin{note}
\Xten{} does not contain a ``register'' operation that would allow an activity
to discover a clock in a datastructure and register itself on it. Therefore,
while a clock \xcd`c` may be stored in a data structure by one activity
\xcd`a` and read from it by another activity \xcd`b`, \xcd`b` cannot do much
with \xcd`c` unless it is already registered with it.  In particular, it
cannot register itself on \xcd`c`, and, lacking that registration, cannot
register a sub-activity on it with \xcd`clocked(c) async S`.
\end{note}

\oldtodo{Add text on arrays of clocks.}

\subsection{Resuming clocks}\index{clock!resume}\label{resume}\label{sec:clock:resume}
\Xten{} permits {\em split phase} clocks. An activity may wish
to indicate that it has completed whatever work it wishes to perform
in the current phase of a  clock \xcd"c" it is registered with, without
suspending all activity. It may do so  by executing 
%~~exp~~`~~`~~c:Clock ~~
\xcd`c.resume()`.



An activity may invoke \xcd`resume()` only on a clock it is registered with,
and has not yet dropped (\Sref{sec:clock:drop}). A
\xcd"ClockUseException"\index{clock!ClockUseException} is thrown if this
condition is violated. Nothing happens if the activity has already invoked a
\xcd"resume" on this clock in the current phase. Otherwise, \xcd`c.resume()`
indicates that the activity will not transmit \xcd"c" to an 
\xcd"async" (through a \xcd"clocked" clause), 
until it terminates, drops \xcd"c" or executes a \xcd"next".

\bard{The following is under investigation}
\begin{staticrule*}
It is a static error if any activity has a potentially
live execution path from a \xcd"resume" statement on a clock \xcd"c"
to a
%\xcd"now" or
async spawn statement (which registers the new
activity on \xcd"c") unless the path goes through a \xcd"next"
statement. (A \xcd"c.drop()" following a \xcd"c.resume()" is legal,
as is \xcd"c.resume()" following a \xcd"c.resume()".)
\end{staticrule*}

\subsection{Advancing clocks}\index{clock!next}\label{sec:clock:next}
An activity may execute the statement
\begin{xten}
next;
\end{xten}

\noindent 
Execution of this statement blocks until all the clocks that the
activity is registered with (if any) have advanced. (The activity
implicitly issues a \xcd"resume" on all clocks it is registered
with before suspending.)

An \Xten{} computation is said to be {\em quiescent} on a clock
\xcd"c" if each activity registered with \xcd"c" has resumed \xcd"c".
Note that once a computation is quiescent on \xcd"c", it will remain
quiescent on \xcd"c" forever (unless the system takes some action),
since no other activity can become registered with \xcd"c".  That is,
quiescence on a clock is a {\em stable property}.

Once the implementation has detected quiescence on \xcd"c", the system
marks all activities registered with \xcd"c" as being able to progress
on \xcd"c". An activity blocked on \xcd"next" resumes execution once
it is marked for progress by all the clocks it is registered with.

\subsection{Dropping clocks}\index{clock!drop}\label{sec:clock:drop}
%~~exp~~`~~`~~ c:Clock~~
An activity may drop a clock by executing \xcd`c.drop()`.



\noindent{} The activity is no longer considered registered with this
clock.  A \xcd"ClockUseException" is thrown if the activity has
already dropped \xcd"c".


%\input{clock/now.tex}

\section{Program equivalences}
From the discussion above it should be clear that the following
equivalences hold:

\begin{eqnarray}
 \mbox{\xcd"c.resume(); next;"}       &=& \mbox{\xcd"next;"}\\
 \mbox{\xcd"c.resume(); d.resume();"} &=& \mbox{\xcd"d.resume(); c.resume();"}\\
 \mbox{\xcd"c.resume(); c.resume();"} &=& \mbox{\xcd"c.resume();"}
\end{eqnarray}

Note that \xcd"next; next;" is not the same as \xcd"next;". The
first will wait for clocks to advance twice, and the second
once.  

%\notinfouro{\input{clock/imp-notes.tex}}
%\notinfouro{\input{clock/clocked-types.tex}}
%\notinfouro{\input{clock/examples.tex}}

