\documentclass[nocopyrightspace,preprint,9pt]{sigplanconf}

\usepackage{times-lite}
\usepackage{mathptm}
\usepackage{txtt}
\usepackage{stmaryrd}
\usepackage{code}
%\usepackage{ttquot}
\usepackage{bcprules}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{afterpage}
\usepackage{balance}
\usepackage{defs}
\usepackage{pldefs}
\usepackage{utils}
\usepackage[pdftex]{graphicx}
\usepackage{ifpdf}

\ifpdf
\setlength{\pdfpagewidth}{8.5in}
\setlength{\pdfpageheight}{11in}
\fi


% \input{../../../../vj/res/pagesizes}
% \input{../../../../vj/res/vijay-macros}
\newcommand\alt{\bnf}

\newcommand\Implies{\Rightarrow}

\newtheorem{example}{Example}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}

\newcommand\Xten{{X10}}
\newcommand\java{{Java}}
\newcommand\Java{{\java}}
\newcommand\csharp{{C$\sharp$}}
\newcommand\FXten{{FX10}}

\begin{document}
\title{Constrained Types for Object-Oriented Languages}
\authorinfo{Vijay Saraswat \and Nathaniel Nystrom}
   {IBM T.~J. Watson Research Center \\
    P.O. Box 704 \\
    Yorktown Heights, NY 10598}
   {\{vsaraswa,nystrom\}@us.ibm.com}
%\authorinfo{Nathaniel Nystrom}
%   {IBM T.~J. Watson Research Center \\
%    P.O. Box 704 \\
%    Yorktown Heights, NY 10598}
%   {nystrom@us.ibm.com}
%\authorinfo{Radha Jagadeesan}
%   {Depaul University}
%   {rjagadeesan@cs.depaul.edu}
%\authorinfo{Jens Palsberg}
%   {University of California--Los Angeles}
%   {palsberg@cs.ucla.edu}

\maketitle

% \conferenceinfo{POPL'08}{XXX}
% \copyrightyear{2008}
% \copyrightdata{[to be supplied]}

\begin{abstract}
We formalize the basic ideas of dependent-types for Java-like
languages, in the context of \FXten, a Featherweight version of \Xten{}.
\end{abstract}

\section{Introduction}

% motivation
% overview

\Xten{} is a modern statically typed object-oriented (OO) language
designed for high productivity in the high performance computing (HPC)
domain~\cite{X10}. \Xten{}, like most OO languages is designed around the notion
of objects, as instances of {\em classes}. However, \Xten{} places
equal emphasis on {\em arrays}, a central data-structure in high
performance computing. In particular, \Xten{} supports dense,
distributed multi-dimensional arrays of value and reference types,
built over index sets known as {\em regions}, and mappings from index
sets to places, known as {\em distributions}.  \Xten{} supports a rich
algebra of operations over regions, distributions and arrays.

In designing a static type system for \Xten{} a central problem
arises. It becomes necessary to permit types, such as {\tt region(2)},
the type of all two-dimensional regions, {\tt int[5]}, the type of
all arrays of {\tt int} of length {\tt 5}, and {\tt int[region(2)]},
the type of all {\tt int} arrays over two dimensional regions.
The underlying
general idea is that of {\em dependent types}: types
parametrized by {\em values} \cite{xi99dependent}.
%, just as generic
%types are types paramterized by other types \cite{genericjava}.

In this paper we develop a general syntactic and semantic framework
for {\em constrained types}, user-defined dependent types
in the context of modern class-based
OO languages such as \java{}, \csharp{} and \Xten{}. Our central
insight is that a rich, user-extensible type system can be developed
on top of predicates over the {\em immutable} state of objects. Such
types statically capture many common invariants naturally arising in
code. Given a single dependently typed class or interface {\tt C}, a
user may construct a potentially infinite family of types {\tt C(:e)}
where {\tt e} is a predicate on the immutable state.
\eat{
The design also
supports the definition of dependent methods.
}
\eat{
Dependent types interact
naturally with generic types.
}

As in staged languages~\cite{nielson-multistage,ts97-multistage},
the design distinguishes between
compile-time and run-time evaluation. Constrained types are
checked (mostly) at compile-time.
The compiler uses a
constraint solver to perform universal reasoning (``for all possible
values of method parameters'') for dependent type-checking.  There is
no run-time constraint-solving.  However,
run-time casts to dependent types are
permitted; these casts involve arithmetic, not
algebra---the values of all parameters are known.

We outline the design for a compiler that can use an extensible
constraint-solver for type-checking.
This design is implemented in the \Xten{} compiler.
No extension of an
underlying virtual machine is necessary, except as may be useful in
improving efficiency (for example, eliminating array bounds checks).
The compiler translates source
programs into target programs without dependent types
but with {\tt assume} and {\tt assert} statements.
A general
constraint propagator that depends only on the operational semantics
of the language and is parametric on the underlying constraint solver
may be run on the program in order to eliminate branches and {\tt
asserts} forced by the assumptions. If all {\tt assert}s cannot be
eliminated at compile-time, some residual constraint-checking
({\em not} solving) may need to be performed at runtime.
%
XXX contrast with hybrid type checking

\section{Criteria}

% design criteria

\section{Language overview}

Our basic approach to introducing dependent types into
class-based statically typed OO languages is to
follow the spirit of generic types, but use values instead of
types.

\subsection{Constrained types}

We permit the definition of a class {\tt C} to specify
a list of typed parameters, or {\em properties},
{\tt (T1 x1, \ldots, Tk xk)} similar in syntactic structure to
a method argument list. Each
property in this list is treated as a {\tt public final} instance
field of the class.
We also permit the
specification of a {\em class invariant}, a
{\em where clause}~\cite{where-clauses}
in the class definition. A where
clause is a boolean expression on the parameters separated from the
parameter list with a ``{\tt :}''.  The compiler ensures that all
instances of the class created at runtime satisfy the where clause
associated with the class.
Thus, for instance, we may specify a class {\tt List} with an
{\tt int length} property as follows:
\begin{code}
  class List(int length: length >= 0) \{...\}
\end{code}

Given such a definition for a class {\tt C},
types can be constructed by {\em constraining} the properties of
{\tt C}.
In principle, {\em any} boolean expression over the
properties specifies a type: the type of all instances of the
class which satisfy the boolean expression. Thus,
{\tt List(:length == 3)} is a permissible type, as are
{\tt List(:length <= 41)} and even
{\tt List(:length * f() >= g())}.
If {\tt C} has no properties, the only type that can be
constructed is the type {\tt C}.

Accordingly, a {\em parametric type} is of the form {\tt C(:e)}, the name of
a class or interface {\tt C}, called the {\em base class}, followed by a
where clause {\tt e}, called the {\em condition}, a boolean expression
on the properties of the base class. 
The denotation, or
semantic interpretation, of such a type is the set of all instances
of subclasses of the base class whose properties satisfy the
condition.
Clearly, for the denotation of a parametric type $t$ to be
non-empty the condition of $t$ must be consistent with the class
invariant, if any, of the base class of $t$.  The compiler is required to
ensure that the type of any variable declaration is non-empty.

For brevity, we write {\tt C} as a type as well; it
corresponds to the (vacuously) parametric type {\tt C(:true)}.
We also permit the syntax {\tt C(t1,\ldots, tk)} for
the type {\tt C (:x1 == t1 \&\& \ldots \&\& xk == tk)} (assuming that
the property list for {\tt C} specifies the {\tt k} properties {\tt
x1,\ldots, xk}, and each term {\tt ti} is of the correct
type). Thus, using the definition above, {\tt List(n)} is the type of
all lists of length {\tt n}.

Parametric types naturally come equipped with a {\em subtyping
structure}: type $t_1$ is a subtype of $t_2$ if the denotation of
$t_1$ is a subset of $t_2$. This definition satisfies
Liskov's Substitution Principle~\cite{liskov-behaviors}),
and implies that
{\tt C(:e1)} is a subtype of {\tt C(:e2)} if {\tt e1} implies {\tt e2}.
In particular, for all conditions {\tt e},
{\tt C(:e)} is a subtype of {\tt C}.
{\tt C(:e)} is empty exactly
when {\tt e} conjoined with {\tt C}'s class invariant is inconsistent.

Two parametric types {\tt C1(:e1)} and {\tt C2(:e2)} are considered equivalent
if {\tt C1} and {\tt C2} are the same base type and {\tt e1} and
{\tt e2} are equivalent when considered as logical expressions.

\subsection{Method and constructor preconditions}

Methods and constructors may specify preconditions
on their parameters as where clauses.
For an invocation of a method (or
constructor) to be type-correct, the
associated where clause must be statically known to be satisfied. The
return type of a method may also contain expressions involving the
arguments to the method. However, we will require
that any argument used in this way must be declared {\tt final},
ensuring it is not mutated by the method body.
For instance:
\begin{verbatim}
  List(arg.length-1)
    tail(final List arg : arg.length > 0) {...}
\end{verbatim}
\noindent will be a valid method declaration. It says that
{\tt tail} must be passed a non-empty list, and it returns a list
whose length is one less than its argument.

\subsubsection{Constructors for dependent classes}

Like a method definition,
a constructor may
specify preconditions on its arguments
and a postcondition on the value produced by the constructor.

Postconditions may be specified in a constructor declaration between
the name of the class and the argument list of the constructor using a
where clause. The where clause can reference only the properties of
the class.

For instance, the
nullary constructor for {\tt List} ensures that the property
{\tt length} has the value {\tt 0}:
{\footnotesize
\begin{verbatim}
    /** Returns the empty list. */
    public List (:length==0)() {
      property(0);
    }
\end{verbatim}}
The {\tt property} statement is used to set all the properties
of the new object simultaneously.  Capturing this assignment in
a single statement simplifies checking that the constructor
postcondition and class invariant are established.  In a class
has properties, every path through the constructor must contain
exactly one {\tt property} statement.

%% Cannot throw an exception.

\eat{
\subsection{Dependent methods}

XXX huh?  What's the different btwn these and final formals.  --n

We will permit {\em dependent methods} (similar to generic methods): a
method may specify a list of parameters in the same way that a class
may. The parameters may be used to construct dependent types for the
arguments and return value of the method.
}

\eat{
\paragraph{Dependent, generic types.}
We will permit a type to be simultaneously a dependent and a generic type.
For instance, we will permit the type:
{\footnotesize
\begin{verbatim}
  List(3)<Point>
\end{verbatim}}
\noindent This is the type of all lists with {\tt 3} elements, each of
which is a {\tt Point}.
}

\eat{
\paragraph{Static parameters.}
We will permit {\em static parameters}. A static parameter is a {\tt
parameter constant} field of a class, i.e., a static final field
explicitly marked as a parameter. Some fields may be marked as {\tt
config} fields: {\tt config} fields are implicitly {\tt parameter
constant} and their values are assigned from the invocation
environment for the program (e.g., command line or a configuration
file).

All expressions appearing in parametric types must reference only
constants or instance or static parameters visible at that type or
variables declared {\tt final}. Further, they must only involve
methods that have been specially marked as parametric. This
facilitates compile-time type-checking, as discussed below.
}

%% Figure out the real condition. Not sure this is important.

\subsection{Constraints}

In this framework, types may be constrained by any boolean
expression over the properties.  For practical reasons,
restrictions need to be imposed to ensure constraint checking is
decidable.

The condition of a parametric type must be a pure
function only of the properties of the base class.
Because properties are
{\tt final} instance fields of the object,
this requirement
ensures that whether or not an object belongs to a parametric type does
not depend on the {\em mutable} state of the object.
That is, the status of the
predicate ``this object belongs to this type'' does not
change over the lifetime of the object.  Second, by insisting that each
property be a {\em field} of the object, the question of
whether an object is of a given type can be
determined merely by examining the state of the object and evaluating
a boolean expression. Of course, an implementation is free to not {\em
explicitly} allocate memory in the object for such fields. For
instance, it may use some scheme of colored pointers to implicitly
encode the values of these fields~\cite{???}.
\eat{
Recall further that \Xten{}
requires the immutable state of an object (the ``value kernel'') to be
transmitted with the reference to an object; thus a remote place may
evaluate casts of objects to parametric types using only information
available with the reference to the object.
}

Further, by requiring that the programmer distinguish certain {\tt
final} fields of a class as properties, we ensure that the programmer
consciously controls {\em which} {\tt final} fields should be available for
constructing parametric types. A field that is ``accidentally'' {\tt
final} may not be used in the construction of a parametric type. It must be
declared as a property.

\java{}-like languages permit constructors to throw exceptions. This
is necessary to deal with the situation in which the arguments to a
constructor for a class {\tt C} are such that no object can be
constructed which satisfies the invariants for {\tt C}. Dependent
types make it possible to perform some of these checks at
compile-time. The class invariant of a class explicitly captures
conditions on the properties of the class that must be satisfied by
any instance of the class.  Constructor preconditions capture
conditions on the constructor arguments.
The compiler's static check for
non-emptiness of the type of any variable captures these invariant
violations at compile-time.

\eat{
\paragraph{Rest of this paper}
In the next section I flesh out the syntactic details of the current
proposal and consider a small example, {\tt List(n)}. After that I
present the code for {\tt place}, {\tt region}, {\tt point}, {\tt
distribution} and {\tt arrays} in \Xten. Most of the methods are {\tt
extern} methods (defined natively); however their signature shows how
considerable information about the structure of the datatypes and the
operations on them can be expressed through the type system.
}



\subsection{Extending dependent classes}

A class may extend a parametric class.

{\em MetaNote: This should be standard. A class definition may extend
a dependent super class, e.g. class Foo(int i) extends Fum(i*i) \{
\ldots \}. The expressions in the actual parameter list for the super
class may involve only the parameters of the class being defined. The
intuition is that these parameters are analogous to explicit arguments
that must be passed in every super-constructor invocation.}

\subsection{An example}

\begin{figure*}
{\footnotesize
\begin{verbatim}
public value class List(int length : length >= 0) {
  Object head = null;
  List(length-1) tail = null;

  /** Returns the empty list. */
  public List(:length==0)() {
      property(0);
  }

  /** Returns a singleton list. */
  public List(:length==1)(Object head) {
    this(head, new List());
  }
  /** Returns the cons of head and tail. */
  public List(:length==tail.length+1)(Object head, final List tail) {
    property(tail.length+1);
    this.head = head;
    this.tail = tail;
  }
  public List(length+arg.length) append(final List arg) {
    return (length == 0)
          ? arg
          : new List(head, tail.append(arg));
  }
  public List(length) rev() {
    return rev(new List());
  }
  public List(length+acc.length) rev(final List acc) {
    return (length == 0)
          ? acc
          : tail.rev(new List(head, acc));
  }
  /** Return a list of compile-time unknown length, obtained by filtering
      this with f. */
  public List(:self.length <= this.length) filter(Predicate f) {
    if (length==0) return this;
    if (f.isTrue(head)) {
      List<Object> l = tail.filter(f);
      return new List(l+1)(head, l);
    } else {
      return tail.filter(f);
    }
  }
}
\end{verbatim}}
%% Aha a design choice here!!
%% Have parameter(..) or not.
\caption{List example}
\label{fig:list-example}
\end{figure*}

Figure~\ref{fig:list-example} shows a {\tt List} class.
Intuitively, this definition states that a {\tt List} has a {\tt int}
property {\tt length}, which must be non-negative.  The
class has two fields that hold the head and tail of the list.

The first constructor {\tt List()} has a postcondition that
signifies that it returns a list of length 0.
The constructor body contains a {\tt property} statement
that initializes the {\tt length} property to {\tt 0}.
The compiler verifies that
the constructor postcondition and the class invariant
are implied by the {\tt property} statement
and any {\tt super} calls in the constructor body imply

The 
second constructor returns a singleton list of length {\tt
1}. The third constructor returns a list of length {\tt m+1}, where
{\tt m} is the length of the second argument. 
If an argument appears in the return type then the argument must be
declared {\tt final}. Thus the argument will point to the same object
throughout the evaluation of the constructor body.

Functions that append one list to another or that reverse a list can
be defined quite naturally. In both cases the size of the list
returned is known statically (as a function of the size of the list
and the argument to the method).  The example also illustrates a
method {\tt filter} which returns a list whose length cannot be known
statically since it depends on the argument predicate {\tt f};
the list length can be bounded, however.

\eat{
XXX
Finally, the example illustrates a dependent method. This example is
discussed more below.
}


\eat{
\subsubsection{Implicit parameters}
A dependent class may also specify additional parameters in the body
of the class. Such parameters are called {\em implicit} parameters.
Syntactically, an implicit parameter is specified using instance field
declaration syntax and prefixing the field declaration with the
keyword {\tt parameter}. The declaration of parameters must include an
initializer which may depend only on parameters defined in the
parameter list for the class or on previously defined parameters in
the class body.

In what follows by the {\em parameters} of a (dependent) class we will
mean either the explicit parameters enumerated in the parameter list,
or the implicit parameters defined using a {\tt parameter} declaration
in the body of the class. Parameters may be used  in an
expression specifying the value of some other parameter (in a
constructor or method call).

\begin{example}
The class {\tt List} may be extended to define an implicit {\tt
boolean} parameter {\tt isEven} which records whether the length of
the list is even.
{\footnotesize
\begin{verbatim}
  public value class List(int length : length >= 0) {
    parameter boolean isEven = (length % 2 == 0);
    ...
  }
\end{verbatim}}
\end{example}

The parameters of a class may be used in any type expression in the
body of the class at which they are visible. Parameters have the
status of final instance fields, hence they are not visible in static
fields, initializers or methods, or when they are overridden.
}


\eat{
\subsubsection{Dependent methods}
Instance method declarations may specify parameters after the
qualifiers and before the return type of the method, through a
parameter list (called the {\em parameter list} of the
method\footnote{We shall use the term ``arguments'' or ``argument
list'' for the usual arguments passed to a method.}).  The parameter
list may be followed by a where expression on the parameters of the
method and/or the parameters of the class. (Recall that a where
expression is a boolean expression following a ``{\tt :}''.)

The parameter list of the method is visible in the declaration of the
method and the body of the method. Each parameter is treated as a {\tt
final} local variable in the body of the method.  The types of
arguments to the method, and the return type of the method, may be
built from type expressions referencing these parameters.

A method invocation must specify the parameters in an actual parameter
list after the name of the method and before the arguments to the
method.  For each such method invocation, the compiler must determine the
corresponding method definition and statically check that its where
clause (if any) is satisfied by the invocation.

{\em MetaNote Need to determine rules for overriding for generic
methods and compare with the rule above.}

Dependent methods are useful in particular when a parameter in the
type of the result is not functionally determined by parameters of
arguments. For instance, suppose we want to write a method to return
the list of all numbers upto $n$. This method cannot take $n$ as an
argument because then it would not be able to assert that the return
type of the method is {\tt List(n)} (all variables that can be
referenced in the return type of a method must be parameters visible
to the method). Thus instead of writing
{\footnotesize
\begin{verbatim}
    public static List<nat> gen(nat m) {
       // returns the list of numbers from 0 to m.
    }
\end{verbatim}}
\noindent one may write:
{\footnotesize
\begin{verbatim}
    public static (nat m) List(m)<nat> gen() {
       // returns the list of numbers from 0 to m.
    }
\end{verbatim}}

Such a method may be invoked as:
{\footnotesize
\begin{verbatim}
    List(32)<nat> l = C.gen(32)();
\end{verbatim}}

%% TODO vj: Hmm... can the argument be a runtime computed value?
%% For usefulness we may need to allow that. But then how do we compile-time check
%% List(m)<nat> l = C.gen(arb())
%% where m is a number already specified and arb() is some random computation
%% on non-parameters?
}

\subsection{Dependent interfaces}

\java{} does not allow interfaces to specify instance fields. Rather all
fields in an interface are final static fields (constants).

X10 supports rich user-definable extensions to the type system by
allowing the user of a type to construct new parametric types: new
types that are predicates on the immutable state of the base type.
For interfaces to support this extension, they must support
user-definable properties, so that parametric types can be
built over interfaces.

As with classes, an interface definition may specify properties
in a 
list after the name of the interface. Similarly, an interface
definition may specify a where clause in its property list. Methods
in the body of an interface may have where clauses
as well.

All classes implementing an interface must have a property
with the same name and
type (either declared in the class or inherited from the superclass)
for each property in the interface. If a class implements
multiple interfaces and more than one of them specify a property
with the same name, then they must all agree on the type of the
property. The class must have a single property with the given name
and type.

The general form of a class declaration is now:
\begin{verbatim}
  class C(T1 x1, ..., Tk xk)
        extends B(:e)
        implements I1(:e1), ..., In(:en) {...}
\end{verbatim}
\noindent
For such a
declaration to type-check, it must be that the class invariant
implies {\tt inv(I) \&\& e}, where {\tt inv(I)} is the invariant associated with
interface {\tt I}.  Again, a parameteric class or interface {\tt I} is taken as
shorthand for {\tt I(:true)}.  Further, every method specified in the
interface must have a corresponding method in the class with the same
signature whose precondition, if any, is implied by the precondition
of the method in the interface.

\eat{
\paragraph{Implementation notes.}

Efficiently implementing dependent interfaces requires two new opcodes
in the VM: getinterface and putinterface, in analogy with
getfield/putfield and getstatic/putstatic. The opcode is just like
getstatic/putstatic. getinterface takes two indexbytes, that are used
to construct an index into the constant pool of the current class. The
constant pool entry must be a CONSTANT_InterfaceFieldref:

{\footnotesize
\begin{verbatim}
CONSTANT_InterfaceFieldref_info {
    		 u1 tag;
    		 u2 interface_index;
    		 u2 name_and_type_index;
   }
\end{verbatim}}

This field must be final. This item is resolved, determining both its
field width and field offset. The value at that offset into the
classref is fetched and pushed onto the stack, after popping the
object reference on top of the stack. Similarly for putinterface.

Execution of this instruction may result in an additional indirection
as compared with the execution of getfield/putfield. This is because
the offset in the block of memory representing the field depends on
the interface and the class of the object at hand. This is similar to
the indirection involved in the implementation of interface method
calls, invokevirtual, and similar techniques may be used to reduce the
overhead.

Until such changes are made, the X10 compiler may transform all
interface field acesses into the invocation of an appropriate getter
interface method. The X10 compiler can automatically construct such a
method for each class implementing the interface. Thus the cost of an
invokevirtual would be paid for each interface field access.
}


%%% Come back to this.

\section{Related work}

Constraint-based type systems:

\cite{mitchell84}

\cite{fuh88}

\cite{curtis90}

\cite{aiken93}

\cite{jones94}

\cite{smith94}

\cite{palsberg95}

\cite{trifonov96}

        Types of the form $T\backslash C$, where $C$ is
        a set of subtyping constraints.

        Not dependent.

\cite{fahndrich99}

% Pottier

Pottier~\cite{pottier96simplifying,pottier01b}
presents a constraint-based type system for an ML-like language with
subtyping.

% HM(X)

HM(X)~\cite{sulzmann97type,pottier01a,pottier-remy-attapl}
is a constraint-based framework
for Hindley--Milner style type systems.
The framework is parameterized on the specific constraint system
X; instantiating X yields extensions of the HM type system.



\begin{itemize}
\item Pottier
\item HM(X)
\item Xi and Pfenning (POPL99)

Dependent types in practical programming.
Dependent ML.  DML(C). Objects drawn from constraint domain C.

Index objects must be pure.
Singleton types int(n).

ML$^{\Pi}_0$:
Refinement of the ML type system: does not affect the
operational semantics.  Can erase to ML$_0$.



\item Ada dependent types

Ada has constrained array definitions.  A constraint
\cite{ada-ref-man}.  Not clear if their dependent.  Are there other dependent
types?

\item singleton kinds (Chris Stone)

\item Nested types, vObj, Scala, gbeta, J\&

Nested types: witness types, p
vObj, Scala: p.type.
J\&: p.class
gbeta: p.C

\item Where clauses for F-bounded polymorphism (Theta and PolyJ)

Bounded quantification: Cardelli and Wegner.  Bound T with T'
F-bounds: Canning, Cook, Hill, Olthoff, Mitchell.  Bound T with F(T).

Not dependent types.

\item Hybrid type checking (Flanagan, POPL06)


Refinement types.  Types can be arbitrary predicates:

        { z : Int | z >= 0 }
        equivalent to the X10 type:
        Int(:self >= 0)

Subtyping is undecidable.  Type-checker can report ``yes'',
``no'',
or ``don't know''.  If the latter, dynamic checks inserted where
subsumption occurs.

Also Hybrid Types, Invariants and Refinements for Imperative
Objects (Flanagan, Freund, Tomb, FOOL06).

    Constraints must be pure.  Update is not pure.
    Calls must have pure actuals + receiver.
    What about alising?


\item Soft typing with conditional types (Aiken, POPL94)

Aiken, Wimmers, and T.K. Lakshman.

\item Cayenne (Augustsson, ICFP98)

Result type of function can depend on argument value.
Any expression is a type.
Haskell-like.
Undecidable type checking.

\item Cardelli, type checking dependent types and subtypes

\item Esterel

\item Findler, Felleisen, Contracts for higher-order functions (ICFP02)

example: int[> 9]

contracts are either simple predicates or function contracts.
defined by (define/contract ...)

enforced at run-time.

\item Jif (final access paths in security labels)
\item FX-90
\item ESCJava \cite{esc-java}, Spec\#
\item JSR 308, Javari
\item Freeman, Pfenning, Refinement types for ML (PLDI91)
\item Holt, Cordy, the Turing programming language
\item Mandelbaum, Walker, Harper, effective thy of type refinements
\item Ou, Tan, Mandelbaum, Walker, Dynamic typing with dependent types

Separate dependent and simple parts of the program.
Statically type the dependent parts.
Dynamic checks when passing values into dependent part.

\item Dependently typed data structurse (Xi)
\item Dead code elimination through dependent types (Xi)
\end{itemize}

\section{Language design}

Constraint system (generic presentation).
Design is constraint-system agnostic.

Principal clause

\section{Examples}

Specific constraint systems used when developing specific
examples.

\subsection{Binary methods}

The binary method problem \cite{bruce}.

Bruce and Cardelli and Castagna and Leavens and Pierce,
On Binary Methods, TAPOS 1(3): 221--242, Fall 1995.

\begin{code}
class IntSet \{
    long bits;
    IntSet(:self.class == this.class)
        union(IntSet(:self.class == this.class) s);
    boolean superSetOf(IntSet(:self.class == this.class) s);
\}
\end{code}

\subsection{Cayenne examples}





\subsection{DML examples}

Red/black tree invariant.

\begin{code}
class Tree \{
    final static Color BLACK;
    final static Color RED;

    Object value;
    int blackHeight;

    Color color;
    Tree left;
    Tree right;

    Tree(Color c, Tree l, Tree r) \{
        color = c;
        left = l;
        right = r;
    \}

    Tree(:color == BLACK && blackHeight == 0 && left == null && right == null) empty();

    Tree(:color == BLACK && blackHeight == l.blackHeight+1 && left == l && right == r)
        black(Tree l, Tree(:self.blackHeight == l.blackHeight) r, Object value);

    Tree(:color == RED && blackHeight == l.blackHeight && left == l && right == r)
        black(Tree l, Tree(:self.blackHeight == l.blackHeight) r, Object value);
\}
\end{code}

Invariant:
1. all leaves black
2. for each node n, there are the same number of black nodes on
every path from n to a leaf (the black height)
3. the immediate children of every red node are black

Bounds checks.

\begin{code}
class Array \{
    T[] a;
    T get(int(:0 <= self \&\& self < a.length) i) \{ return a[i]; \}
    void set(int(:0 <= self \&\& self < a.length) i, T v) \{ a[i] = v; \}
\}
\end{code}

\subsection{Nullable types}

Nullable types (T(:self != null))

\subsection{Arrays}

Array/region/distribution types (examples from X10)

\cite{gps06-arrays}

\subsection{Places}

Place types (examples from X10)

\subsection{Clocks}

Clock types

\subsection{Capabilities}

Capablities (from Radha and Vijay's paper on neighborhoods)

\subsection{Ownership types}

Ownership types~\cite{ownership-types}

\subsection{Discussion}

Dependent types are of use in annotations~\cite{ns07-x10anno}.

\section{Implementation}

The dependent type system is implemented in the X10
compiler~\cite{X10}, which is implemented as an extension of
Java using the Polyglot compiler framework~\cite{ncm03}.

One may understand dependent classes and parametric types via a
simple, compositional source-to-source translation into a language
without these features, but with {\tt assert} and {\tt assume}
statements (as in modern \java{} like languages). A program simplifier
may flow {\tt assume} assertions around the program, treating them as
constraints. It may simplify or eliminate {\tt assert} statements
using logical reasoning over constraints.  If all {\tt assert}
statements are eliminated by the simplifier, then the program is said
to be {\em statically correct}. Otherwise some residual checks are
left for runtime and may generate runtime errors.

Thus compile-time type-checking is seen as a way of performing some
runtime calculations early and ensuring that certain exceptions are
not thrown at runtime.

\subsection{The target language}
The target language for the translation is \Xten{} without dependent
or parametric types, but with {\tt assert} and {\tt assume}
statements, which we now define.

For {\tt e} a boolean expression the statement:
{\footnotesize
\begin{verbatim}
   assume e;
\end{verbatim}}
asserts that {\tt e} will be true whenever control reaches that point
in the code. This assertion is categorical---it does not depend on
any property of the code other than what is expressed through the type
system and hence checked statically. Thus it is a mere
comment---it
does not translate into any runtime code.  A programmer may not add
{\tt assume} statements; only the compiler may add such statements
e.g., when translating an enhanced type system into a base type
system.

On the contrary the statement:
{\footnotesize
\begin{verbatim}
   assert e : s;
\end{verbatim}}
(where {\tt e} is a boolean expression and {\tt s} a string) is an
assertion that says {\tt e} {\em should} be true at runtime whenever
control reaches that point. In case it is not, a runtime error should be thrown
with the given string as argument. Thus it translates into the code:
{\footnotesize
\begin{verbatim}
   if (! e) throw new RuntimeError( s );
\end{verbatim}}

We permit the user to add arbitrary {\tt assert} statements to the
program.

\paragraph{State invariant predications.}
Certain kinds of predications play a special role in {\tt assert} and
{\tt assume} statements. They permit a very direct correspondence
between program execution and constraint-solving and are central to
the idea that a uniform constraint-propagator may eliminate {\tt assert}
statements based on the logical content of {\tt assume} statements.

We say that a predication ({\tt boolean} valued expression) is {\em
state invariant} if its value is independent of any mutations to any
variable (or object referenced by a variable) involved in the
expression. Specifically, any variable occurring in the predication
must be a {\tt final} variable, any field accesses must be to {\tt
final} fields, and any method occuring in the predication must be {\em
state invariant} (see below).  For instance, the predication {\tt
list.n+1==3} for a {\tt final} variable {\tt list} of type {\tt List}
is state-invariant; it depends only on the {\tt final} field {\tt n}
of the {\tt final} variable {\tt list}, the constant {\tt 3} and the
operation {\tt +} which is (intuitively) state invariant.

We permit user-defined methods to occur in state invariant
predications as long as they satisfy certain properties.  Let $m$ be a
method on a class $C$, with $k$ arguments.  We say that it is {\em
state invariant} is it satisfies the property that the set of tuples
of objects on which it succeeds is closed under equivalence of
objects.  Two objects (of the same class) are said to be equivalent if
their immutable state is identical. Thus a state invariant method
satisfies the property that if on being invoked with arguments
$a_1,\ldots, a_k$ it returns an object $a$, then on being invoked with
$a_1', \ldots, a_k'$ where each $a_i$ is equivalent to $a_i$ it will
return a value $a'$ which is equivalent to $a$.

Further such a method $m$ must be associated with a {\em logical
invariant}, a constraint (in the underlying constraint language) of
arity $k+1$, which is a finite representation of the (infinite) {\em
extension} of the method. The extension of a method $m$ which takes
$k$ arguments is the set of all tuples $\langle t_1,\ldots, t_k,
t\rangle$ which satisfy the property that when $m$ is invoked on
$t_1,\ldots, t_k$ it returns $t$.

Thus the constraint is a symbolic representation of the method and can
be used for compile-time symbolic reasoning about the method.  At
runtime we can use the code of $m$ to evaluate a call to $m$, since
all the values of the method arguments are known. At compile-time,
the actual values to a method call are not known. Instead we must
reason about the execution of the body of a method assuming simply
that the arguments are some arbitrary but unknown values (i.e.,
assuming that they are {\em logical variables}). Thus we must use
the logical invariant associated with the method.

For instance each operation on {\tt nat} (e.g., ``{\tt +}'',''{\tt *}'',
``{\tt \%}'' is state invariant and may be associated with a logical
invariant. For instance the  ``{\tt +}'' operation may be associated
with the constraint {\tt x+y=z} in an arithmetic constraint solver.

\paragraph{Simplification of programs with state-invariant {\tt assume} and {\tt asserts}.}

As we shall see below, the translation of a program with dependent and
parametric types introduces only those {\tt assert} and {\tt assume}
statements whose predications are state invariant. (This is easy to
see, dependent classes are designed to express only those properties
of objects which are state invariant.)

State-invariant {\tt assume} and {\tt asserts} are quite easy to
reason with, since the value of the expressions occurring in these
assertions does not change with program execution. Thus the compiler
may transform {\tt assume e} to a {\em tell} of the constraint $c_e$
obtained by simply translating $e$ (treating each program variable as
a logical variable, and replacing each method call in $e$ with the
corresponding logical invariant). An assert statement $s$ of the form
{\tt assert e} can be eliminated if the conjunction of tell
constraints on each path leading into it entails $c_e$, the constraint
obtained from $e$. (If a path is guarded by a conditional, then the
condition may be assumed on the positive path, and the negation on the
negative path.) The ask and tell constraint languages of
\cite{my-thesis-book} may be used fruitfully in this context.


\subsection{The translation}

The basic idea behind the translation is simple. Each dependent class
is translated into a single class of the same name (without dependent
types). The explicit parameters of the dependent class are translated
into {\tt public final} (instance) fields of the target class.

Each constructor of the target class takes a {\tt final} additional
argument for each explicit parameter, and initializes the correspoding
field to that value. Each constructor {\tt assume}s the constructor's
where clause (if any) at the beginning of the constructor, and {\tt
assert}s the class's where condition at the end of the
constructor. Within the body of each constructor a call to a
constructor for the superclass is treated like a method call: an {\tt
assert} is added for the precondition of the super constructor, and
for the arguments of the call to the superconstructor. After the call,
an {\tt assume} is added for the super-class's where clause applied to
{\tt this}.

A dependent method of the source class with $k$ parameters is
translated into a method in the target class of the same name with $k$
additional {\tt final} arguments.\footnote{For simplicity of
presentation we are assuming that the class does not already have a
method with the same name and $k$ extra arguments.} The body of the
target method {\tt assume}s the arguments satisfy the source method's
where clause.  It may also {\tt assume} the class's where clause on
{\tt this} at the begining of the method.  After that it executes the
translated body of the source method.

Now we consider the translation of parametric types in the body of
methods.  For simplicity let us assume that the body of the method is
translated into a ``single assignment'' form with nested method calls
``flattened''. Every argument to a method invocation at a parametric
type is a {\tt final} local variable.  If a method has a parametric
return type then every {\tt return} statement is of the form {\tt
return v} where {\tt v} is a {\tt final} local variable.  Similarly
the value read from every mutable variable of parametric type (e.g.,
local variable, field) is read into a {\tt final} variable of the same
type (i.e., reads of mutable variables of parametric type occur only
on the RHS of an assignment to a {\tt final} local variable). The
value written into every mutable variable of parametric type is read
from a {\tt final} variable of the same type.

Every statement in \Xten{} can be transformed into an equivalent such
statement by introducing enough new {\tt final} local variables. For
instance the method:
{\footnotesize
  \begin{verbatim}
    public  List(n+arg.n) rev(final List arg) {
      return
        (n == 0)
        ? arg
        : rest.rev(new List(1+arg.n)(node, arg));
    }
  \end{verbatim}
}

\noindent is translated to:

{\footnotesize
  \begin{verbatim}
    public  List(n+arg.n) rev( final List arg) {
      if (n==0) {
         return arg;
      } else {
        final List(1+arg.n) arg2 = new List(1+arg.n)(node, arg);
        final List(n-1) restval = rest;              // Read from a mutable field of parametric type
        final List(restval.n+arg2.n) result = restval.rev( arg2 );
        return result;
    }
  \end{verbatim}}

Let {\tt v} be a local variable or field declared at a parametric type
{\tt C(:b)}. The translation will declare {\tt v} at type {\tt C}.
Every write to {\tt v} must be of the form {\tt v=r} where {\tt r} is
a final variable, per the reasoning above. The write must be preceded
by the statement {\tt assert r.b : "DependentTypeError";} where {\tt
r.b} stands for the clause {\tt b} with each parameter {\tt p} in {\tt
b} replaced by {\tt r.p}. Every read of {\tt v} must be of the form
{\tt r=v} where {\tt r} is a {\tt final} variable; such a read is
succeeded by the statement {\tt assume r.e}.

Formal arguments to methods of a parametric type are treated similarly.

Similarly a parametric type occurring as the return type of a method
is replaced in the translation by the base type. Each expression {\tt
return e;} in the body of the method is translated as a write of {\tt e}
to a local variable declared at the parametric type.

Every method invocation is considered as a write to the formal
arguments of the method, and hence preceded by {\tt assert}s if the
type of a formal argument is parametric. It is also preceded by an
{\tt assert} of the method precondition, if any.  Every method
invocation is succeded by an {\tt assume} of the return type of the
method applied to the return value.

For instance the code above is translated to:
{\footnotesize
  \begin{verbatim}
    public  List(n+arg.n)<Node> rev( final List<Node> arg) {
      if (n==0) {
         assert n+arg.n == arg.n : "DependentTypeError"; // For the return value.
         return arg;
      } else {
        assert 1+arg.n-1=arg.n : "DependentTypeError"; // For the argument to the constructor
        final List<Node> arg2 = new List<Node>(1+arg.n,node, arg));
        assume arg2.n==1+arg.n;                      // From the constructor invocation
        final List<Node> restval = rest;             // Read from a mutable field of parametric type
        assume restval.n == n-1;                     // From the field read.
        final List<Node> result = restval.rev( arg2 );
        assume result.n=restval.n+arg2.n
        assert n+arg.n == result.n                   // For the return value
        return result;
    }
  \end{verbatim}}

\paragraph{Simplifcation}
The statement in the body of the method now generates the following
constraint operations. Here we assume that {\tt arg} and {\tt n}
{\tt restval}, {\tt result}, {\tt arg2} are free {\tt nat} variables.

There is a single path to the first ask, guarded by {\tt n=0}. Thus the constraint problem
to be solved is:
{\footnotesize
  \begin{verbatim}
      n=0,  (n+arg.n = arg.n => Remove1)
\end{verbatim}}
\noindent The underlying constraint system can solve the problem:
{\footnotesize
  \begin{verbatim}
      n=0 |-  (n+arg.n = arg.n)
\end{verbatim}}
\noindent thereby establishing {\tt Remove1}. Hence the first {\tt assert} can be removed.

\noindent There is a single path to the second and third asks, guarded by {\tt
n!=0}. The constraint problem generated is:
{\footnotesize
  \begin{verbatim}
      (n!= 0),  (1+arg.n-1 =arg.n) => Remove2
      1+arg.n-1 = arg.n,
      arg2.n =1+arg.n,
      restval.n = n-1,
      result.n = restval.n+arg2.n,
      (n+arg.n = result.n) => Remove3
\end{verbatim}}
\noindent  The underlying constraint solver can establish
{\footnotesize
  \begin{verbatim}
      |- 1+arg.n-1=arg.n
\end{verbatim}}
without using any constraint at all (this is vacuously true). Hence
{\tt Remove2} is established. It can also establish:
{\footnotesize
  \begin{verbatim}
      arg2.n =1+arg.n, restval.n = n-1, result.n = restval.n+arg2.n |- n+arg.n=result.n
\end{verbatim}}
\noindent through simple substitution. Hence {\tt Remove3} is established.

For the {\tt List} program, all asserts can be removed. The resulting
program is given in Table~\ref{assume-table1}-\ref{assume-table2}.

\begin{table}
{\footnotesize
\begin{verbatim}
  public value class List <Node> {
    public final nat n;   // is a parameter
    nullable Node node = null;
    nullable List<Node> rest = null;  // All assignments must check n = this.n-1.

    public List ( final nat n ) {
      assume n==0;
      this.n = n;
    }
    public List ( final nat n, Node node ) {
      assume n==1;                         // From the constructor precondition.
      this(n, node, new List<Node>(0));
    }

    public List ( final nat n, Node node, List<Node> rest ) {
      assume n>=1;                               // From the constructor precondition
      assume rest.n==n-1;
      this.n = n;
      this.node = node;
      this.rest = rest;
    }

    public  List<Node> append( final List<Node> arg ) {
      if (n == 0) {
          return arg;
      } else {
          final List<Node> restval = rest;
          assume restval.n == n-1;
          final List<Node> argval = restval.append(arg);
          assume argval.n == restval.n+arg.n;
          final List<Node> result = new List<Node>(n+arg.n, node, argval);
          assume result.n == n+arg.n;
          return result;
      }
    }
\end{verbatim}}
\caption{Translation of {\tt List} (contd in Table~\ref{assume-table2}).}\label{assume-table1}
\end{table}

\begin{table}
{\footnotesize
\begin{verbatim}
    public  List<Node> rev() {
      final List<Node> arg = new List<Node>(0);
      assume arg.n = 0;                           // From the constructor call.
      final List<Node> result = rev( arg );
      assume result.n == n+arg.n;                  // From the method signature
      return result;
    }

    public  List<Node> rev( final List<Node> arg) {
      if (n==0) {
         return arg;
      } else {
        final List<Node> arg2 = new List<Node>(1+arg.n,node, arg));
        assume arg2.n==1+arg.n;                      // From the constructor invocation
        final List<Node> restval = rest;             // Read from a mutable field of parametric type
        assume restval.n == n-1;                     // From the field read.
        final List<Node> result = restval.rev( arg2 );
        assume result.n=restval.n+arg2.n
        return result;
    }

    public List<Node> filter(fun<Node, boolean> f) {
         if (n==0) return this;
         if (f(node)) {
           final List<Node> l = rest.filter(f);
           return new List<Node>(l.n+1,node, l);
         } else {
           return rest.filter(f);
         }
    }


    public static  List<nat> gen( final nat m ) {
         final List<nat> result = gen(0,m);
         assume result.n=m-0 : "DependentTypeError";  // From the method signature
         return result;
    }

    public static List<nat> gen(final nat i, final nat m) {
      assume i <= m;                                   // Method precondition.
      if (i==m) {
        final List result = new List<nat>(m-i);
        assume result.n == m-i;                        // From the constructor call.
        return result;
      } else {
        final List<nat> arg = gen(i+1,m);
        assume arg.n = m-(i+1);                        // From the method call.
        final List result = new List<nat>(m-i, i, arg);
        assume result.n = m-i;                         // From the constructor invocation.
        return result;
    }
  }
\end{verbatim}}
\caption{Translation of {\tt List} (contd.}\label{assume-table2}
\end{table}


\section{Future work}

Type inference

Extensions

\section{Conclusions}
We have presented a simple design for dependent types in \java-like
languages. The design considerably enriches the space of (mostly)
statically checkable types expressible in the language. This is
particularly important for data-structurs such as lists and arrays. We
have shown a simple translation scheme for dependent types into an
underlying language with {\tt assert} and {\tt assume} statements.
The assert and assume statements generated by this translation have
the important property of state invariance. This enables a very simple
notion of simplification for such programs. A general constraint
propagator can simplify programs by using ask and tell operations on
the underlying constraint system. Assert statements are removed if they
are entailed by the conjunction of {\tt assume}s on each path to the
statement.

Our treatment is parametric in that the underlying constraint system
can vary. Indeed the constraint system is not required to be complete;
any incompleteness results merely in certain asserts being relegated
to runtime. Some of these asserts may throw runtime exceptions if they
are violated.

In future work we plan to investigate optimizations (such as array
bounds check elimination) enabled by dependent types. We also plan to
pursue much richer constraint systems, e.g., those necessary to deal
with regions, cyclic and block-cyclic distributions etc.

\bibliographystyle{plain}
\bibliography{master}
\appendix
\section{More extended examples}
Below I discuss the problem of specifying the operations on places, regions,
distributions and arrays in \Xten. I specify the signatures of these
classes, making extensive use of dependent types.

\section*{Acknowledgments}

Radha, Jens.
Igor Peshansky,
Lex Spoon,
Vincent Cave.

\bibliographystyle{plain}
\bibliography{master}
\balance
\appendix
\onecolumn

\section{Basic \FXten}
{\em
TO BE DONE: Add the ability to specify a constraint on super's fields
when subclassing
\mathcd{class C(f:X, var g:Y) extends D(\&c) \{M\}}
Here \mathcd{c} is a constraint on \mathcd{f},\mathcd{g} and the
fields of \mathcd{D}.
}
The abstract syntax for \FXten{} is specified in
Table~\ref{Table:AST}. We consider a parametric version of the
language, with an underlying constraint system $\cal C$ \cite{cccc} being used to
specify dependent types.

\begin{figure}
%% IMPLICIT CTOR CHANGE
\[
\begin{array}{lrcll}
\mbox{(classes)}         & CL    &{::=}& "class"~C(\bar{f}:\bar{X}, "var"~\bar{g}:\bar{Y}) & \\
                         &       &     & ~~~~"extends"~D~\{\bar{M}\}                       & \\
\mbox{(methods)}         & M     &{::=}& "def"~m(\bar{x}:\bar{X} : c):T = e                & \\
\mbox{(expressions)}     & e,r,s &{::=}& "new"~C(\bar{x})                                  & \mbox{(New object)} \\
                         &       &\alt & \{ "val"~x:X=e;~e \}                              & \mbox{(Local variable declaration)} \\
                         &       &\alt & x.m(\bar{x})                                      & \mbox{(Method Invocation)} \\
                         &       &\alt & (T)~e                                             & \mbox{(Cast)} \\
                         &       &\alt & x.f=e                                             & \mbox{(Assignment)} \\
                         &       &\alt & e;~e                                              & \mbox{(Sequencing)} \\
                         &       &\alt & ce                                                & \\
                         &       &\alt & {ce \Implies e : e}                               & \\
\mbox{(types)}           & T,U   &{::=}& C(:c)                                             & \\
                         &       &\alt & "nullable"~C(:c)                                  & \\
\mbox{(constraint)}      & c,d   &{::=}& ce                                                & \\
                         &       &\alt & (\exists x:T)~c                                   & \\
\mbox{(constraint term)} & ce    &{::=}& "null"                                            & \\
                         &       &{::=}& "true"                                            & \\
                         &       &{::=}& "false"                                           & \\
                         &       &{::=}& n                                                 & \\
                         &       &{::=}& x                                                 & \\
                         &       &{::=}& x.f                                               & \\
                         &       &{::=}& ce~"op"~ce                                        & \\
                         &       &{::=}& "op"~ce                                           & \\
\end{array}
\]

\caption{Abstract syntax for \FXten.}\label{Table:AST}
\end{figure}

We follow \cite{FJ,MJ} in our treatment. Meta-variables {\tt C}, {\tt
D}, {\tt E} range over class names (including the ``built-in'' classes
{\tt int}, {\tt boolean} and {\tt Object}); {\tt f} and {\tt g} range over
field names; {\tt m} ranges over method names; {\tt x}, {\tt y}, {\tt
z} range over parameter and local constant names; other meta-variables
are specified in Table~\ref{Table:AST}.

We write $\tt \bar{e}$ as shorthand for $\tt e_1,\ldots, e_n$
(comma-separated sequence); this sequence may be empty ({\tt n=0}).
Similarly for $\bar{x}$.
$\bar{\tt M}$ and $\bar{\tt K}$ are similar except that no commas
separate the items in the sequence. We use the obvious abbreviation:
$\tt\bar{\tt f}:\bar{X},$ for $\tt f_1:X_1,\ldots, f_n:X_n$
({\tt n} may be zero).  {\tt var $\tt\bar{\tt g}:\bar{\tt Y}$}
abbreviates the sequence {\tt var $\tt g_1:Y_1, \ldots, g_n:Y_n$} if
$\tt n > 1$ and the empty sequence otherwise. Empty parameter
sequences may be omitted (like Scala, unlike Java).

%%{\tt this.$\bar{\tt f}$=$\bar{\tt e}$;} abbreviates {$\tt this.f_1=e_1;\ldots
%%this.f_n=e_n$}.  {\tt \{val $\tt\bar{\tt x}:\bar{\tt X}=\bar{\tt
%%e};\}$} abbreviates {\tt \{val $\tt x_1: X_1= e_1;\ldots;
%%x_n:X_n=e_n;\}$}.

Sequences of field declarations, parameter declarations, local
variable declarations, are assumed to not contain any duplicates.
Sequences of methods in a class must not contain two methods with the
same sequence of parameters types.  (\FXten{} permits {\em ad hoc}
polymorphism.)

%% IMPLICIT CTOR CHANGE
\paragraph{Class definition.}

A {\em class definition} specifies {\tt val} (immutable) fields, {\tt var}
(mutable fields) and their types, its super-class, its list of
methods, and an (implicit) constructor. Modulo minor syntactic changes
(and dependent types), one may view the declaration

\[
"class"~C(\bar{f}:\bar{X},~"var"~\bar{g}:\bar{Y})~"extends"~D~\{\bar{M}\}
\]

\noindent as shorthand for the Java class definition:

{\footnotesize
\begin{tabular}[t]{l}
\tt class C extends D \{ \\
\tt  \quad final $\bar{\tt X} \bar{\tt f}$;\\
 \tt \quad $\bar{\tt Y}$\ $\bar{\tt g}$; \\
 \tt \quad C($\bar{\tt X}$\ $\bar{\tt f}$,\,$\bar{\tt Y}$\ $\bar{\tt g}$,\,$\bar{\tt Z}$\ $\bar{\tt h}$) \{\\
  \tt \quad\quad super($\bar{\tt h}$); \\
  \tt \quad\quad this.$\bar{\tt f}$=$\bar{\tt f}$;\\
  \tt \quad\quad this.$\bar{\tt g}$=$\bar{\tt g}$;\\
 \quad \} \\
\tt \quad $\bar{\tt M}$\\
\tt \}
\end{tabular}}

\noindent where $\bar{\tt h}:\bar{\tt Z}$ is the list of argument types of the
constructor for the super class {\tt D}.

\paragraph{Methods.}
In a method definition, {\tt c} is a constraint on the parameters
$\bar{\tt x}$ and the final fields of the current object.  This
constraint must be true (statically) for the method to be invoked.
One can think of {\tt c} as allowing the programmer to specify
conditions on the object which must be true for the method to be
invoked. This flexibility is particularly valuable for nullary methods
-- for such methods the constraint cannot be folded into the type of
arguments.

As usual for references to a field in the body of a class (not within
a dependent type, see below), the occurrence of a field {\tt f} in
{\tt c} stands for {\tt this.f}.

\paragraph{Expressions.}
For expressions, we assume the following precedence order (from less
tight to more tight): sequencing, type-cast, assignment, conditional,
field invocation, method invocation.

We also reserve the local constant names ``{\tt this}'' and ``{\tt
self}''. That is, no program may define a local constant or parameter
named {\tt this} or {\tt self}.

We note that, somewhat unusually, field selection, assignment, method
invocation and constructor invocation take constants as arguments,
rather than expressions. This is necessary because we need a name for
the arguments so that the name can be substituted for the formal
argument in the resulting type. The version of these operations which
takes arbitrary expressionas as arguments can be obtained by combining
with the local variable combinator. Thus, {\tt e.m(e1)} is simply {\tt
\{val x:X=e; \{val y:Y=e1; x.m(y)\}\}}, where {\tt x} and {\tt y} are
new local variables, and the type of the expressions {\tt e} and {\tt
e1} is {\tt X} and {\tt Y} respectively. Below, when writing actual
programs we shall feel free to use the abbreviated {\tt e.m(e1)} form.

The two-armed conditional expression $\tt ce \Implies e : e$ is a
typecase expression: it permits the compiler to reason conditionally
about the expression, by propagating the constraint down the positive
branch and its negation down the negative branch.

\paragraph{Types.}
We reserve the class names ``{\tt Object}'', ``{\tt int}'' and ``{\tt
boolean}''. That is, the user may not define these
classes. \footnote{In a subsequent version of this document we will
introduce value types, and then {\tt int} will be just another value
type, defined with native methods.}

A {\em dependent type} is of the form $C(:c)$ where $c$ is a
constraint.  The phrase ``$:c$'' is called a {\em where
clause}. We abbreviate $:"true"$ to the empty string. Since
empty parameter lists can be omitted, this means that $C(:"true")$
can be abbreviated to $C$.

Intuitively, a type {\tt C(:c)} is the type of all objects that are
instances of {\tt C} and satisfy the condition {\tt c}. Note that if
the condition {\tt c} is unsatisfiable, then the type is
empty. Variables/parameters cannot be declared at empty types; this is
checked statically.

{\tt c} may contain references to parameters and local constants
visible at the point of declaration of the type (including {\tt
this}), and the special constant {\tt self}.  {\tt self} refers to the
object whose type is being specified. A field {\tt f} of {\tt C} may
occur unqualified in {\tt c}, such a reference is supposed to be
shorthand for {\tt self.f}. References to the {\tt f} field of the
current object must be explicitly preceded by {\tt this}.\footnote{
Note that in general {\tt this.f} is different from {\tt self.f}.  For
instance the type {\tt B(:f = this.g)} appearing in the body of the
definition of the class {\tt A} is the type of all instances of {\tt
B} whose {\tt f} field has the same value as the {\tt g} field of the
current {\tt A} object. (It is the same as the type {\tt B(:self.f =
this.g}).)}

{\tt self} is often absent in types. It is particularly useful in {\em
singleton types}, e.g. {\tt Point(:self=p)} which is satisfied by any
object that is an instance of {\tt Point} and is the same as {\tt p},
and in {\em subrange types}, e.g. {\tt int(:self >= 0)}.

%%The special variable {\tt this} may {\em not} be referenced in a typei
%%in the definition of a constructor (e.g., in the constraint in the
%%parameter list of the constructor, or in the return type of the
%%constructor). This recognizes the fact that an object does not exist
%%until it is created.

The type {\tt nullable C(:c)} is the type {\tt C(:c)} together with
the special value {\tt null}. Thus the type {\tt nullable C(:c)} is
never empty: if {\tt c} is inconsistent it permits precisely the value
{\tt null}.

The terms {\tt ce} in a constraint are drawn from an underlying
constraint system, $\cal C$ \cite{cccc}. {\em For now we take the
constraint system to be fixed, but it makes sense to permit the
programmer to extend the constraint system with new value types, and
operations over them, provided that a constraint solver is supplied
for these types.} $\cal C$ specifies a collection of value types
(e.g., {\tt int}, {\tt bool}, constants of those types and operations
on those types.

We also permit the shorthand {\tt C($\overline{\tt ce}$)} for {\tt
C(:$\overline{\tt f}=\overline{\tt ce}$)} where $\tt \overline f$ is the textual
order enumeration of the {\tt val} fields of {\tt C}. If the class has
no field, then we use the shorthand {\tt C(ce)} for {\tt
C(:self=ce)}. Thus {\tt int(0)} is satisfied precisely by the value
{\tt 0}.

Finally, we permit the shorthand $\tt (\exists x:T) C(:c)$ for
$\tt C(\exists x:T)c)$.

{\em In a later version of this document we will introduce type definitions.
This will let us use, for instance, the abbreviation {\tt nat}
for the type {\tt int(:self >= 0)}.
}

\paragraph{Program.}
A {\em program} is a pair of a set of classes and an expression. For
simplicity we shall leave the set of classes implicit. We shall assume
that every class name used in the program (except {\tt Object}) is
defined exactly once in the program. We assume that the class
hierarchy, defined by $\leq$ in the next section is acyclic
(anti-symmetric).

\subsection{Remarks on the syntax}
%%In a class declaration, $\tt\bar{\tt f}$ represents the val (final)
%%fields of the class, $\tt\bar{\tt g}$ the var (mutable)
%%fields.\footnote{ The addition of {\tt var} constructor and method
%%parameters and local variables is routine and omitted for
%%brevity. Similarly for initializers of fields, static fields and
%%methods. We may add exceptions later since they play an integral part in the
%%semantics of concurrent constructs.}

%% $\tt c$ is the {\em class
%% invariant} (a constraint on the fields of the class true for all
%% instances of the class); this must be checked when validating the
%% constructor.\footnote{In the current formulation there is only one
%% constructor, so the class invariant can be folded into the return type
%% of the constructor. However, it makes sense to permit multiple
%% constructors in the future, so we shall retain the separate syntax for
%% the class invariant.}

After Scala \cite{scala}, we have chosen the ML-style variable
declaration (type comes after the variable, and is separated by a
colon), as opposed to conventional Java-style declarations, so that
the return type of a method may appear after the declaration of the
parameters of the method. This permits parameters to appear in the
return type, while respecting the ``define before use''
meta-rule. This syntax also permits types (for parameters, variables
and methods) to be optional, while still retaining readability.  Note
that the language above does not permit mutable constructor or method
parameters.

%%In a constructor declaration, {\tt c} is a constraint on the
%%constructor parameters $\bar{\tt x}$ that must be true for the
%%constructor to be invoked.  A constructor may specify the return type
%%(useful for specifying constraints on the fields of the object
%%returned by the constructor).

The abstract syntax differs from the syntax in \cite{DependentTypes}
in many notational respects. It differs substantively in that there is
no distinction between parameters of classes and fields, and
parameters of methods and arguments to the method. All arguments to a
method are considered final. There are no implicit parameters for
classes.  All final fields of a class may be used in defining a
dependent type on that class.

\subsection{Example}
\begin{example}[List]\label{List}
Consider the class {\tt List}. We shall use generic syntax for
type parameters; this will be formalized in a subsequent version
of this note in a fashion similar to \cite{FJ}. For now,
the reader should understand generic syntax in the spirit of \cite{FJ}.

{\footnotesize
\begin{verbatim}
  class List<X>( n:int(&self>=0),
                 var node: nullable X,
                     rest: nullable List<X>(n-1)) extends Object {
    def makeList:List<X>(0)=new List(0,null, null)
    def makeList(node:X):List<X>(1)=new List(1,node,makeList)
    def makeList{node:X, rest:nullable List<X>):List<X>(rest.n+1)=
     rest==null => makeList(node) : new List(rest.n+1,node,rest)
    def EmptyListInt:List<int(&self>=0)>(0)=new List<int(&self>=0)>(0,null,null)

    def append(arg:List<X>):List<X>(n+arg.n)  =
         (n == 0) => arg : new List<X>(node, rest.append(arg))
    def rplacd(arg:List<X>(n-1)):List<X>(n)  = {
         this.rest=arg;
         this
    }
    def rev : List<X>(n) = rev(new List<X>())
    def rev(arg:List<X>):List<X>(n+arg.n) =
         (n == 0) => arg : rest.rev(new List<X>( node, arg))
    def filter(f: fun<X,boolean>):List<X> =
         (n==0) => this
         : (f(node) =>
           new List<X>(node, rest.filter(f));
            : rest.filter(f))
    /** Return a list of m numbers from o..m-1. */
    def gen(m:int(&self>= 0)):List<int(&self>=0)>(m) = gen(0,m)
    /** Return a list of (m-i) elements, from i to m-1. */
    def gen(i:int(&self>=0), m:int(&self>=i)):List<int(&self>=0)>(m-i) =
       (i == m) => EmptyListInt : EmptyListInt.makeList(i, gen(i+1,m))
  }
\end{verbatim}}

The class {\tt List} has three fields, the {\tt val} field {\tt n},
and the {\tt var} fields {\tt node} and {\tt rest}. {\tt rest} is
required to be a {\tt List} whose {\tt n} field has the value {\tt
this.n-1}.  {\tt n} is required to be non-negative. Note that {\tt
rest} is forced to be {\tt null} if {\tt n=0}, since {\tt
List<X>(n-1)} will be empty in this case.

Three make methods are provided that call the implicit constructor
with different arguments. While the first two return lists of
constant size, the third takes  returns a list of a size
that depends on one of its arguments.

Functions that append one list to another or that reverse a list can
be defined quite naturally. In both cases the size of the
list returned is known statically (as a function of the size of the
list and the argument to the method).  The example also illustrates a
method {\tt filter} which returns a list whose size cannot be known
statically (it depends on properties of the argument function {\tt f}
which are not captured statically).

The {\tt gen} methods\footnote{These should really be {\tt static}.}
illustrate ``{\tt self}''-constraints. The first {\tt gen} method
takes a single argument {\tt m} that is required to be a non-negative
{\tt int}.  The second {\tt gen} method illustrates that the type of a
parameter can depend on the value of another parameter: {\tt m} is
required to be no less than {\tt i}. This assumption are necessary in
order to guarantee that the result type of the method is not empty,
that is, to guarantee {\tt m-i >= 0}.
\end{example}

{\em Note:
Language extensions to be made to get a fuller subset of \Xten:

\begin{itemize}
  \item Add multiple constructors.
  \item Permit arbitrary code in constructors.
  \item Add static state---or at least distinguish between objects and traits.
  \item Permit fields to be overridden?
  \item Add functions.
  \item Add exceptions.
  \item Add places.
  \item Add async, finish, future.
  \item Add regions, distributions and arrays.
  \item Add generics with declaration-time
  covariance/contravariance/invariance, a la Scala.  Generics should
  be instantiable with arbitrary value types.
  \item Consider adding generic values (universal quantification).
  \item Arrays should be generic.
\end{itemize}
}

\subsection{Type system}

A {\em typing environment}, $\Gamma$, is a collection of
constraints. Constraints are taken from the underlying constraint
system $\cal C$, and extended to include tokens of the form {\tt var
x.g:T} (read as: {\em {\tt x} has a field {\tt g} of type {\tt T}})
and {\tt x:T} (read as: {\tt x} has type {\tt T}).

The constraint system satisfies the axiom:

$$
\tt \Gamma, x:C(:c) \vdash c[x/self]
$$

\noindent Thus, for instance, we have:
$$
\tt x:List(: n==3) \vdash x.n==3
$$
\noindent (asuming {\tt n} is a field in {\tt List}, and hence
an abbreviation for {\tt self.n}). We also remind the reader
that for any constraint system $\Gamma \vdash c \wedge d$ iff
$\Gamma\vdash c$ and $\Gamma\vdash d$.

Given a program (collection of classes and an expression), we shall
also assume that the entailment relationship is closed under subtyping (see below):

\infrule{\Gamma \vdash x:C \andalso C \leq D }
        {\Gamma \vdash x:D}

\noindent and field selection. That is,

\infrule{
\Gamma \vdash x:C \ \ \theta= [x/this]\ \  \ class\ C(\bar{\tt f}:\bar{\tt X},\,var\ \bar{\tt g}:\bar{\tt Y}) \ldots }
{
\begin{array}{l}
\tt \Gamma \vdash val\ x.\bar{\tt f} \wedge x.\bar{\tt f} : \bar{\tt X}\theta \\
\tt \Gamma \vdash var\ x.\bar{\tt g} \wedge x.\bar{\tt g} : \bar{\tt Y}\theta
\end{array}
}

\noindent (These assumptions enable us to state in a simple way that
the constraints on fields of a class should be consistent. For, by
requiring that {\tt x:C} be consistent, we require that the
conjunction of all the constraints on the fields of {\tt x} is
consistent, since a constraint is consistent iff its completion under
entailment is consistent.)

Typing judgements for expressions are of the form $\tt \Gamma \vdash
e:T$, read as ``Under the assumptions $\Gamma$, {\tt e} has type {\tt
T}'', and thought of as defining an inference relation that extends
the underlying constraint system.  We use sequence notation in the
obvious way: $\tt \Gamma \vdash \bar{x}:\bar{X}$ is shorthand for the
collection of typing judgements $\tt \Gamma \vdash x_1:X_1 \ldots
\Gamma \vdash x_n:X_n$.

\subsubsection{Type well-formedness rules}

We shall need the judgement $\tt \Gamma \vdash T\star$, read as ``Under
the assumptions $\Gamma$, {\tt T} is a valid type'', and the judgement
$\tt \Gamma \vdash val\ c$, read as ``Under the assumptions
$\Gamma$, {\tt c} is a constant term (not dependent on mutable fields).''


The rules for establishing {\tt val c} are straightforward:
\infax{\vdash "val"~"null"}
\infax{\vdash "val"~"true"}
\infax{\vdash "val"~"false"}
\infax{\vdash "val"~n}
\infax{x:X \vdash "val"~x}
\infrule{\Gamma \vdash X\star \wedge \Gamma \vdash "val"~c}
        {\Gamma \vdash "val"~(\exists x:X) c}
\infrule{\Gamma \vdash "val"~e}
        {\Gamma \vdash "val"~"op"~e}
\infrule{\Gamma \vdash "val"~e_0 \andalso "val"~e_1}
        {\Gamma \vdash "val"~e_0 \mathbin{"op"} e_1}

The only inference rule for establishing $Z\star$ is:
\infrule{\Gamma, "self":C \vdash c:"boolean" \wedge "val"~c}
        {\Gamma \vdash C(:c)\star}

\subsubsection{Subtyping rules}
We will also use the sub-typing judgement $\tt \Gamma \vdash X \leq Y$
on types, read as ``Under the assumptions $\Gamma$ the type $\tt X$ is
a sub-type of $\tt Y$.

\infax{\Gamma \vdash C \leq C}
\infrule{\Gamma \vdash C \leq D \andalso \Gamma \vdash D \leq E}
        {\Gamma \vdash C \leq E}
\infrule{"class"~C(\ldots)~"extends"~D~\ldots}
        {\Gamma \vdash C \leq D}
\infrule{\Gamma \vdash C \leq D \andalso \Gamma, c \vdash d}
        {\Gamma \vdash C(:c) \leq D(:d)}

Under the assumptions of well-formed programs, this relation is acyclic.

\subsubsection{Static semantics rules}
First we cover the rules for literals:
\infax[\rname{T-Lit}]
{
  \begin{array}{l}
    \vdash "null": "nullable"~T \\
    \vdash n:"int"(n)    \\
    \vdash "true":"boolean"("true")  \\
    \vdash "false":"boolean"("false")
  \end{array}
}

\infrule[\rname{T-Nullable}]
        {\Gamma \vdash e:T}
        {\Gamma \vdash e: nullable\ T}

\noindent No rules are needed for typing field access or for
establishing {\tt x:T}; these are covered by the underlying constraint system.

\infrule
[\rname{T-New}]
{
  \begin{array}{l}
   \tt class\ C( \bar{\tt f}:\bar{\tt X},\, var\ \bar{\tt g}:\bar{\tt Y})\; extends\ D \ldots \\
   \tt \bar{\tt h}:\bar{\tt Z} = fields(D) \\
  \tt \Gamma \vdash \bar{\tt x},\bar{\tt y},\bar{\tt z}:\bar{\tt X}_1,\bar{\tt Y}_1,\bar{\tt Z}_1 \\
  \tt \theta= [ \bar{\tt x},\bar{\tt y},\bar{\tt z}/\bar{\tt f},\bar{\tt g},\bar{\tt h}] \\
  \tt \Gamma \vdash \bar{\tt X}_1,\bar{\tt Y}_1,\bar{\tt Z}_1 \leq
                    \bar{\tt X}\theta,\bar{\tt Y}\theta,\bar{\tt Z}\theta  \\
  \end{array}}
{\tt \Gamma \vdash new\ C(\bar{\tt x}, \bar{\tt y}, \bar{\tt z})
  :C(:\bar{\tt f}, \bar{\tt g}, \bar{\tt h} == \bar{\tt x}, \bar{\tt y}, \bar{\tt z})
 }

\infrule
[\rname{T-Invoke}]
{
  \begin{array}{l}
   \tt \Gamma \vdash x,\bar{y}:X,\bar{Y} \\
   \tt m(\bar{z}:\bar{Z}:c):T \in mType(X) \\
   \tt \theta=[x/this,\bar{y}/\bar{z}] \\
   \begin{array}{ll}
   \tt \Gamma \vdash \bar{Y} \leq \bar{Z}\theta \wedge c\theta
   \end{array}
 \end{array}
 }
{\tt \Gamma \vdash x.m(\bar{y}):T\theta}

\infrule
[\rname{T-Local}]
  {
  \begin{array}{l}
    \tt \Gamma \vdash X\star \\
    \tt \Gamma,x:X\ \mbox{\em satisfiable}\\
    \tt \Gamma,x:X \vdash d:Y \wedge Y \leq X \wedge e:Z
  \end{array}
}
{\tt \Gamma \vdash \{val\ x:X=d;e\}:\exists (x:X)\,Z}

\infrule[
\rname{T-UCast}]
{\tt \Gamma \vdash Y\star \andalso \Gamma \vdash e:X \wedge X\leq Y}
{\tt \Gamma \vdash (Y) e: Y}

\infrule[
\rname{T-GCast}]
{\tt \Gamma \vdash Y\star \andalso
\Gamma \vdash e:X \andalso \Gamma \not\vdash X\leq Y}
{\tt \Gamma \vdash (Y) e: Y}

\infrule[
\rname{T-Typecase}]
{
  \begin{array}{lll}
   \tt \Gamma \vdash ce:boolean &  \tt \Gamma, ce \vdash r:T &  \tt \Gamma, !ce \vdash s:T
 \end{array}}
{\tt \Gamma \vdash (ce \Implies r:s) :T}

\infrule[
\rname{T-Method}]
{
  \begin{array}{l}
  \tt M \in \mbox{methods}(C) \\
  \tt M= def\ m(\bar{\tt z}:\bar{\tt Z}:c):T=e\\
   \tt this:C \vdash \bar{\tt Z}\star \\
   \tt \bar{\tt z}:\bar{\tt Z}, this:C \vdash c : boolean \wedge val\ c\\
   \tt \bar{\tt z}:\bar{\tt Z}, this:C, c\ \mbox{\em satisfiable}\\
   \tt \bar{\tt z}:\bar{\tt Z}, this:C, c\vdash e:T
 \end{array}}
{\tt M\ OK\ in\ C}

\infrule[
\rname{T-Class}]
{
  \begin{array}{l}
%\tt \bar{\tt f}:\bar{\tt X},\,\tt\bar{\tt g}:\bar{\tt Y}\ \mbox{\em satisfiable}\\
\tt  this:C \vdash \bar{\tt X}\star\;\&\;\bar{\tt Y}\star\\
\tt \bar{\tt f}:\bar{\tt X},\,var\ \bar{\tt g}:\bar{\tt Y}\ \mbox{\em satisfiable}\\
\tt  D\ OK   \andalso \tt \bar{\tt M}\ OK \ in \ C\\
 \end{array}}
{\tt class\ C(\bar{\tt f}:\bar{\tt X},\, var\, \tt\bar{\tt g}:\bar{\tt Y})\,
    extends\ D \{\bar{\tt M}\}\ OK}

Finally we cover the rules for field assignment and sequencing. These are standard.

\infrule[
\rname{T-Field-w}]
{
  \begin{array}{lll}
  \tt  \Gamma \vdash var\; x.g\;\&\;x.g:U &  \tt \Gamma \vdash e:V & \tt \Gamma \vdash V \leq U
 \end{array}}
{\tt \Gamma \vdash x.g=e:U}

\infrule[
\rname{T-Seq}]
{
  \begin{array}{ll}
   \tt \Gamma \vdash d:S   &
   \tt \Gamma \vdash e:T
 \end{array}}
{\tt \Gamma \vdash d;e:T}

%%\subsubsection{Auxiliary definitions}
%%The rules use some auxiliary definitions.
%%For any type {\tt T}, {\tt fields(T)} is the set of typed fields for that type:
%%$$
%%\begin{array}{l}
%%\begin{array}{ll}
%%\tt fields(Object)=\emptyset & \tt fields(C(\&c))=fields(C)
%%\end{array} \\
%%\tt fields(C)=fields(D),\bar{\tt x}:\bar{\tt X},\bar{\tt y}:\bar{\tt Y}
%%\ \ \mbox{\em if
%%{\tt class C($\tt \bar{\tt x}:\bar{\tt X},var\ \bar{\tt y}:\bar{\tt Y}$\&c) extends D\ldots}}
%%\end{array}
%%$$
%%
%%%%\noindent Given two sets $S$ and $T$ of field type assertions, the set $S,T$
%%%%has all the elements of $T$ and all the elements of $S$ except those
%%%%whose variable is the same as a variable of an element in $T$. Thus
%%%%the above definitions implement field overriding: fields of {\tt C}
%%%%with the same name hide the fields of {\tt D} with the same name (even
%%%%if they have different types).
%%
%%For any type {\tt T}, {\tt varfields(T)} is the set of mutable fields for that type:
%%$$
%%\begin{array}{l}
%%\begin{array}{ll}
%%\tt varfields(Object)=\emptyset & \tt varfields(C(\&c))=varfields(C)
%%\end{array} \\
%%\tt varfields(C)=varfields(D)[\bar{y}:\bar{Y}]\ \ \mbox{\em if
%%{\tt class C($\tt \bar{\tt x}:\bar{\tt X},var\ \bar{\tt y}:\bar{\tt Y}$\&c) extends D\ldots}}
%%\end{array}
%%$$
%%
%%The set of constructors of a type {\tt T=C(\&c)} ({\tt ctor(C)}) is
%%the set of all elements {$\tt C(\bar{\tt x}:\bar{\tt X}\&c):T$} such
%%that the constructor {$\tt def C(\bar{\tt x}:\bar{\tt
%%X}\&c):T$=\ldots} occurs in the definition of the class {\tt C}. We omit a formal definition.
%%The set of methods of a type {\tt T=C(\&c)}, {\tt mType(T)}, is the
%%set of all elements {$\tt m(\bar{z}:\bar{Z}\&c):T$}  such that the method
%%{$\tt def m(\bar{z}:\bar{Z}\&c):T=e$} occurs in the definition of the class
%%{\tt C} or an ancestor class. We omit a formal definition.

\subsection{Example revisited}

Here we consider a concrete constraint system with the type {\tt int}
(with arithmetic operations).

{\em Show the List example type-checks.}

\subsection{Dynamic semantics}

We provide a dynamic semantics as a binary transition relation in the
usual structural operational semantics style.  We consider first the
assignment-free sublanguage (the language without field-assignment,
and sequencing).  For such a language there is no reason to introduce
heaps; the semantics can be specified by a transition relation on just
expressions.  The computation rules are not very different from
\cite{FJ}; in fact they are simpler because we permit only local
constants as receivers of method calls and arguments of method calls
and constructors.

First we define the notion of {\em canonical values}:

\begin{tabular}[t]{|llll|}\hline
 (Canonical Value) & v,w &{::=}& \tt null \alt true \alt false \alt n \alt new C($\bar{\tt v}$)
\\ \hline
\end{tabular}

\vskip 10pt
We shall see that values are {\em terminal} in the dynamic semantics
(they cannot evolve).

\newcommand\derives{\stepsto}
\newcommand\starderives{\stepsmany}

    \infrule[
    \rname{R-Field}]
    {\tt fields(C)=\bar{\tt f}:\bar{\tt X}}
    {\tt (new\ C(\bar{\tt v})).f_i \derives v_i}

    \infrule[
    \rname{R-Invoke}]
    {\tt mbody(m,C)=(\bar{\tt x}, e)}
    {\tt (new\ C(\bar{\tt v})).m(\bar{\tt w}) \derives e[\bar{\tt w}/\bar{\tt x},\,new\ C(\bar{\tt v})/this]}

    \infrule[
  \rname{R-Cast-Null}]{}{\tt (nullable\ T)\; null \derives null}

    \infrule[
  \rname{R-Cast}]
  {
      \tt C \leq D \andalso \tt c[new\ C(\bar{\tt v})/self]\starderives true
  }
  {
    \begin{array}{l}
      \tt (D(\&c))(new\ C(\bar{\tt v})) \derives new\ C(\bar{\tt v}) \\
      \tt (nullable\ D(\&c))(new\ C(\bar{\tt v})) \derives new\ C(\bar{\tt v})
  \end{array}}

  \infrule[
  \rname{R-Local}]
  {}
  {\tt \{val\ x:T=v;\; e\} \derives e[v/x]}

  \infrule[
  \rname{R-Typecase}]
  {}
  {
    \begin{array}{l}
      \tt  true \Implies e_0 : e_1 \derives e_0\\
      \tt  false \Implies e_0 : e_1 \derives e_1\\
  \end{array}}

  \infrule[
  \rname{R-Primitive}]
    {}
    {\begin{array}{l}
	\tt v\ op\ w \derives z \andalso \mbox{({\tt z} is result of {\tt v op w})} \\
	  \tt op\ v  \derives  z \andalso \mbox{({\tt z} is result of {\tt op v})}
	\end{array}}

Finally, we have the context rules:

\infrule[
\rname{R-Context}]
{\tt r \derives r'}
{
  \begin{array}{l}
    \tt \{val\ x:T=r;\, e\} \derives \{val\ x:T=r';\, e\} \\
    \tt r \Implies e_0 : e_1  \derives r' \Implies e_0 : e_1 \\
    \tt (T)\; r \derives (T)\; r'
  \end{array}}

\subsection{Properties of the typing system}
Below, we say that $\tt e$ is {\em stuck} if there is no $\tt r$ such that
$e \derives r$.

{\em Proofs of these lemmas and theorems are being worked on.}

\begin{lemma}[Well-formedness] If $\Gamma \vdash e:T$ then $\Gamma$ is satisfiable,
and $\Gamma \vdash T\star$.
\end{lemma}

\begin{lemma}[Term substitution preserves types] If $\tt \Gamma, x:X \vdash e:T$
and $\tt \Gamma \vdash r:Y$ such that $\tt\Gamma \vdash Y \leq X$ then
$\tt\Gamma \vdash e[r/x]:T'$ for some $\tt T' \leq T$.
\end{lemma}

\begin{theorem}[Type soundness] $\Gamma \vdash e':T'$ whenever
for some $T$ s.t. $\Gamma \vdash T' \leq T$, $\Gamma\vdash e:T$ and
$e \derives e'$.
\end{theorem}

Say that $\Gamma \vdash_s e$ (read: ``{\tt e}'' is safely well-typed in $\Gamma$) if
for some $T$, $\Gamma \vdash_e e:T$ and the derivation does not use rule
\rname{T-GCast}. (Invocations of the cast operation ``checked'' by such a rule can fail
dynamically.)

\begin{theorem}[Safety] If $\Gamma \vdash_s  e$ and $e \vdash e'$ then
$\Gamma \vdash_s e'$. If $\tt \Gamma \vdash_s e$ and $\tt e$ is stuck then $\tt e$ is a value.
\end{theorem}

\section{\FXten{} with places}

{\em
  \begin{itemize}
    \item Follow the outline of my recent set of slides.
    \item Every reference object now has a final {\tt place} field, {\tt loc}.
    \item The constant {\tt here} evaluates to the current place.
    \item {\tt place} is a value type, with a fixed but unknown set of
      operations, we can assume {\tt .next:place}.
    \item The type {\tt T@!} is represented by {\tt T(\&loc=here}), and
      the type {\tt T@x} by {\tt T(\&loc=x.loc)}.
    \item The rules for field read/write and method invocation are changed to require that
      the subject be of type {\tt \_(\&loc=here)}.
    \item The new place-shifting control construct {\tt eval(p)e} is introduced.
  \end{itemize}
}

%\section{\FXten{} with regions}

%\section{\FXten{} with distributions}

\section{An extended example}
{\footnotesize
\begin{verbatim}
/**
   A distributed binary tree.
   @author Satish Chandra 4/6/2006
   @author vj
 */
//                             ____P0
//                            |     |
//                            |     |
//                          _P2  __P0
//                         |  | |   |
//                         |  | |   |
//                        P3 P2 P1 P0
//                         *  *  *  *
// Right child is always on the same place as its parent;
// left child is at a different place at the top few levels of the tree,
// but at the same place as its parent at the lower levels.

class Tree(localLeft: boolean,
           left: nullable Tree(& localLeft => loc=here),
           right: nullable Tree(& loc=here),
           next: nullable Tree) extends Object {
    def postOrder:Tree = {
        val result:Tree = this;
        if (right != null) {
            val result:Tree = right.postOrder();
            right.next = this;
            if (left != null) return left.postOrder(tt);
        } else if (left != null) return left.postOrder(tt);
        this
    }
    def postOrder(rest: Tree):Tree = {
        this.next = rest;
        postOrder
    }
    def sum:int = size + (right==null => 0 : right.sum()) + (left==null => 0 : left.sum)
}
value TreeMaker {
    // Create a binary tree on span places.
    def build(count:int, span:int): nullable Tree(& localLeft==(span/2==0)) = {
        if (count == 0) return null;
        {val ll:boolean = (span/2==0);
         new Tree(ll,  eval(ll => here : place.places(here.id+span/2)){build(count/2, span/2)},
           build(count/2, span/2),count)}
    }
}
\end{verbatim}}

\subsection{Places}
{\footnotesize
\begin{verbatim}
/**

 * This class implements the notion of places in X10. The maximum
 * number of places is determined by a configuration parameter
 * (MAX_PLACES). Each place is indexed by a nat, from 0 to MAX_PLACES;
 * thus there are MAX_PLACES+1 places. This ensures that there is
 * always at least 1 place, the 0'th place.

 * We use a dependent parameter to ensure that the compiler can track
 * indices for places.
 *
 * Note that place(i), for i <= MAX_PLACES, can now be used as a non-empty type.
 * Thus it is possible to run an async at another place, without using arays---
 * just use async(place(i)) {...} for an appropriate i.

 * @author Christoph von Praun
 * @author vj
 */

package x10.lang;

import x10.util.List;
import x10.util.Set;

public value class place (nat i : i <= MAX_PLACES){

    /** The number of places in this run of the system. Set on
     * initialization, through the command line/init parameters file.
     */
    config nat MAX_PLACES;

    // Create this array at the very beginning.
    private constant place value [] myPlaces = new place[MAX_PLACES+1] fun place (int i) {
	return new place( i )(); };

    /** The last place in this program execution.
     */
    public static final place LAST_PLACE = myPlaces[MAX_PLACES];

    /** The first place in this program execution.
     */
    public static final place FIRST_PLACE = myPlaces[0];
    public static final Set<place> places = makeSet( MAX_PLACES );

    /** Returns the set of places from first place to last place.
     */
    public static Set<place> makeSet( nat lastPlace ) {
	Set<place> result = new Set<place>();
	for ( int i : 0 .. lastPlace ) {
	    result.add( myPlaces[i] );
	}
	return result;
    }

    /**  Return the current place for this activity.
     */
    public static place here() {
	return activity.currentActivity().place();
    }

    /** Returns the next place, using modular arithmetic. Thus the
     * next place for the last place is the first place.
     */
    public place(i+1 % MAX_PLACES) next()  { return next( 1 ); }

    /** Returns the previous place, using modular arithmetic. Thus the
     * previous place for the first place is the last place.
     */
    public place(i-1 % MAX_PLACES) prev()  { return next( -1 ); }

    /** Returns the k'th next place, using modular arithmetic. k may
     * be negative.
     */
    public place(i+k % MAX_PLACES) next( int k ) {
	return places[ (i + k) % MAX_PLACES];
    }

    /**  Is this the first place?
     */
    public boolean isFirst() { return i==0; }

    /** Is this the last place?
     */
    public boolean isLast() { return i==MAX_PLACES; }
}
\end{verbatim}}
\subsection{$k$-dimensional regions}
{\footnotesize
\begin{verbatim}
package x10.lang;

/** A region represents a k-dimensional space of points. A region is a
 * dependent class, with the value parameter specifying the dimension
 * of the region.
 * @author vj
 * @date 12/24/2004
 */

public final value class region( int dimension : dimension >= 0 )  {

    /** Construct a 1-dimensional region, if low <= high. Otherwise
     * through a MalformedRegionException.
     */
    extern public region (: dimension==1) (int low, int high)
        throws MalformedRegionException;

    /** Construct a region, using the list of region(1)'s passed as
     * arguments to the constructor.
     */
    extern public region( List(dimension)<region(1)> regions );

    /** Throws IndexOutOfBoundException if i > dimension. Returns the
        region(1) associated with the i'th dimension of this otherwise.
     */
    extern public region(1) dimension( int i )
        throws IndexOutOfBoundException;


    /** Returns true iff the region contains every point between two
     * points in the region.
     */
    extern public boolean isConvex();

    /** Return the low bound for a 1-dimensional region.
     */
    extern public (:dimension=1) int low();

    /** Return the high bound for a 1-dimensional region.
     */
    extern public (:dimension=1) int high();

    /** Return the next element for a 1-dimensional region, if any.
     */
    extern public (:dimension=1) int next( int current )
        throws IndexOutOfBoundException;

    extern public region(dimension) union( region(dimension) r);
    extern public region(dimension) intersection( region(dimension) r);
    extern public region(dimension) difference( region(dimension) r);
    extern public region(dimension) convexHull();

    /**
       Returns true iff this is a superset of r.
     */
    extern public boolean contains( region(dimension) r);
    /**
       Returns true iff this is disjoint from r.
     */
    extern public boolean disjoint( region(dimension) r);

    /** Returns true iff the set of points in r and this are equal.
     */
    public boolean equal( region(dimension) r) {
        return this.contains(r) && r.contains(this);
    }

    // Static methods follow.

    public static region(2) upperTriangular(int size) {
        return upperTriangular(2)( size );
    }
    public static region(2) lowerTriangular(int size) {
        return lowerTriangular(2)( size );
    }
    public static region(2) banded(int size, int width) {
        return banded(2)( size );
    }

    /** Return an \code{upperTriangular} region for a dim-dimensional
     * space of size \code{size} in each dimension.
     */
    extern public static (int dim) region(dim) upperTriangular(int size);

    /** Return a lowerTriangular region for a dim-dimensional space of
     * size \code{size} in each dimension.
     */
    extern public static (int dim) region(dim) lowerTriangular(int size);

    /** Return a banded region of width {\code width} for a
     * dim-dimensional space of size {\code size} in each dimension.
     */
    extern public static (int dim) region(dim) banded(int size, int width);


}

\end{verbatim}}

\subsection{Point}
{\footnotesize
\begin{verbatim}
package x10.lang;

public final class point( region region ) {
    parameter int dimension = region.dimension;
    // an array of the given size.
    int[dimension] val;

    /** Create a point with the given values in each dimension.
     */
    public point( int[dimension] val ) {
        this.val = val;
    }

    /** Return the value of this point on the i'th dimension.
     */
    public int valAt( int i) throws IndexOutOfBoundException {
        if (i < 1 || i > dimension) throw new IndexOutOfBoundException();
        return val[i];
    }

    /** Return the next point in the given region on this given
     * dimension, if any.
     */
    public void inc( int i )
        throws IndexOutOfBoundException, MalformedRegionException {
        int val = valAt(i);
        val[i] = region.dimension(i).next( val );
    }

    /** Return true iff the point is on the upper boundary of the i'th
     * dimension.
     */
    public boolean onUpperBoundary(int i)
        throws IndexOutOfBoundException {
        int val = valAt(i);
        return val == region.dimension(i).high();
    }

    /** Return true iff the point is on the lower boundary of the i'th
     * dimension.
     */
    public boolean onLowerBoundary(int i)
        throws IndexOutOfBoundException {
        int val = valAt(i);
        return val == region.dimension(i).low();
    }
}
\end{verbatim}}

\subsection{Distribution}
{\footnotesize
\begin{verbatim}
package x10.lang;

/** A distribution is a mapping from a given region to a set of
 * places. It takes as parameter the region over which the mapping is
 * defined. The dimensionality of the distribution is the same as the
 * dimensionality of the underlying region.

   @author vj
   @date 12/24/2004
 */

public final value class distribution( region region ) {
    /** The parameter dimension may be used in constructing types derived
     * from the class distribution. For instance,
     * distribution(dimension=k) is the type of all k-dimensional
     * distributions.
     */
    parameter int dimension = region.dimension;

    /** places is the range of the distribution. Guranteed that if a
     * place P is in this set then for some point p in region,
     * this.valueAt(p)==P.
     */
    public final Set<place> places; // consider making this a parameter?

    /** Returns the place to which the point p in region is mapped.
     */
    extern public place valueAt(point(region) p);

    /** Returns the region mapped by this distribution to the place P.
        The value returned is a subset of this.region.
     */
    extern public region(dimension) restriction( place P );

    /** Returns the distribution obtained by range-restricting this to Ps.
        The region of the distribution returned is contained in this.region.
     */
    extern public distribution(:this.region.contains(region))
        restriction( Set<place> Ps );

    /** Returns a new distribution obtained by restricting this to the
     * domain region.intersection(R), where parameter R is a region
     * with the same dimension.
     */
    extern public (region(dimension) R) distribution(region.intersection(R))
        restriction();

    /** Returns the restriction of this to the domain region.difference(R),
        where parameter R is a region with the same dimension.
     */
    extern public (region(dimension) R) distribution(region.difference(R))
        difference();

    /** Takes as parameter a distribution D defined over a region
        disjoint from this. Returns a distribution defined over a
        region which is the union of this.region and D.region.
        This distribution must assume the value of D over D.region
        and this over this.region.

        @seealso distribution.asymmetricUnion.
     */
    extern public (distribution(:region.disjoint(this.region) &&
                                dimension=this.dimension) D)
        distribution(region.union(D.region)) union();

    /** Returns a distribution defined on region.union(R): it takes on
        this.valueAt(p) for all points p in region, and D.valueAt(p) for all
        points in R.difference(region).
     */
    extern public (region(dimension) R) distribution(region.union(R))
        asymmetricUnion( distribution(R) D);

    /** Return a distribution on region.setMinus(R) which takes on the
     * same value at each point in its domain as this. R is passed as
     * a parameter; this allows the type of the return value to be
     * parametric in R.
     */
    extern public (region(dimension) R) distribution(region.setMinus(R))
        setMinus();

    /** Return true iff the given distribution D, which must be over a
     * region of the same dimension as this, is defined over a subset
     * of this.region and agrees with it at each point.
     */
    extern public (region(dimension) r)
        boolean subDistribution( distribution(r) D);

    /** Returns true iff this and d map each point in their common
     * domain to the same place.
     */
    public boolean equal( distribution( region ) d ) {
        return this.subDistribution(region)(d)
            && d.subDistribution(region)(this);
    }

    /** Returns the unique 1-dimensional distribution U over the region 1..k,
     * (where k is the cardinality of Q) which maps the point [i] to the
     * i'th element in Q in canonical place-order.
     */
    extern public static distribution(:dimension=1) unique( Set<place> Q );

    /** Returns the constant distribution which maps every point in its
        region to the given place P.
    */
    extern public static (region R) distribution(R) constant( place P );

    /** Returns the block distribution over the given region, and over
     * place.MAX_PLACES places.
     */
    public static (region R) distribution(R) block() {
        return this.block(R)(place.places);
    }

    /** Returns the block distribution over the given region and the
     * given set of places. Chunks of the region are distributed over
     * s, in canonical order.
     */
    extern public static (region R) distribution(R) block( Set<place> s);


    /** Returns the cyclic distribution over the given region, and over
     * all places.
     */
    public static (region R) distribution(R) cyclic() {
        return this.cyclic(R)(place.places);
    }

    extern public static (region R) distribution(R) cyclic( Set<place> s);

    /** Returns the block-cyclic distribution over the given region, and over
     * place.MAX_PLACES places. Exception thrown if blockSize < 1.
     */
    extern public static (region R)
        distribution(R) blockCyclic( int blockSize)
        throws MalformedRegionException;

    /** Returns a distribution which assigns a random place in the
     * given set of places to each point in the region.
     */
    extern public static (region R) distribution(R) random();

    /** Returns a distribution which assigns some arbitrary place in
     * the given set of places to each point in the region. There are
     * no guarantees on this assignment, e.g. all points may be
     * assigned to the same place.
     */
    extern public static (region R) distribution(R) arbitrary();

}
\end{verbatim}}
\subsection{Arrays}
Finally we can now define arrays. An array is built over a
distribution and a base type.

{\footnotesize
\begin{verbatim}
package x10.lang;

/** The class of all  multidimensional, distributed arrays in X10.

    <p> I dont yet know how to handle B@current base type for the
    array.

 * @author vj 12/24/2004
 */

public final value class array ( distribution dist )<B@P> {
    parameter int dimension = dist.dimension;
    parameter region(dimension) region = dist.region;

    /** Return an array initialized with the given function which
        maps each point in region to a value in B.
     */
    extern public array( Fun<point(region),B@P> init);

    /** Return the value of the array at the given point in the
     * region.
     */
    extern public B@P valueAt(point(region) p);

    /** Return the value obtained by reducing the given array with the
        function fun, which is assumed to be associative and
        commutative. unit should satisfy fun(unit,x)=x=fun(x,unit).
     */
    extern public B reduce(Fun<B@?,Fun<B@?,B@?>> fun, B@? unit);


    /** Return an array of B with the same distribution as this, by
        scanning this with the function fun, and unit unit.
     */
    extern public array(dist)<B> scan(Fun<B@?,Fun<B@?,B@?>> fun, B@? unit);

    /** Return an array of B@P defined on the intersection of the
        region underlying the array and the parameter region R.
     */
    extern public (region(dimension) R)
        array(dist.restriction(R)())<B@P>  restriction();

    /** Return an array of B@P defined on the intersection of
        the region underlying this and the parametric distribution.
     */
    public  (distribution(:dimension=this.dimension) D)
        array(dist.restriction(D.region)())<B@P> restriction();

    /** Take as parameter a distribution D of the same dimension as *
     * this, and defined over a disjoint region. Take as argument an *
     * array other over D. Return an array whose distribution is the
     * union of this and D and which takes on the value
     * this.atValue(p) for p in this.region and other.atValue(p) for p
     * in other.region.
     */
    extern public (distribution(:region.disjoint(this.region) &&
                                dimension=this.dimension) D)
        array(dist.union(D))<B@P> compose( array(D)<B@P> other);

    /** Return the array obtained by overlaying this array on top of
        other. The method takes as parameter a distribution D over the
        same dimension. It returns an array over the distribution
        dist.asymmetricUnion(D).
     */
    extern public (distribution(:dimension=this.dimension) D)
        array(dist.asymmetricUnion(D))<B@P> overlay( array(D)<B@P> other);

    extern public array<B> overlay(array<B> other);

    /** Assume given an array a over distribution dist, but with
     * basetype C@P. Assume given a function f: B@P -> C@P -> D@P.
     * Return an array with distribution dist over the type D@P
     * containing fun(this.atValue(p),a.atValue(p)) for each p in
     * dist.region.
     */
    extern public <C@P, D>
        array(dist)<D@P> lift(Fun<B@P, Fun<C@P, D@P>> fun, array(dist)<C@P> a);

    /**  Return an array of B with distribution d initialized
         with the value b at every point in d.
     */
    extern public static (distribution D) <B@P> array(D)<B@P> constant(B@? b);

}
\end{verbatim}}

\end{document}

\begin{example}
 The code for {\tt List} translates as given in Table~\ref{List-translation}.
\end{example}

\begin{table}
{\footnotesize
\begin{verbatim}
  public value class List <Node> {
    public final nat n;   // is a parameter
    nullable Node node = null;
    nullable List<Node> rest = null;  // All assignments must check n = this.n-1.

    /** Returns the empty list. Defined only when the parameter n
        has the value 0. Invocation: new List(0)<Node>().
     */
    public List ( final nat n ) {
      assume n==0;
      this.n = n;
    }

    /** Returns a list of length 1 containing the given node.
        Invocation: new List(1)<Node>( node ).
     */
    public List ( final nat n, Node node ) {
      assume n==1;                         // From the constructor precondition.
      assert 0==0 : "DependentTypeError"; // For the constructor call.
      assert n>=1 : "DependentTypeError"; // For the this call.
      this(n, node, new List<Node>(0));
    }

    public List ( final nat n, Node node, List<Node> rest ) {
      assume n>=1;                               // From the constructor precondition
      assume rest.n==n-1 : "DependentTypeError"; // From the argument type.
      this.n = n;
      this.node = node;
      assert rest.n==n-1 : "DependentTypeError"; // For the field assignment.
      this.rest = rest;
    }

    public  List<Node> append( List<Node> arg ) {
      if (n == 0) {
          final List<Node> result = arg;
          assert n+arg.n == result.n : "DependentTypeError"; // For the return value
          return result;
      } else {
          assume rest.n == n-1;
          final List<Node> argval = rest.append(arg);
          assume argval.n == rest.n+arg.n;
          assert n+arg.n-1== argval.n : "DependentTypeError"; // For the constructor call.
          final List<Node> result = new List<Node>(n+arg.n, node, argval);
          assume result.n == n+arg.n;
          assert n+arg.n == result.n : "DependentTypeError"; // For the return value
          return result;
      }
    }

\end{verbatim}}
\caption{Translation of {\tt List} (contd in Table~\ref{List-translation-2}).}\label{List-translation}
\end{table}
\begin{table}
{\footnotesize
\begin{verbatim}
    public  List<Node> rev() {
      final List<Node> arg = new List<Node>(0);
      assume arg.n = 0;                           // From the constructor call.
      final List<Node> result = rev( arg );
      assume result.n == n+arg.n;                  // From the method signature
      assert n == result.n : "DependentTypeError"; // For the return value.
      return result;
    }

    public  List(n+arg.n)<Node> rev( final List<Node> arg) {
      if (n==0) {
         assert n+arg.n == arg.n : "DependentTypeError"; // For the return value.
         return arg;
      } else {
        assert 1+arg.n-1=arg.n : "DependentTypeError"; // For the argument to the constructor
        final List<Node> arg2 = new List<Node>(1+arg.n,node, arg));
        assume arg2.n==1+arg.n;                      // From the constructor invocation
        final List<Node> restval = rest;             // Read from a mutable field of parametric type
        assume restval.n == n-1;                     // From the field read.
        final List(restval.n+arg2.n)<Node> result = restval.rev( arg2 );
        assume result.n=restval.n+arg2.n
        assert n+arg.n == result.n                   // For the return value
        return result;
    }

    /** Return a list of compile-time unknown length, obtained by filtering
        this with f. */
    public List<Node> filter(fun<Node, boolean> f) {
         if (n==0) return this;
         if (f(node)) {
           final List<Node> l = rest.filter(f);
           assert l.n+1-1==l.n : "DependentTypeError"; // For the constructor call
           return new List<Node>(l.n+1,node, l);
         } else {
           return rest.filter(f);
         }
    }

    /** Return a list of m numbers from o..m-1. */
    public static  List<nat> gen( final nat m ) {
         assert 0 <= m : "DependentTypeError";        // Precondition for method call.
         final List<nat> result = gen(0,m);
         assume result.n=m-0 : "DependentTypeError";  // From the method signature
         assert m == result.n : "DependentTypeError"; // For the return value
         return result;
    }

    /** Return a list of (m-i) elements, from i to m-1. */
    public static List<nat> gen(final nat i, final nat m) {
      assume i <= m;                                   // Method precondition.
      if (i==m) {
        assert m-i == 0 : "DependentTypeError";        // For the constructor call
        final List result = new List<nat>(m-i);
        assume result.n == 0;                          // From the constructor call.
        assert m-i == result.n : "DependentTypeError"; // For the return value.
        return result;
      } else {
        assert i+1 <= m : "DependentTypeError";        // For the method call.
        final List<nat> arg = gen(i+1,m);
        assume arg.n = m-(i+1);                        // From the method call.
        assert m-i-1 = arg.n;                          // For the constructor invocation.
        final List result = new List<nat>(m-i, i, arg);
        assume result.n = m-i;                         // From the constructor invocation.
        assert m-i == result.n : "DependentTypeError"; // For the return value
        return result;
    }
  }
\end{verbatim}}
\caption{Translation of {\tt List} (continued).}\label{List-translation-2}
\end{table}

\section{Type-checking dependent classes}

Each programming language---such as \Xten{}---will specify the base
underlying classes (and the operations on them) which can occur as
types in parameter lists. For instance, in the code for {\tt List}
above, the only type that appears in parameter lists is {\tt int}, and
the only operations on {\tt int} are addition, subtraction, {\tt >=},
{\tt ==}, and the only constants are {\tt 0} and {\tt 1}.  (This
language falls within Presburger arithmetic, a decidable fragment of
arithmetic.)  The compiler must come equipped with a constraint solver
(decision procedure) that can answer questions of the form: does one
constraint entail another?  Constraints are atomic formulas built up
from these operations, using variables. For instance, the compiler
must answer each one of:
{\footnotesize
\begin{verbatim}
  n >= 2 |- n-1 >= 0
  n >= 0, m >= 0 |- m+n >= 0
\end{verbatim}}

Ultimately, the only variables that will occur in constraints are
those that correspond to {\tt config} parameters and those that are
defined by implicit parameter definitions. We need to establish that
the verification of any class will generate only a finite number of
constraints, hence only a finite constraint problem for the constraint
solver.

Second, it should be possible for instances of user-defined classes
(and operations on them) to occur as type parameters. For the compiler
to check conditions involving such values, it is necessary that the
underlying constraint solver be extended.

There are two general ways in which the constraint solver may be
extended.  Both require that the programmer single out some classes
and methods on those classes as {\em pure}. (We shall think of
constants as corresponding to zero-ary methods.) Only instances of
pure classes and expressions involving pure methods on these instances
are allowed in parameter expressions.

How shall constraints be generated for such pure methods? First, the
programmer may explicitly supply with each pure method {\tt T m(T1 x1,
..., Tn xn)} a constraint on {\tt n+2} variables in the constraint
system of the underlying solver that is entailed by {\tt y =
o.m(x1,..., xn)}. Whenever the compiler has to perform reasoning on an
expression involving this method invocation, it uses the constraint
supplied by the programmer. A second more ambitious possibility is
that a symbolic evaluator of the language may be run on the body of
the method to automatically generate the corresponding constraint.

Finally an additional possibility is that the constraint solver itself
be made extensible. In this case, when a user writes a class which is
intended to be used in specifying parameters, he also supplies an
additional program which is used to extend the underlying constraint
solver used by the compiler. This program adds more primitive
constraints and knows how to perform reasoning using these
constraints. This is how I expect we will initially implement the
\Xten{} language. As language designers and implementers we will
provide constraint solvers for finite functions and {\tt Herbrand}
terms on top of arithmetic.



\end{document}
