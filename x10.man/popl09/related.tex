Constraint-based type systems, dependent types, and generic types
have been well-studied in the literature.

\paragraph{Constraint-based type systems.}

The use of constraints for type inference and subtyping has a history
going back to Mitchell~\cite{mitchell84} and by
Reynolds~\cite{reynolds85}.  These and subsequent systems are based on
constraints over types, but not over values.  Trifonov and
Smith~\cite{trifonov96} proposed a type system in which types are
refined using subtyping constraints.
Pottier~\cite{pottier96simplifying} presents a constraint-based type
system for an ML-like language with subtyping.  These developments
lead to \hmx~\cite{sulzmann97type}, a constraint-based framework for
Hindley--Milner-style type systems.  The framework is parametrized on
the specific constraint system $X$; instantiating $X$ yields
extensions of the HM type system.  Constraints in \hmx{} are over
types, not values. The \hmx{} approach is an important precursor to
our constrained types approach. The principal difference is that
\hmx{} applies to functional languages and does not integrate
dependent types.

%
Sulzmann and Stuckey~\cite{sulzmann-hmx-clpx} showed that the
type inference algorithm for \hmx can be encoded as a
constraint logic program parametrized by the constraint system
$X$. This is very much in spirit with our approach.
Constrained types open the door to {\em user-defined}
predicates and functions, effectively permitting the user to enrich
$\cal C$ (hence the power of the compile-time type-checker)
with application-specific constraints using a constraint
programming language such as CLP($\cal C$) \cite{clp} or the richer
RCC($\cal C$) \cite{DBLP:conf/fsttcs/JagadeesanNS05}.

\paragraph{Dependent types.}

Dependent type
systems~\cite{xi99dependent,calc-constructions,epigram,cayenne}
parametrize types on values.  Refinement type
systems~\cite{refinement-types,conditional-types,jones94,sized-types,flanagan-popl06,flanagan-fool06,liquid-types},
introduced by Freeman and Pfenning~\cite{refinement-types}, are dependent type
systems that extend a base type system through constraints on values.  These
systems do not treat value and type constraints uniformly.

Our work is closely related to DML, \cite{xi99dependent}, an
extension of ML with dependent types. DML is also built
parametrically on a constraint solver. Types are refinement types;
they do not affect the operational semantics and erasing the
constraints yields a legal DML program.  This differs from generic constrained
types, where erasure of subtyping constraints can prevent the program from
type-checking.
DML does not permit any run-time checking of constraints
(dynamic casts).

The most obvious distinction between DML and constrained types
lies in the target
domain: DML is designed for functional programming
whereas constrained types are designed for imperative, concurrent
object-oriented languages. 
But there are several other
crucial differences as well.

DML achieves its separation between compile-time and run-time processing
by not permitting program
variables to be used in types. Instead, a parallel set of (universally
or existentially quantified) ``index'' variables are
introduced.
%
Second, DML permits only variables of basic index sorts known to
the constraint solver (e.g., \Xcd{bool}, \Xcd{int}, \Xcd{nat}) to
occur in types. In contrast, constrained types permit program
variables at any type to occur in constrained types. As with DML
only operations specified by the constraint system are permitted in
types. However, these operations always include field selection and
equality on object references.  Note that DML-style constraints are easily
encoded in constrained types.

% {\em Conditional
% types}~\cite{conditional-types} extend refinement types to
% encode control-flow information in the types.
% %
% Jones introduced {\em qualified types}, which permit
% types to be constrained by a finite set of
% predicates~\cite{jones94}.
% %
% {\em Sized types}~\cite{sized-types}
% annotate types with the sizes of recursive data structures.
% Sizes are linear functions of size variables.
% Size inference is performed using a constraint solver for
% Presburger arithmetic~\cite{omega}.
% % constraints on types, support primitive recursion only

% Index objects must be pure.
% Singleton types int(n).
% ML$^{\Pi}_0$:
% Refinement of the ML type system: does not affect the
% operational semantics.  Can erase to ML$_0$.

% Jay and Sekanina 1996: array bounds checking based on shape
% types.

% Ada dependent types.
% Ada has constrained array definitions.  A constraint
% \cite{ada-ref-man}.  Not clear if they're dependent.  Are
% there other dependent types?  Generics are dependent?

        % Used for array bounds by Morrisett et al (I think--need
        % to find paper)

% Singleton types~\cite{aspinall-singletons}.

Logically qualified types, or liquid types~\cite{liquid-types},
permit types in a base Hindley--Milner-style type system to be refined with
conjunctions of logical qualifiers.  The subtyping relation is similar to
\Xten{}'s, that is, two liquid types are in the subtyping relation if their base
types are and if one type's qualifier implies the other's.
The Hindley--Milner type
inference algorithm is used to infer base types; these types are used as templates for inference of the liquid types.
The types of certain expressions are over-approximated to ensure inference
is decidable.
To improve precision of the inference algorithm, and hence
to reduce the annotation burden on the programmer, 
the type system is path sensitive.

Hybrid type-checking~\cite{flanagan-popl06,flanagan-fool06}
introduced another refinement type system.
While typing is undecidable, dynamic checks are inserted into
the program when necessary if the type-checker (which
includes a constraint solver) cannot determine
type safety statically.
In \FXG{}, dynamic type checks, including tests of dependent
constraints, are inserted only at explicit casts or
\Xcd{instanceof} expressions; constraint solving is performed at compile time.

% Where clauses for F-bounded polymorphism~\cite{where-clauses}
% Bounded quantification: Cardelli and Wegner.  Bound T with T'
% In F-bounded polymorphism~\cite{f-bounds}, type variables are bounded by a function of 
% the type variable. 
% Not dependent types.

Concoqtion~\cite{concoqtion} extends types in OCaml~\cite{ocaml}
with constraints written as Coq~\cite{coq} rules.
While the types are expressive, supporting the full generality
of the Coq language, proofs must be
provided to satisfy the type checker.
\Xten{} supports only constraints that can be checked by a
constraint solver during compilation.
Concoqtion encodes OCaml types and value to allow reasoning in
the Coq formulae; however, there is an impedance mismatch
caused by the differing syntax, representation, and behavior
of OCaml versus Coq.

\eat{
Cayenne~\cite{cayenne} is a Haskell-like language with fully dependent types.
There is no distinction between static and dynamic types.
Type-checking is undecidable.
There is no notion of datatype refinement as in DML.

Epigram~\cite{epigram,epigram-matter}
is a dependently typed functional programming language based on
a type theory with inductive families.
Epigram does not have a phase distinction between values and
types.
}

\eat{
$\lambda^{\sf Con}$ is a lambda calculus with assertions.
Findler, Felleisen, Contracts for higher-order functions (ICFP02)

  example: int[> 9]

contracts are either simple predicates or function contracts.
defined by (define/contract ...)

enforced at run-time.
}

% Jif~\cite{jif,jflow} is an extension of Java in which
% types are labeled with security policies enforced by the
% compiler.

\eat{
ESC/Java~\cite{esc-java}
allow programmers to write object invariants and pre- and
post-conditions that are enforced statically
by the compiler using an automated theorem prover.
Static checking is undecidable and, in the presence of loops,
is unsound (but still useful) unless the programmer supplies loop invariants.
ESC/Java can enforce invariants on mutable state.
}

% and Spec$\sharp$~\cite{specsharp}

\eat{
Pluggable and optional type systems were proposed by
Bracha~\cite{bracha04-pluggable} and provide another means of
specifying refinement types.
Type annotations, implemented in compiler plugins, serve only to
reject programs statically that might otherwise have dynamic
type errors.
CQual~\cite{foster-popl02} extends C with user-defined type
qualifiers.  These
qualifiers may be flow-sensitive and may be inferred. 
CQual supports only a fixed set of typing rules
for all qualifiers.
In contrast, the {\em semantic type qualifiers} of
Chin, Markstrum, and Millstein~\cite{chin05-qualifiers}
allow programmers to define typing rules for qualifiers
in a meta language that allows type-checking rules to be
specified declaratively.
JavaCOP~\cite{javacop-oopsla06} is a pluggable type system
framework for Java.  Annotations are defined in a meta language
that allows type-checking rules to be specified declaratively.
JSR 308~\cite{jsr308} is a proposal for adding user-defined type qualifiers
to Java.
}

% Holt, Cordy, the Turing programming language

% Ou, Tan, Mandelbaum, Walker, Dynamic typing with dependent types
% Separate dependent and simple parts of the program.
% Statically type the dependent parts.
% Dynamic checks when passing values into dependent part.

\paragraph{Genericity.}

Genericity in object-oriented languages is usually
supported through
type parametrization.

A number of proposals 
for adding genericity to Java quickly followed
the initial release of
the language~\cite{GJ,Pizza,java-popl97,thorup97,allen03}.
GJ~\cite{GJ} implements invariant type
parameters via type erasure.
PolyJ~\cite{java-popl97} supports run-time representation of types
via adapter objects, and also permits instantiation of
parameters on primitive types and structural parameter bounds.
Viroli and Natali~\cite{reflective-generics,type-passing-generics}
also support
a run-time representation of types, using Java's reflection API.
NextGen~\cite{nextgen,allen03} was implemented using run-time 
instantiation.
\Xten{}'s generics have a hybrid implementation, adopting PolyJ's
adapter object approach for dependent types and for 
type introspection and using NextGen's run-time
instantiation approach for greater efficiency.
% MixGen~\cite{allen04} extends NextGen with mixins.

\csharp also supports generic types via run-time instantiation in the
CLR~\cite{csharp-generics}.  Type parameters may be declared
with definition-site variance tags.
Generalized type constraints were proposed for
\csharp~\cite{emir06}.  Methods can be annotated with subtyping
constraints that must be satisfied to invoke the method.
Generic \Xten{} supports these constraints, as well as constraints
on values, with method and constructor where clauses.

\eat{
\FXG{} does not support \emph{bivariance}~\cite{variant-parametric-types}; a
class \xcd"C" is bivariant in a type property \xcd"X" if \xcd"C{self.X==S}" is
a subtype of \xcd"C{self.X==T}" for any \xcd"S" and \xcd"T".  Bivariance is
useful for writing code in which the property \xcd"X" is ignored.  One can
achieve  this effect in \FXG{} simply by leaving \xcd"X" unconstrained.
}

\eat{
Parametric types with use-site variance are related to existential types:
\xcd"C<+T>" corresponds to the bounded existential $\exists\tcd{X<:T}.C<X>$;
\xcd"C<-T>" corresponds to the bounded existential $\exists\tcd{X:>T}.C<X>$;
\xcd"C<*>" corresponds to the unbounded existential $\exists\tcd{X}.C<X>$.
\FXG{} has a similar correspondence:
\xcd"C{X<:T}" corresponds to the bounded existential \xcdmath"C\{\exists\tcd{self}:C.self.X<:T\}";
\xcd"C{X:>T}" corresponds to the bounded existential \xcdmath"C\{\exists\tcd{self}.C<X\}";
\xcd"C" corresponds to the unbounded existential \xcdmath"C\{\exists\tcd{self}.C<X\}".
}

