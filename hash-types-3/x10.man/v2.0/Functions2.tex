\chapter{Functions}
\label{Functions}
\label{functions}
\index{functions}
\label{Closures}

\section{Overview}
The runtime entities in \Xten{} are of three kinds: \emph{structs},
\emph{objects}, and \emph{functions}. This section is concerned with
functions and their types -- how they are created, and what operations
can be performed on them.

Intuitively, a function is a piece of code which can be applied to a
set of arguments to produce a value. The application may not
terminate, or may terminate abruptly. Functions may throw checked and
unchecked exceptions. The body of a function may be any \Xten{}
expression: hence a function evaluation may spawn multiple activities,
read and write mutable locations, wait until memory locations contain
a desired value, and execute over multiple places. In particular,
function evaluation may be non-deterministic. When applied to the same
input twice, a function may yield two different results.

It is a limitation of \XtenCurrVer{} that functions do not support
type arguments. This limitation may be removed in future versions of
the language.

A \emph{function literal} \xcd"(x1:T1,..,xn:Tn){c}:T=>e" creates a
function of type\\ \xcd"(x1:T1,...,xn:Tn){c}=>T"
(\Sref{FunctionType}). The body \Xcd{e} of such an expression is
type-checked in an environment in which \Xcd{c} is true. At runtime,
function execution results in the evaluation of \Xcd{e} in an
environment in which each formal is bound to the given actual
parameter.

The \emph{method selector expression} \Xcd{e.m.(x1:T1,...,xn:Tn)} (\Sref{MethodSelectors})
permits the specification of the function underlying
the method \Xcd{m}, which takes arguments of type \Xcd{(x1:T1,..., xn:Tn)}.
Within this function, \Xcd{this} is bound to the result of evaluating \Xcd{e}.

Function types may be used in \Xcd{implements} clauses of class
definitions. Instances of such classes may be used as functions of the
given type.  Indeed, an object may behave like any (fixed) number of
functions, since the class it is an instance of may implement any
(fixed) number of function types.

%\section{Implementation Notes}
%\begin{itemize}
%
%\item Note that e.m.(T1,...,Tn) will evaluate e to create a
%  function. This function will be applied later to given
%  arguments. Thus this syntax can be used to evaluate the receiver of
%  a method call ahead of the actual invocation. The resulting function
%  can be used multiple times, of course.
%\end{itemize}


\section{Function Literals}
\index{literal!function}
\label{FunctionLiteral}

\Xten{} provides first-class, typed functions, including
\emph{closures}, \emph{operator functions}, and \emph{method
  selectors}.

\begin{grammar}
ClosureExpression \:
        \xcd"("
        Formals\opt
        \xcd")"
\\ &&
        Guard\opt
        ReturnType\opt
        Throws\opt
        \xcd"=>" ClosureBody \\
ClosureBody \:
        Expression \\
        \| \xcd"{" Statement\star \xcd"}" \\
        \| \xcd"{" Statement\star Expression \xcd"}" \\
\end{grammar}

Functions have zero or more formal parameters, an optional return type
and optional set of exceptions throws by the body.  The body has the
same syntax as a method body; it may be either an expression, a block
of statements, or a block terminated by an expression to return. In
particular, a value may be returned from the body of the function
using a return statement (\Sref{ReturnStatement}). The type of a
function is a function type (\Sref{FunctionType}).  In some cases the
return type \Xcd{T} is also optional and defaults to the type of the
body. If a formal \Xcd{xi} does not occur in any
\Xcd{Tj},\Xcd{c},\Xcd{T} or \Xcd{e}, the declaration \Xcd{xi:Ti} may
be replaced by just \Xcd{Ti}.

\label{ClosureGuard}

As with methods, a function may declare a guard to
constrain the actual parameters with which it may be invoked.
The guard may refer to the type parameters, formal parameters,
and any \xcd`val`s in scope at the function expression.

The body of the function is evaluated when the function is
invoked by a call expression (\Sref{Call}), not at the function's
place in the program text.

As with methods, a function with return type \xcd"Void" cannot
have a terminating expression. 
If the return type is omitted, it is inferred, as described in
\Sref{TypeInference}.
It is a static error if the return type cannot be inferred. 


\begin{example}
The following method takes a function parameter and uses it to
test each element of the list, returning the first matching
element.
\begin{xten}
def find[T](f: (T) => Boolean, xs: List[T]): T = {
  for (x: T in xs)
    if (f(x)) return x;
  null
}
\end{xten}

The method may be invoked thus:
\begin{xten}
xs: List[Int] = ...;
x: Int = find((x: Int) => x>0, xs);
\end{xten}
\end{example}

As with a normal method, the function may have a \xcd"throws"
clause. It is a static error if the body of the function throws a
checked exception that is not declared in the function's \xcd"throws"
clause.

\subsection{Outer variable access}

In a function
\xcdmath"(x$_1$: T$_1$, $\dots$, x$_n$: T$_n$){c} => { s }"
the types \xcdmath"T$_i$", the guard \xcd"c" and the body \xcd"s"
may access fields of enclosing classes and local variables and type
parameters declared in an outer scope.

Recall that languages such as \java{} require that methods may
access only those local variables declared in an enclosing scope
(``outer variables'') which are \xcd`val`. This is valuable in
preventing accidental races between multiple functions reading
and writing the same outer variable. At the same time, it is
desirable to support the following common idiom of expression:

\begin{xten}
def allPositive(c: Collection): Boolean {
  shared var result: Boolean = true;
  c.applyToAll((x: Int) => { if (x < 0) atomic {result=false;}});
  return result;
}
\end{xten}

This motivates the following rule:

\begin{staticrule*}
In an expression
\xcdmath"(x$_1$: T$_1$, $\dots$, x$_n$: T$_n$) => e",
any outer local variable accessed by \xcd"e" must be \xcd`val` or
must be declared
as \xcd"shared" (\Sref{Shared}).
\end{staticrule*}

The function body may refer to instances of enclosing classes using
the syntax \xcd"C.this", where \xcd"C" is the name of the
enclosing class.

\begin{note}
The main activity may run in parallel with any
functions it creates. Hence even the read of an outer variable by the
body of a function may result in a race condition. Since functions are
first-class, the analysis of whether a function may execute in parallel
with the activity that created it may be difficult.
\end{note}

%% vj: This should be verified.
%\begin{note}
%The rule for accessing outer variables from function bodies
%should be the same as the rule for accessing outer variables from local
%or anonymous classes.
%\end{note}

\section{Methods selectors}
\label{MethodSelectors}
\index{function!method selector}
\index{method!underlying function}

A method selector expression allows a method to be used as a
first-class function.

\begin{grammar}
MethodSelector \:
        Primary \xcd"."
        MethodName \xcd"."
                TypeParameters\opt \xcd"(" Formals\opt \xcd")" \\
      \|
        TypeName \xcd"."
        MethodName \xcd"."
                TypeParameters\opt \xcd"(" Formals\opt \xcd")" \\
\end{grammar}

The \emph{method selector expression} \Xcd{e.m.(T1,...,Tn)} is type
correct only if it is the case that the static type of \Xcd{e} is a
class or struct or interface with a method
\Xcd{m(x1:T1,...xn:Tn)\{c\}:T} defined on it (for some
\Xcd{x1,...,xn,c,T)}. At runtime the evaluation of this expression
evaluates \Xcd{e} to a value \Xcd{v} and creates a function \Xcd{f}
which, when applied to an argument list \Xcd{(a1,...,an)} (of the right
type) yields the value obtained by evaluating \Xcd{v.m(a1,...,an)}.

Thus, the method selector

\begin{xtenmath}
e.m.[X$_1$, $\dots$, X$_m$](T$_1$, $\dots$, T$_n$)
\end{xtenmath}
\noindent behaves as if it were the function
\begin{xtenmath}
((v:T)=>
  [X$_1$, $\dots$, X$_m$](x$_1$: T$_1$, $\dots$, x$_n$: T$_n$) => v.m[X$_1$, $\dots$, X$_m$](x$_1$, $\dots$, x$_n$))
(e)
\end{xtenmath}

\begin{note}
Because of overloading, a method name is not sufficient to
uniquely identify a function for a given class (in Java-like languages).
One needs the argument type information as well.
The selector syntax (dot) is used to distinguish \xcd"e.m()" (a
method invocation on \xcd"e" of method named \xcd"m" with no arguments)
from \xcd"e.m.()"
(the function bound to the method). 
\end{note}

A static method provides a binding from a name to a function that is
independent of any instance of a class; rather it is associated with the
class itself. The static function selector
\xcdmath"T.m.(T$_1$, $\dots$, T$_n$)" denotes the
function bound to the static method named \xcd"m", with argument types
\xcdmath"(T$_1$, $\dots$, T$_n$)" for the type \xcd"T". The return type
of the function is specified by the declaration of \xcd"T.m".

Users of a function type do not care whether a function was defined
directly (using the function syntax), or obtained via (static or
instance) function selectors.

\begin{note}
Design note: The function selector syntax is consistent with the
reinterpretation of the usual method invocation syntax
\xcdmath"e.m(e$_1$,..., e$_n$)"
into a function specifier, \xcd"e.m", applied to a tuple of arguments
\xcdmath"(e$_1$,..., e$_n$)". Note that the receiver is not
treated as ``an extra argument'' to the
function. That would break the above approach.
\end{note}

\section{Operator functions}
\label{OperatorFunction}
\index{function!operator}
Every operator (e.g.,
\xcd"+",
\xcd"-",
\xcd"*",
\xcd"/",
\dots) has a family of functions, one for
each type on which the operator is defined. The function can be
selected using the "." syntax:

\begin{grammar}
OperatorFunction
        \: TypeName \xcd"." Operator \xcd"(" Formals\opt \xcd")" \\
        \| TypeName \xcd"." Operator \\
\end{grammar}

If an operator has more than one arity (e.g., unary and binary
\xcd"-"), the appropriate version may be selected by giving the
formal parameter types.  The binary version is selected by
default.
For example, the following equivalences hold:

\begin{xtenmath}
String.+             $\equiv$ (x: String, y: String): String => x + y
Long.-               $\equiv$ (x: Long, y: Long): Long => x - y
Float.-(Float,Float) $\equiv$ (x: Float, y: Float): Float => x - y
Int.-(Int)           $\equiv$ (x: Int): Int => -x
Boolean.&            $\equiv$ (x: Boolean, y: Boolean): Boolean => x & y
Boolean.!            $\equiv$ (x: Boolean): Boolean => !x
Int.<(Int,Int)       $\equiv$ (x: Int, y: Int): Boolean => x < y
Dist.|(Place)        $\equiv$ (d: Dist, p: Place): Dist => d | p
\end{xtenmath}

Unary and binary promotion (\Sref{XtenPromotions}) is not performed
when invoking these
operations; instead, the operands are coerced individually via implicit
coercions (\Sref{XtenConversions}), as appropriate.

Additionally, for every expression \xcd"e" of a type \xcd"T" at which a binary
operator \xcd"OP" is defined, the expression \xcd"e.OP" or
\xcd"e.OP(T)" represents the function
defined by:

\begin{xten}
(x: T): T => { e OP x }
\end{xten}

\begin{grammar}
Primary \: Expr \xcd"." Operator \xcd"(" Formals\opt \xcd")" \\
        \| Expr \xcd"." Operator \\
\end{grammar}

%% For every expression \xcd"e" of a type \xcd"T" at which a unary
%%operator \xcd"OP" is defined, the expression \xcd"e.OP()"
%% represents the function defined by:

%% \begin{xten}
%% (): T => { OP e }
%% \end{xten}

For example,
one may write an expression that adds one to each member of a
list \xcd"xs" by:

\begin{xten}
xs.map(1.+)
\end{xten}

\section{Functions as objects of type \Xcd{Any}}
\label{FunctionAnyMethods}

\label{FunctionEquality}
\index{function!equality}
\index{equality!function}
Two functions \Xcd{f} and \Xcd{g} are equal (``\Xcd{==}'') if both are
instances of classes and the same object, or if both were obtained by
the same evaluation of a function literal.\footnote{A literal may
  occur in program text within a loop, and hence may be evaluated
  multiple times.} Further, it is guaranteed that if two functions are
equal then they refer to the same locations in the environment and
represent the ``same code'' (so their executions in an identical
environment are comparable).
\index{function!==}


Every function type implements all the methods of \Xcd{Any}.
For a value \Xcd{f} of a function type \Xcd{(x1:T1,...xn:Tn)=>T}, 
the expression \Xcd{f.equals(g)} is of type \Xcd{Boolean}.
It succeeds if and only if \Xcd{f==g} succeeds. Similarly, the 
expression \Xcd{f.hashCode()} is of type \Xcd{Int} and returns
an implementation defined hash code which is guaranteed to be the
same for two values that are \Xcd{equal}. The expression
\Xcd{f.toString()} returns an implementation-dependent string.
Two strings returned on different evaluations are \Xcd{equal} to each other. 
Similarly, \Xcd{f.typeName()}  returns an implementation-dependent string.
Two strings returned on different evaluations are \Xcd{equal} to each other. 
\index{function!equals}
\index{function!hashCode}
\index{function!toString}
\index{function!typeName}

The method \Xcd{f.home()} always returns \Xcd{here}. The call
\Xcd{f.at(p)} for \Xcd{p} a value of type \Xcd{Place} always returns
\Xcd{true}. The call 
\Xcd{f.at(o)} for \Xcd{o} a value of type \Xcd{Object} always returns
\Xcd{true}
\index{function!home}
\index{function!at(Place)}
\index{function!at(Object)}

