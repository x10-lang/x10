/*
 *
 * (C) Copyright IBM Corporation 2006
 *
 *  This file is part of X10 Test.
 *
 */
import harness.x10Test;;
import x10.array.Array;

/**
 * Jacobi iteration.
 *
 * At each step of the iteration, replace the value of a cell with
 * the average of its adjacent cells in the (i,j) dimensions.
 * Compute the error at each iteration as the sum of the changes
 * in value across the whole array. Continue the iteration until
 * the error falls below a given bound.
 *
 * @author vj
 * @author cvp
 * @author kemal
 */
public class JacobiExtern extends x10Test {

	const N: int = 6;
	const epsilon: double = 0.002;
	const epsilon2: double = 0.000000001;
	val R: region = [0..(N+1), 0..(N+1)];
	val R_inner: region = [1..N, 1..N];
	val D: dist = distmakeBlock(R);
	val D_inner: dist = D.restriction(R_inner);
	val D_Boundary: dist = D.difference(D_inner.region);
	const EXPECTED_ITERS: int = 97;
	const EXPECTED_ERR: double = 0.0018673382039402497;

	native static def computeError(var dbl: Array[double], var temp: Array[double]): double;

	static { System.loadLibrary("JacobiExtern"); }

	public def run(): boolean = {

		var iters: int = 0;

		final val a: Array[double] = new Array[double](D);
		finish ateach (val p: point in D_inner) { a(p) = (double)(p(0)-1)*N + (p(1)-1); }
		finish ateach (val p: point in D_Boundary) { a(p) = (N-1)/2; }
		var err: doublevar x10err: double;
		var x: Array[double] = a;
		while (true) {
			final val b: Array[double] = x;
			final val temp: Array[double] = new Array[double](D_inner);
			finish ateach (val p: point in D_inner) {
				var i: int = p(0);
				var j: int = p(1);
				temp(p) = (read(b, i+1, j)+read(b, i-1, j)+read(b, i, j-1)+read(b, i, j+1))/4.0;
			}

			if ((err = computeError(b, temp)) < epsilon)
				break;
			x10err = (b.restriction(D_inner).sub(temp).abs().sum());
			if (x10err != err) {
				System.out.println("Inconsistent errors:"+err+" != "+x10err);
				return false;
			}
			x = x.overlay(temp);

			iters++;
		}
		System.out.println(err);
		System.out.println(iters);
		return Math.abs(err-EXPECTED_ERR)<epsilon2 && iters == EXPECTED_ITERS;
	}

	static def read(val b: Array[double], val i: int, val j: int): double = {
		return future(b.dist(i, j)) { b(i, j) }.force();
	}

	public static def main(var args: Rail[String]): void = {
		new JacobiExtern().execute();
	}
}
