<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>Method definitions</title>
</head>

<body>
 <h2><a name="tth_sEc7">
7</a>&nbsp;&nbsp;Method definitions</h2>

<div class="p"><!----></div>
 X10 permits guarded method definitions, similar to guarded
field definitions. Additionally, the parameter list for a method may
contain a .

<div class="p"><!----></div>
<em>  
<table>
<tr><td align="right">MethodDeclaration &nbsp;::=&nbsp; MethodHeader ; </td></tr>
<tr><td align="right"> |  MethodHeader = ClosureBody </td></tr>
<tr><td align="right">MethodHeader &nbsp;::=&nbsp;
  MethodModifiers<sup>?</sup>&nbsp;<tt>def</tt> Identifier TypeParameters<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right"></td><td align="center"></td><td>( 
  FormalParameterList<sup>?</sup>&nbsp;) Guard<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right"></td><td align="center"></td><td>ReturnType<sup>?</sup>&nbsp;Throws<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right"></td></tr></table>
</em>


<div class="p"><!----></div>
In the formal parameter list, variables may be declared with
"val" or "var".  If neither is specified, the variable
is "val".

<div class="p"><!----></div>
<a name="MethodGuard">
</a>The guard (specified by )
specifies a constraint "c" on the
properties of the class "C" on which the method is being defined. The
method exists only for those instances of "C" which satisfy "c".  It is
illegal for code to invoke the method on objects whose static type is
not a subtype of "C{c}".

<div class="p"><!----></div>
    The compiler checks that every method invocation
    &#246;.m(e<sub>1</sub>, ..., e<sub>n</sub>)"
    for a method is type correct. Each each argument
    &#235;<sub>i</sub>" must have a
    static type "S<sub>i</sub>" that is a subtype of the declared type
    "T<sub>i</sub>" for the ith
    argument of the method, and the conjunction of static types
    of the arguments must entail the guard in the parameter list
    of the method.

<div class="p"><!----></div>
    The compiler checks that in every method invocation
    &#246;.m(e<sub>1</sub>, ..., e<sub>n</sub>)"
    the static type of &#246;", "S", is a subtype of "C{c}", where the method
    is defined in class "C" and the guard for "m" is equivalent to
    "c".

<div class="p"><!----></div>
    Finally, if the declared return type of the method is
    "D{d}", the
    return type computed for the call is
    "D{a: S; x<sub>1</sub>: S<sub>1</sub>; ...; x<sub>n</sub>: S<sub>n</sub>; d[a/this]}",
    where &#228;" is a new
    variable that does not occur in
    "d, S, S<sub>1</sub>, ..., S<sub>n</sub>", and
    "x<sub>1</sub>, ..., x<sub>n</sub>" are the formal
    parameters of the method.


<div class="p"><!----></div>
Consider the program:
<pre>
public class List(n: Int{n&#62;=0}) { 
  protected val head{n&#62;0}: Object;
  protected val tail{n&#62;0}: List(n-1);
  public def this(o: Object, t: List): List(t.n+1) = { 
     property(t.n+1);
     head=o;
     tail=t;
  }
  public def this(): List(0) = { 
     property(0);
  }
  public def append(l: List): List{self.n==this.n+l.n} = {
      return (n==0)? l
         : new List(head, tail.append(l)); 
  }
  public def nth(k: Int{1 &lt;= k && k &lt;= n}){n &#62; 0}: Object = { 
      return k==1 ? head : tail.nth(k-1);
  }
}
</pre>

<div class="p"><!----></div>
The following code fragment
<pre>
u: List{self.n==3} = ...
t: List{self.n==x} = ...;
s: List{self.n==x+3} = t.append(u);
</pre>
 will typecheck. The type of the expression "t.append(u)" is 
<pre>
List{a: List{self.n==x}; 
     l: List{self.n==3}; self.n==a.n+l.n}  
</pre>
 which is equivalent to:
<pre>
List{self.n==x+3}
</pre>


<div class="p"><!----></div>
The method body is either an expression, a block of statements,
or a block ending with an expression.

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.1">
7.1</a>&nbsp;&nbsp;Property methods</h3>

<div class="p"><!----></div>
A method declared with the modifier "property" may be used
in constraints.  A property method declared in a class must have
a body and must not be "void".  The body of the method must
consist of only a single "return" statement or a single
expression.  It is a static error of the expression cannot be
represented in the constraint system.

<div class="p"><!----></div>
Property methods in classes are implicitly "final"; they cannot be
overridden.

<div class="p"><!----></div>
A property method definition may omit the formal parameters and
the "def" keyword.  That is, the following are equivalent:

<div class="p"><!----></div>
<pre>
property def rail(): boolean = rect && onePlace == here && zeroBased;
property rail: boolean = rect && onePlace == here && zeroBased;
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc7.2">
7.2</a>&nbsp;&nbsp;Method overloading, overriding, hiding, shadowing and obscuring</h3>
<a name="MethodOverload">
</a>

<div class="p"><!----></div>
The definitions of method overloading, overriding, hiding, shadowing
and obscuring in  X10 are the same as in  Java, modulo the following
considerations motivated by type parameters and dependent types.

<div class="p"><!----></div>
Two or more methods of a class or interface may have the same
name if they have a different number of type parameters, or
they have value parameters of different types.

<div class="p"><!----></div>
The definition of a method declaration "m<sub>1</sub>" "having the same signature
as" a method declaration "m<sub>2</sub>" involves identity of types. Two  X10 types
are defined to be identical iff they are equivalent ().
Two methods are said to have <em>the same signature</em> if (a)
they have the same number of type parameters, (b) they have the
same number of formal (value) parameters, and (c) for each formal parameter
their types are equivalent. It is a compile-time error for there
to be two methods with the same name and same signature in a class
(either defined in that class or in a superclass).

<div class="p"><!----></div>
  A class "C" may not have two declarations for a method named "m"-either
  defined at "C" or inherited:
<pre>
def m[X<sub>1</sub>, ..., X<sub>m</sub>](v<sub>1</sub>: T<sub>1</sub>{t<sub>1</sub>}, ..., v<sub>n</sub>: T<sub>n</sub>{t<sub>n</sub>}){tc}: T {...}
def m[X<sub>1</sub>, ..., X<sub>m</sub>](v<sub>1</sub>: S<sub>1</sub>{s<sub>1</sub>}, ..., v<sub>n</sub>: S<sub>n</sub>{s<sub>n</sub>{){sc}: S {...}
</pre>

if it is the case that the types "C{tc}", "T<sub>1</sub>{t<sub>1</sub>}",
..., "T<sub>n</sub>{t<sub>n</sub>}" are
equivalent to the types "C{sc}, S<sub>1</sub>{t<sub>1</sub>}, ..., T<sub>n</sub>{t<sub>n</sub>}"
respectively.


<div class="p"><!----></div>
In addition, the guard of a overriding method must be 
no stronger than the guard of the overridden method.   This
ensures that any virtual call to the method
satisfies the guard of the callee.

<div class="p"><!----></div>
  If a class "C" overrides a method of a class or interface
  "B", the guard of the method in "B" must entail
  the guard of the method in "C".


<div class="p"><!----></div>
A class "C" inherits from its direct superclass and superinterfaces all
their methods visible according to the access restriction modifiers
public/private/protected/(package) of the superclass/superinterfaces
that are not hidden or overridden. A method "M<sub>1</sub>" in a class
"C" overrides
a method "M<sub>2</sub>" in a superclass "D" if
"M<sub>1</sub>" and "M<sub>2</sub>" have the same signature.
Methods are overriden on a signature-by-signature basis.

<div class="p"><!----></div>
A method invocation &#246;.m(e<sub>1</sub>, ..., e<sub>n</sub>)"
is said to have the <em>static signature</em>
&#171;T, T<sub>1</sub>, ..., T<sub>n</sub>&#62;" where "T" is the static type of
&#246;", and
"T<sub>1</sub>",
...,
"T<sub>n</sub>"
are the static types of &#235;<sub>1</sub>", ..., &#235;<sub>n</sub>",
respectively.  As in
 Java, it must be the case that the compiler can determine a single
method defined on "T" with argument type
"T<sub>1</sub>", ... "T<sub>n</sub>"; otherwise, a
compile-time error is declared. However, unlike  Java, the  X10 type "T"
may be a dependent type "C{c}". Therefore, given a class definition for
"C" we must determine which methods of "C" are available at a type
"C{c}". But the answer to this question is clear: exactly those methods
defined on "C" are available at the type "C{c}"
whose guard "d" is implied by "c".

<div class="p"><!----></div>
  Consider the definitions:
<pre>
class Point(i: Int, j: Int) {...}
class Line(s: Point, e: Point{self != i}) {
  // m1: Both points lie in the right half of the plane
  def draw(){s.i&#62;= 0 && e.i &#62;= 0} = {...}
  // m2: Both points lie on the y-axis
  def draw(){s.i== 0 && e.i == 0} = {...}
  // m3: Both points lie in the top half of the plane
  def draw(){s.j&#62;= 0 && e.j &#62;= 0} = {...}
  // m4: The general method
  def draw() = {...}
} 
</pre> 
  Three different implementations are given for the
"draw" method, one
  for the case in which the line lies in the right half of the plane,
  one for the case that the line lies on the y-axis and the third for
  the case that the line lies in the top half of the plane.

<div class="p"><!----></div>
  Consider the invocation
<pre>
m: Line{s.i &lt; 0} = ...
m.draw();
</pre>

<div class="p"><!----></div>
  This generates a compile time error because there is no applicable
  method definition.

<div class="p"><!----></div>
  Consider the invocation

<div class="p"><!----></div>
<pre>
m: Line{s.i&#62;=0 && s.j&#62;=0 && e.i&#62;=0 && e.j&#62;=0} = ...
m.draw();
</pre>

<div class="p"><!----></div>
  This generates a compile time error because both
"m1" and "m3" are applicable.

<div class="p"><!----></div>
  Consider the invocation
<pre>
m: Line{s.i&#62;=0 && s.j&#62;=0 && e.i&#62;=0} = ...
m.draw();
</pre>
  This does not generate any compile-time error since only m1 is
  applicable. 


<div class="p"><!----></div>
In the last example, notice that at runtime "m1" will be invoked
(assuming "m" contains an instance of the "Line" class, and not some
subclass of "Line" that overrides this method). This will be the case
even if "m" satisfies at runtime the stronger conditions for "m2" (i.e.,
&#223;.i==0 </td><td width="150">
</td><td width="150">
 e.i==0"). That is, dynamic method lookup will not take into
account the  "strongest" constraint that the receiver may
satisfy, i.e.,
its "strongest constrained type". 

<div class="p"><!----></div>
  The design decision that dynamic method lookup should ignore
  dependent type information was made to keep the design and the
  implementation simple and to ensure that serious errors such as
  method invocation errors are captured at compile-time.

<div class="p"><!----></div>
  Consider the above example and the invocation
<pre>
m: Line = ...
m.draw();    
</pre>

<div class="p"><!----></div>
   Statically the compiler will not report an error because m4 is the
   only method that is applicable. However, if dynamic method lookup
   were to use constrained types then we would face the problem that if m is a
   line that lives in the upper right quadrant then both "m2"
   and "m3"
   are applicable and one does not override the other. Hence we must
   report an error dynamically.

<div class="p"><!----></div>
   As discussed above, the programmer can write code with &#239;nstanceof"
   and class casts that perform any application-appropriate
   discrimination.  


<div class="p"><!----></div>
     <h3><a name="tth_sEc7.3">
7.3</a>&nbsp;&nbsp;Method annotations</h3>

<div class="p"><!----></div>
      <h4><a name="tth_sEc7.3.1">
7.3.1</a>&nbsp;&nbsp;<tt>atomic</tt> annotation</h4>

<div class="p"><!----></div>
A method may be declared &#228;tomic".

<div class="p"><!----></div>
<em>  
<table>
<tr><td align="right">MethodModifier &nbsp;::=&nbsp; <tt>atomic</tt>  
</td></tr></table>
</em>

<div class="p"><!----></div>
Such a method is treated as if the statement in its body is wrapped 
implicitly in an &#228;tomic" statement.

<div class="p"><!----></div>
      <h4><a name="tth_sEc7.3.2">
7.3.2</a>&nbsp;&nbsp;<tt>local</tt> annotation</h4><a name="LocalAnnotation">
</a>

<div class="p"><!----></div>
A method may be declared "local".

<div class="p"><!----></div>
<em>  
<table>
<tr><td align="right">MethodModifier &nbsp;::=&nbsp; <tt>local</tt>  
</td></tr></table>
</em>


<div class="p"><!----></div>
By declaring a method "local" the programmer asserts that while
executing this method an activity will only access local memory.

<div class="p"><!----></div>
The compiler implements the following rules to guarantee this property.

<div class="p"><!----></div>
Let &#246;" be any expression occurring in the body of the
method. Assume its static datatype is "F". 

<div class="p"><!----></div>

<ul>
<li> Local methods can only be overridden by local methods.
<div class="p"><!----></div>
</li>

<li> If the body of the method contains any field access &#246;.e", then
the static placetype of &#246;" must be "here". 

<div class="p"><!----></div>
The programmer can always ensure that this condition is satisfied
(albeit at the risk of introducing a runtime exception) by replacing
each field access &#246;.e" with "(o as F!here).e".
<div class="p"><!----></div>
</li>

<li> If the body of the method contains any assignments to fields
(e.g. &#246;.e Op= t", or &#214;p o.e" or &#246;.e Op") then the
static placetype of &#246;" must be "here".

<div class="p"><!----></div>
The programmer can always ensure that this condition is satisfied by
replacing &#246;.e Op= t" by &#246;1.e Op=t" and preceding it (in the
same basic block) with the local variable declaration &#246;1: F!here = o as F!here" (for some new local variable &#246;1"). Similarly for
&#214;p o.e" and &#246;.e Op".
<div class="p"><!----></div>
</li>

<li> Recall that the static placetype of an array access &#246;(e)"
is &#246;.dist(e)". Therefore, any read/write array access
&#246;(e)" must be guarded by the condition &#246;.dist(e) == here".  (Since  &#235;" may have side-effects, the compiler must
ensure that the place check uses the value returned by the same
expression evaluation that is used to access the array element.)
<div class="p"><!----></div>
</li>

<li> If the body of the method contains any method invocation
&#246;.m(t<sub>1</sub>,...,t<sub>k</sub>)" then the method invoked must be local. Additionally,
the static place type of &#246;" must be "here". 
As above, the programmer can always ensure the second
condition is satisfied by writing such a method invocation
as "(o as F!here).m(t<sub>1</sub>,...,t<sub>k</sub>)".
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
Note that reads/writes to local variables or method parameters are
always local, hence the compiler does not have to check any extra
conditions.

<div class="p"><!----></div>
A method declared &#228;tomic" is automatically declared
to be "local".

</body>
</html>