<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
<title>Object-oriented features</title>
</head>

<body>
 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Object-oriented features</h2>

<div class="p"><!----></div>
The sequential core of X10 is a <em>container-based</em> object-oriented language
similar to Java or Scala.
Programmers write X10 code by defining containers for behavior called
<em>interfaces</em>
(&#167;),
<em>classes</em>
(&#167;) and
<em>structs</em>
(&#167;).

<div class="p"><!----></div>

<b>Interfaces&nbsp;&nbsp;</b>

<div class="p"><!----></div>
An X10 interface specifies a collection of abstract methods (a
<em>signature</em>). Interfaces may extend one or more interfaces, can be
extended by other interfaces and implemented by classes and structs.
To implement an interface a class or struct must declare that it
implements that interface, and provide definitions for all the methods
defined in that interface.

<div class="p"><!----></div>

<b>Classes and Structs&nbsp;&nbsp;</b>

<div class="p"><!----></div>
There are two kinds of concrete containers: <em>classes</em>
(&#167;) and <em>structs</em>
(&#167;). Containers may have type parameters, have fields,
methods and inner containing types and can implement one or more
interfaces. A method or an immutable field of a
container may be marked <b>global</b>.  For a given entity (instance of
a container), global fields and methods may be accessed from any
place. Otherwise they may be accessed only in the place in which they
were created.

<div class="p"><!----></div>
Classes are organized in a single-inheritance tree. Classes may have
mutable fields.  Instances of classes with mutable fields may not be
freely copied from place to place. Non-global methods may be invoked
on such an object only by an activity in the same place as the object.
The <b>null</b> reference is a value of any reference type.

<div class="p"><!----></div>
In contrast, structs are "headerless" objects that can be onlined in
the containing object.  Structs cannot inherit code - hence a
variable of a struct type contains an instance of precisely that
struct. Structs may not be recursive, i.e. there can be no cycles in
the graph whose nodes are structs and edges s &#8594; t reflect
that struct s has a field of (struct) type t. Thus a struct
instance may be represented with exactly as much space as necessary to
store the fields of that struct (modulo alignment considerations). Structs
can be copied freely. 

<div class="p"><!----></div>
X10 has no primitive classes. However, the standard library
<b>x10.lang</b> supplies structs <b>Boolean</b>, <b>Byte</b>,
<b>Short</b>, <b>Char</b>, <b>Int</b>, <b>Long</b>, <b>Float</b>,
<b>Double</b>, <b>Complex</b> and <b>String</b>. The user may defined
additional arithmetic structs using the facilities of the
language.

<div class="p"><!----></div>

<b>Functions.&nbsp;&nbsp;</b>
X10 provides functions (&#167;) to allow code to be used
as values.  The body of a function may capture variables in the
function's environment (technically, then, functions are <em>
  closures</em>).  Functions are used implicitly in asyncs, futures, and
array initializers.
For example, the following method uses a function to increment
elements of an array.
<pre>
def incr(A: Array[Int]): Array[Int] {
    val f = (x: Int) =&#62; x+1; // e.g., f(1) == 2
    return A.lift(f);
}
</pre>

<div class="p"><!----></div>

<b>Dependent types&nbsp;&nbsp;</b>
Classes and interfaces may declare <em>properties</em>: immutable object members bound at object construction.
Types may be defined by constraining a
class or interface's properties.
Properties enable the definition of <em>dependent types</em>.

<div class="p"><!----></div>
For example, the following code declares a class for a two-dimensional 
<b>Point</b> class with an <b>add</b> method.
<pre>
struct Point(x: Int, y: Int) {
    def add(p: Point) = Point(x+p.x,y+p.y); 
}
</pre>
The class has integer value properties <b>x</b> and <b>y</b>.
The <b>add</b> method creates and returns a new point by
element-wise addition.
The dependent type <b>Point{x==0}</b> is the type of all points 
with <b>x</b> set to <b>0</b>; that is, all points along the y-axis.

<div class="p"><!----></div>

<b>Generic types&nbsp;&nbsp;</b>

<div class="p"><!----></div>
Classes and interfaces may have type parameters, permitting the definition of
<em>generic types</em>.  Type parameters may be instantiated by any type - a
container type or a function type. 

<div class="p"><!----></div>
For example,
the following code declares a simple <b>List</b> class with a
type parameter <b>T</b>.

<div class="p"><!----></div>
<pre>
class List[T] {
    var head: T;
    var tail: List[T];
    def this(h: T, t: List[T]) { head = h; tail = t; }
    def append(x: T) {
        if (this.tail == null)
            this.tail = new List(x, null);
        else
            this.tail.add(x);
    }
}
</pre>
The constructor (<b>def this</b>) initializes the fields of the new object.
The <b>add</b> method appends an element to the list.
<b>List</b> is a generic type.  When  instances of <b>List</b> are
allocated, the type parameter <b>T</b> must be bound to a concrete
type.  <b>List[Int]</b> is the type of lists of element type
<b>Int</b>, <b>List[String]</b> is the type of lists of element
type <b>String</b>.

<div class="p"><!----></div>

</body>
</html>