<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>Atomic Block</title>
</head>

<body>
 <h2><a name="tth_sEc6">
6</a>&nbsp;&nbsp;Atomic blocks</h2><a name="AtomicBlocks">
</a>
Languages such as  Java use low-level synchronization locks to allow
multiple interacting threads to coordinate the mutation of shared
data.  X10 eschews locks in favor of a very simple high-level
construct, the <em>atomic block</em>.

<div class="p"><!----></div>
A programmer may use atomic blocks to guarantee that invariants of
shared data-structures are maintained even as they are being accessed
simultaneously by multiple activities running in the same place.

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.1">
6.1</a>&nbsp;&nbsp;Unconditional atomic blocks</h3>
The simplest form of an atomic block is the <em>unconditional
atomic block</em>:

<div class="p"><!----></div>
<pre>
461 Statement ::= AtomicStatement
474 StatementNoShortIf ::= 
       AtomicStatementNoShortIf
482 AtomicStatement ::= atomic  Statement
492 AtomicStatementNoShortIf ::= 
       atomic StatementNoShortIf
445 MethodModifier ::= atomic
</pre>

<div class="p"><!----></div>
For the sake of efficient implementation  X10 v1.01 requires
that the atomic block be <em>analyzable</em>, that is, the set of
locations that are read and written by the <tt>BlockStatement</tt> are
bounded and determined statically.<a href="#tthFtNtAAE" name="tthFrefAAE"><sup>4</sup></a>
The exact algorithm to be used by
the compiler to perform this analysis will be specified in future
versions of the language.


<div class="p"><!----></div>
Such a statement is executed by an activity as if in a single step
during which all other concurrent activities in the same place are
suspended. If execution of the statement may throw an exception, it is
the programmer's responsibility to wrap the atomic block within a
<tt>try/finally</tt> clause and include undo code in the finally
clause. Thus the <tt>atomic</tt> statement only guarantees atomicity on
successful execution, not on a faulty execution.

<div class="p"><!----></div>
We allow methods of an object to be annotated with <tt>atomic</tt>. Such
a method is taken to stand for a method whose body is wrapped within an
<tt>atomic</tt> statement.

<div class="p"><!----></div>
Atomic blocks are closely related to non-blocking synchronization
constructs [7], and can be used to implement 
non-blocking concurrent algorithms.

<div class="p"><!----></div>

<b>Static semantics and dynamic checks.&nbsp;&nbsp;</b>
In <tt>atomic s</tt>, <tt>s</tt> may include method calls, conditionals etc.
It may <em>not</em> include an <tt>async</tt> activity.
It may <em>not</em> include any statement that may potentially block at
runtime (e.g. <tt>when</tt>, <tt>force</tt> operations, <tt>next</tt>
operations on clocks, <tt>finish</tt>).

<div class="p"><!----></div>
All locations accessed in an atomic block must reside <tt>here</tt>
(&#167;&nbsp;6.0.2). A <tt>
BadPlaceException</tt> is thrown if (and
when) this condition is violated.

<div class="p"><!----></div>

<b>Consequences.&nbsp;&nbsp;</b>
Note an important property of an (unconditonal) atomic block:

<div class="p"><!----></div>

<br clear="all" /><table border="0" width="100%"><tr><td>
<table border="0" cellspacing="0" cellpadding="0">
 <tr><td width="50%"></td><td nowrap="nowrap" align="right" colspan="1"><table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
 <tt>atomic</tt>&nbsp;{<tt>s</tt><tt>1</tt>&nbsp;<tt>atomic</tt>&nbsp;<tt>s</tt><tt>2</tt>} </td></tr></table></td><td nowrap="nowrap" align="left">
<table border="0" cellspacing="0" cellpadding="2"><tr><td nowrap="nowrap" align="left">
=</td></tr></table></td><td nowrap="nowrap" align="left">
<table><tr><td nowrap="nowrap" align="right" colspan="1"><tt>atomic</tt>&nbsp;{<tt>s</tt><tt>1</tt>&nbsp;<tt>s</tt><tt>2</tt>}</td></tr></table></td><td width="50%"></td><td width="1" align="right">(1)</td></tr></table>
</td></tr></table>



<div class="p"><!----></div>
Further, an atomic block will eventually terminate successfully or
thrown an exception; it may not introduce a deadlock.

<div class="p"><!----></div>
      <h4><a name="tth_sEc6.1.1">
6.1.1</a>&nbsp;&nbsp;Example</h4>

<div class="p"><!----></div>
The following class method implements a (generic) compare and swap (CAS) operation:

<div class="p"><!----></div>
<pre>
// target defined in lexically enclosing environment.
public atomic boolean CAS( Object old, 
                           Object new) {
   if (target.equals(old)) {
     target = new;
     return true;
   }
   return false;
}
</pre>

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.2">
6.2</a>&nbsp;&nbsp;Conditional atomic blocks</h3>

<div class="p"><!----></div>
Conditional atomic blocks are of the form:
<pre>
465 Statement ::= WhenStatement
475 StatementNoShortIf ::= WhenStatementNoShortIf
483 WhenStatement ::= 
          when ( Expression ) Statement
484      |  WhenStatement 
          or ( Expression ) Statement
</pre>

<div class="p"><!----></div>
In such a statement the one or more expressions are called <em>
guards</em> and must be <tt>boolean</tt> expressions. The statements are the
corresponding <em>guarded statements</em>. The first pair of expression
and statement is called the <em>main clause</em> and the additional pairs
are called <em>auxiliary clauses</em>. A statement must have a main
clause and may have no auxiliary clauses.

<div class="p"><!----></div>
An activity executing such a statement suspends until such time as any
one of the guards is true in the current state. In that state, the
statement corresponding to the first guard that is true is executed.
The checking of the guards and the execution of the corresponding
guarded statement is done atomically. 

<div class="p"><!----></div>
 X10 does not guarantee that a conditional atomic block
will execute if its condition holds only intermmitently. For, based on
the vagaries of the scheduler, the precise instant at which a
condition holds may be missed. Therefore the programmer is advised to
ensure that conditions being tested by conditional atomic blocks are
eventually stable, i.e. they will continue to hold until the block
executes (the action in the body of the block may cause the condition
to not hold any more).

<div class="p"><!----></div>

<div class="p"><!----></div>
The guarantee provided by <tt>wait/notify</tt> in  Java is no
stronger. Indeed conditional atomic blocks may be thought of as a
replacement for  Java's wait/notify functionality.
 

<div class="p"><!----></div>
We note two common abbreviations. The statement <tt>when (true) S</tt> is
behaviorally identical to <tt>atomic S</tt>: it never suspends. Second,
<tt>when (c) {;}</tt> may be abbreviated to <tt>await(c);</tt> - it
simply indicates that the thread must await the occurrence of a
certain condition before proceeding.  Finally note that a <tt>when</tt>
statement with multiple branches is behaviorally identical to a <tt>
when</tt> statement with a single branch that checks the disjunction of
the condition of each branch, and whose body contains an <tt>
if/then/else</tt> checking each of the branch conditions.

<div class="p"><!----></div>

<b>Static semantics.&nbsp;&nbsp;</b>
For the sake of efficient implementation certain restrictions are
placed on the guards and statements in a conditional atomic
block. 

<div class="p"><!----></div>
Guards are required not to have side-effects, not to spawn
asynchronous activities and to have a statically determinable upper
bound on their execution. These conditions are expected to be checked
statically by the compiler.

<div class="p"><!----></div>
The body of a <tt>when</tt> statement must satisfy the conditions
for the body of an <tt>atomic</tt> block.

<div class="p"><!----></div>
Note that this implies that guarded statements are required to be <em>
flat</em>, that is, they may not contain conditional atomic blocks. (The
implementation of nested conditional atomic blocks may require
sophisticated operational techniques such as rollbacks.)

<div class="p"><!----></div>

<b>Sample usage.&nbsp;&nbsp;</b> 
There are many ways to ensure that a guard is eventually
stable. Typically the set of activities are divided into those that
may enable a condition and those that are blocked on the
condition. Then it is sufficient to require that the threads that may
enable a condition do not disable it once it is enabled. Instead the
condition may be disabled in a guarded statement guarded by the
condition. This will ensure forward progress, given the weak-fairness
guarantee.

<div class="p"><!----></div>
     <h3><a name="tth_sEc6.3">
6.3</a>&nbsp;&nbsp;Examples</h3>

<div class="p"><!----></div>

<b>Bounded buffer.&nbsp;&nbsp;</b>
The following class shows how to implement a bounded buffer of size
1 in  X10 for repeated communication between a sender and a
receiver.

<div class="p"><!----></div>
<pre>
class OneBuffer {
  nullable Object datum = null;
  boolean filled = false;
  public 
    void send(Object v) {
      when ( !filled ) {
        this.datum = v;
        this.filled = true;
    }
 }
  public
    Object receive() {
      when ( filled ) {
        Object v  = datum;
        datum = null;
        filled = false;
        return v;
      }
  }
}
</pre>

<div class="p"><!----></div>

<b>Implementing a future with a latch.&nbsp;&nbsp;</b><a name="future-imp">
</a>
The following class shows how to implement a <em>latch</em>. A latch is
an object that is initially created in a state called the <em>
unlatched</em> state. During its lifetime it may transition once to a <em>
forced</em> state. Once forced, it stays forced for its lifetime. The
latch may be queried to determine if it is forced, and if so, an
associated value may be retrieved. Below, we will consider a latch set
when some activity invokes a <tt>setValue</tt> method on it. This method
provides two values, a normal value and an exceptional value. The
method <tt>force</tt> blocks until the latch is set. If an exceptional
value was specified when the latch was set, that value is thrown on
any attempt to read the latch. Otherwise the normal value is returned.

<div class="p"><!----></div>
<pre>
public interface future {
   boolean forced();
   Object force();
}
public class Latch implements future {
  protected boolean forced = false;
  protected nullable boxed result = null;
  protected nullable exception z = null;

<div class="p"><!----></div>
  public atomic 
   boolean setValue( nullable Object val ) {
   return setValue( val, null);
    }
   public atomic 
   boolean setValue( nullable exception z ) {
        return setValue( null, z);
    }
    public atomic 
    boolean setValue( nullable Object val, 
                      nullable exception z ) {
        if ( forced ) return false;
        // these assignment happens only once.
        this.result = val;
        this.z = z;
        this.forced = true;
        return true;
    }
    public atomic boolean forced() {
        return forced;
    }
    public Object force() {
        when ( forced ) {
            if (z != null) throw z;
            return result;
        }
    }
}
</pre>

<div class="p"><!----></div>
Latches, <tt>aync</tt> operations and <tt>finish</tt> operations may be used
to implement futures as follows. The expression <tt>future(P) {e} </tt>
can be translated to:
<pre>
  new RunnableLatch() {
      public Latch run() {
         Latch L = new Latch();
         async ( P ) {
            Object X;
            try {
                finish X = e;
                async ( L ) {
                   L.setValue( X ); 
                }
            } catch ( exception Z ) {
               async ( L ) {
                 L.setValue( Z );
               }
            }
         }
         return l;
      }
    }.run()
</pre>

<div class="p"><!----></div>
Here we assume that <tt>RunnableLatch</tt> is an interface defined by:
<pre> 
  public interface RunnableLatch {
     Latch run();
  }
</pre>

<div class="p"><!----></div>
We use the standard  Java idiom of wrapping the core translation
inside an inner class definition/method invocation pair (i.e. <tt>
new RunnableLatch() .....run()</tt>) so as to keep the resulting
expression completely self-contained, while executing statements
inside the evaluation of an expression.

<div class="p"><!----></div>
Execution of a <tt>future(P) {e}</tt> causes a new latch to be created,
and an <tt>async</tt> activity spawned at <tt>P</tt>. The activity attempts
to <tt>finish</tt> the assigned <tt>x = e</tt>, where <tt>x</tt> is a local
variable.  This may cause new activities to be spawned, based on <tt>
e</tt>. If the assignment terminates successfully, another activity is
spawned to invoke the <tt>setValue</tt> method on the latch.  Exceptions
thrown by these activities (if any) are accumulated at the <tt>
finish</tt> statement and thrown after global termination of all
activities spawned by <tt>x=e</tt>. The exception will be caught by the 
<tt>catch</tt> clause and stored with the latch. 

<div class="p"><!----></div>

<b>A future to execute a statement.&nbsp;&nbsp;</b>
Consider an expression <tt>onFinish {S}</tt>. This should return a <tt>
boolean</tt> latch which should be forced when <tt>S</tt> has terminated
globally. Unlike <tt>finish S</tt>, the evaluation of <tt>onFinish
{S}</tt> should locally terminate immediately, returning a latch. The
latch may be passed around in method invocations and stored in
objects. An activity may perform <tt>force</tt>/<tt>forced</tt> method
invocations on the latch whenever it desires to determine whether <tt>S</tt>
has terminated.

<div class="p"><!----></div>
Such an expression can be written as:
<pre>
  new RunnableLatch() {
      public Latch run() {
         Latch L = new Latch();
         async ( here ) {
            try {
                finish S;
                L.setValue( true );
            } catch ( exception Z ) {
                 L.setValue( Z );
            }
         }
         return L;
      }
    }.run()
</pre>
</body>
</html>