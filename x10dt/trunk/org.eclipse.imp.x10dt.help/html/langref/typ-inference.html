<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
<title>Type inference</title>
</head>

<body>
 <h2><a name="tth_sEc11">
11</a>&nbsp;&nbsp;Type inference</h2>
<a name="TypeInference">
</a>



<div class="p"><!----></div>
X10 v2.0 supports limited local type inference, permitting
certain variable types and return types to be elided.
It is a static error if an omitted type cannot be inferred or
uniquely determined.

<div class="p"><!----></div>
     <h3><a name="tth_sEc11.1">
11.1</a>&nbsp;&nbsp;Variable declarations</h3>

<div class="p"><!----></div>
The type of a <b>val</b> variable declaration can be omitted if the
declaration has an initializer.  The inferred type of the
variable is the computed type of the initializer.
For example, 
<b>val seven = 7;</b>
is identical to 
<b>val seven: Int{self==7} = 7;</b>
Note that type inference gives the most precise X10 type, which might be more
specific than the type that a programmer would write.

<div class="p"><!----></div>
<em><em>Limitation</em> At the moment, only <b>val</b> declarations can have their types
elided in this way.  
</em>

<div class="p"><!----></div>
     <h3><a name="tth_sEc11.2">
11.2</a>&nbsp;&nbsp;Return types</h3>

<div class="p"><!----></div>
The return type of a method can be omitted if the method has a body (, is
not <b>abstract</b> or <b>native</b>). The inferred return type is the computed
type of the body.  In the following example, the return type inferred for
<b>isTriangle</b> is 
<b>Boolean{self==false}</b>
<pre>
class Shape {
  def isTriangle() = false; 
}  
</pre>
Note that, as with other type inference, methods are given the most specific
type.  In many cases, this interferes with subtyping.  For example, if one
tried to write: 
<pre>
class Triangle extends Shape {
  def isTriangle() = true;
}
</pre>

the X10 compiler would reject this program for attempting to override
<b>isTriangle()</b> by a method with the wrong type, ,
<b>Booleanself==true</b>.  In this case, supply the type that is actually
intended for <b>isTriangle</b>, such as 
<b>def isTriangle() :Boolean =false;</b>. 

<div class="p"><!----></div>
The return type of a closure can be omitted.
The inferred return type is the computed type of the body.

<div class="p"><!----></div>
The return type of a constructor can be omitted if the
constructor has a body.
The inferred return type is the enclosing class type with
properties bound to the arguments in the constructor's <b>property</b>
statement, if any, or to the unconstrained class type.
For example, the <b>Spot</b> class has two constructors, the first of which has
inferred return type <b>Spot{x==0}</b> and the second of which has 
inferred return type <b>Spotx==xx</b>. 
<pre>
class Spot(x:Int) {
  def this() {property(0);}
  def this(xx: Int) { property(xx); }
}
</pre>

<div class="p"><!----></div>
A method or closure that has expression-free <b>return</b> statements
(<b>return;</b> rather than <b>return e;</b>) is said to return <b>Void</b>.
<b>Void</b> is not a type; there are no <b>Void</b> values, nor can <b>Void</b>
be used as the argument of a generic type. However, <b>Void</b> takes the
syntactic place of a type. A method returning <b>Void</b> can be specified by
<b>def m():Void</b>: 

<div class="p"><!----></div>
<pre>
val f : () =&#62; Void = () =&#62; {return;};
</pre>

<div class="p"><!----></div>
By a convenient abuse of language, <b>Void</b> is sometimes
lumped in with types; , we may say "return type of a method" rather than
the formally correct but rather more awkward "return type of a method, or
<b>Void</b>".   Despite this informal usage, <b>Void</b> is not a type.  For
example, given 
<pre>
  static def eval[T] (f:()=&#62;T):T = f();
</pre>

The call <b>eval[Void](f)</b> does <em>not</em> typecheck; <b>Void</b> is not a
type and thus cannot be used as a type argument.  There is no way in X10 to
write a generic function which works with both functions which return a value
and functions which do not.  In most cases, functions which have no sensible
return value can be provided with a dummy return value.

<div class="p"><!----></div>
     <h3><a name="tth_sEc11.3">
11.3</a>&nbsp;&nbsp;Type arguments</h3>

<div class="p"><!----></div>
<em><em>Limitation</em> This does not seem to work at all currently.</em>


<div class="p"><!----></div>
A call to a polymorphic method %, closure, or constructor 
may omit the
explicit type arguments.  If the method has a type parameter
<b>T</b>, the type argument corresponding to <b>T</b> is inferred
to be the least common ancestor of the types of any formal
parameters of type <b>T</b>.


<div class="p"><!----></div>
Consider the following method:
<pre>
def choose[T](a: T, b: T): T { ... }
</pre>
Given <b>Set[T] &lt;: Collection[T]</b>, 
<b>List[T] &lt;: Collection[T]</b>,
and <b>SubClass &lt;: SuperClass</b>,
in the following snippet, the algorithm will infer the type
<b>Collection[Any]</b> for <b>x</b>.
<pre>
def m(intSet: Set[Int], stringList: List[String]) {
  val x = choose(intSet, stringList);
...
}
</pre>
And in this snippet, the algorithm should infer the type
<b>Collection[Int]</b> for <b>y</b>.
<pre>
def m(intSet: Set[Int], intList: List[Int]) {
  val y = choose(intSet, intList);
  ...
}
</pre>
Finally, in this snippet, the algorithm should infer the type
<b>CollectionT &lt;: SuperClass</b> for <b>z</b>.
<pre>
def m(intSet: Set[SubClass], numList: List{T &lt;: SuperClass}) {
  val z = choose(intSet, numList);
  ...
}
</pre>

<div class="p"><!----></div>

<div class="p"><!----></div>
</li>
<hr /><h3>Footnotes:</h3>

<div class="p"><!----></div>
<a name="tthFtNtAAB"></a><a href="#tthFrefAAB"><sup>1</sup></a>Objects but no structs.  If we
had wanted structs too, we could have used a <b>Cell[Any]</b>.
<div class="p"><!----></div>
<a name="tthFtNtAAC"></a><a href="#tthFrefAAC"><sup>2</sup></a>Currently inequalities
      of the form <b>e &lt; f</b> are not supported.
<div class="p"><!----></div>
<a name="tthFtNtAAD"></a><a href="#tthFrefAAD"><sup>3</sup></a>We call them
<b>Position</b> to avoid confusion with the built-in class <b>Point</b>
<div class="p"><!----></div>
<a name="tthFtNtAAE"></a><a href="#tthFrefAAE"><sup>4</sup></a>Java, for one, suffers a number of
  inconveniences because some built-in types like <b>int</b> and <b>char</b>
  aren't subtypes of anything else.
<div class="p"><!----></div>
<a name="tthFtNtAAF"></a><a href="#tthFrefAAF"><sup>5</sup></a>The behavioral annotation <b>property</b> is
  explained in &#167;<a href="#properties">1.3</a>; <b>safe</b> in &#167; , and
  <b>global</b> in &#167; .

</body>
</html>