<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
<title>Common ancestor of types</title>
</head>

<body>
 <h2><a name="tth_sEc9">
9</a>&nbsp;&nbsp;Common ancestors of types</h2>
<a name="LCA">
</a>

<div class="p"><!----></div>
There are several situations where X10 must find a type <b>T</b> that describes
values of two or more different types.  This arises when X10 is trying to find
a good type to describe: 

<ul>
<li> Conditional expressions, like <b>test ? 0 : "non-zero"</b> or even 
      <b>test ? 0 : 1</b>;
<div class="p"><!----></div>
</li>

<li> ValRail construction, like <b>[0, "non-zero"]</b> and 
      <b>[0,1]</b>;
<div class="p"><!----></div>
</li>

<li> Functions with multiple returns, like
<pre>
def f(a:Int) {
  if (a == 0) return 0;
  else return "non-zero";
}
</pre>

<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>
In some cases, there is a unique best type describing the expression.  For
example, if <b>B</b> and <b>C</b> are direct subclasses of <b>A</b>, <b>pick</b>
will have return type <b>A</b>: 
<pre>
static def pick(t:Boolean, b:B, c:C) = t ? b : c;  
</pre>

<div class="p"><!----></div>
However, in many common cases, there is no unique best type describing the
expression.  For example, consider the expression E= <b>b ? 0 : 1</b>.  The
best type of <b>0</b> 
is <b>Int{self==0}</b>, and the best type of 1 is <b>Int{self==1}</b>.
Certainly E could be given the type <b>Int</b>, or even <b>Any</b>, and that
would describe all possible results.  However, we actually know more.
<b>Int{self != 2}</b> is a better description of the type of E-certainly
the result of E can never be <b>2</b>.   <b>Int{self != 2, self != 3}</b> is
an even better description; E can't be <b>3</b> either.  We can continue
this process forever, adding integers which E will definitely not return
and getting better and better approximations. (If the constraint
sublanguage had <b></td><td width="150">
&#124;</td><td width="150">
&#124;</b>, we could give it the type 
<b>Int{self == 0 </td><td width="150">
&#124;</td><td width="150">
&#124; self == 1}</b>, which would be nearly perfect.  But 
<b></td><td width="150">
&#124;</td><td width="150">
&#124;</b> makes typechecking far more expensive, so it is excluded.)
No X10 type is the best description of E; there is always a better one.

<div class="p"><!----></div>
Similarly, consider two unrelated interfaces: 
<pre>
interface I1 {}
interface I2 {}
class A implements I1, I2 {}
class B implements I1, I2 {}
class C {
  static def example(t:Boolean, a:A, b:B) = t ? a : b;
}
</pre>
<b>I1</b> and <b>I2</b> are both perfectly good descriptions of <b>t ? a : b</b>, 
but neither one is better than the other, and there is no single X10 type
which is better than both. (Some languages have <em>conjunctive
    types</em>, and could say that the return type of <b>example</b> was 
<b>I1 &amp;&amp; I2</b>.  This, too, complicates typechecking.)

<div class="p"><!----></div>
</li>


<div class="p"><!----></div>
So, when confronted with expressions like this, X10 computes <em>some</em>
satisfactory type for the expression, but not necessarily the <em>best</em> type.  
X10 provides certain guarantees about the common type <b>V{v}</b> computed for 
<b>T{t}</b> and <b>U{u}</b>: 

<ul>
<li> If <b>T{t} == U{u}</b>, then <b>V{v} == T{t} == U{u}</b>.  So, if X10's
      algorithm produces an utterly untenable type for <b>a ? b : c</b>, and
      you want the result to have type <b>T{t}</b>, you can 
      (in the worst case) rewrite it to 
      <b>a ? b as T{t} : c as T{t}</b>.
<div class="p"><!----></div>
</li>

<li> If <b>T == U</b>, then <b>V == T == U</b>.  For example, 
      X10 will compute the type of <b>b ? 0 : 1</b> as 
      <b>Int{c}</b> for some constraint <b>c</b>-perhaps simply 
      picking <b>Int{true}</b>, , <b>Int</b>.
<div class="p"><!----></div>
</li>

<li> X10 preserves place information, because it is so important. If both
      <b>t</b> and <b>u</b> entail <b>self.home==p</b>, then  
      <b>v</b> will also entail <b>self.home==p</b>.  In particular, the common
      type for <b>T!</b> and <b>U!</b> has the form <b>V!</b>.
<div class="p"><!----></div>
</li>

<li> X10 similarly preserves nullity information.  If <b>t</b> and <b>u</b>
      both entail <b>x == null</b> or <b>x != null</b> for some variable
      <b>x</b>, then <b>v</b> will also entail it as well.
<div class="p"><!----></div>
</li>
</ul>

<div class="p"><!----></div>

<div class="p"><!----></div>

</body>
</html>