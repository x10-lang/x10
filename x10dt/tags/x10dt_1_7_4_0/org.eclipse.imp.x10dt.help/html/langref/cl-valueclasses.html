<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
<meta name="GENERATOR" content="TtH 3.80">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
	<title>Value classes</title>
</head>

<body>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;Value classes</h2><a name="ValueClasses">
</a>

<div class="p"><!----></div>
 X10 singles out a certain set of classes for additional
support. A class is said to be <em>stateless</em> if all of its fields
are declared to be "final" (), otherwise it
is <em>stateful</em>. ( X10 has syntax for specifying an array class
with final fields, unlike  Java.) A <em>stateless (stateful)
object</em> is an instance of a stateless (stateful) class.

<div class="p"><!----></div>
 X10 allows the programmer to signify that a class (and all its
descendents) are stateless. Such a class is called a <em>value
class</em>.  The programmer specifies a value class by prefixing the
modifier "value" before the keyword "class" in a class
declaration.  (A class not declared to be a value class will be called
a <em>reference class</em>.)  Each instance field of a value class is
treated as "final". It is legal (but neither required nor recommended)
for fields in a value class to be declared final. For brevity, the  X10
compiler allows the programmer to omit the keyword "class" after
" value" in a value class declaration.

<div class="p"><!----></div>
<em>  
<table>
<tr><td align="right">ValueClassDeclaration &nbsp;::=&nbsp; 
      ClassModifiers<sup>?</sup>&nbsp;<tt>value class </tt><sup>?</sup>&nbsp;Identifier  </td></tr>
<tr><td align="right"></td><td align="center"></td><td>TypePropertyList<sup>?</sup>&nbsp;PropertyList<sup>?</sup>&nbsp;Guard<sup>?</sup>&nbsp;</td></tr>
<tr><td align="right"></td><td align="center"></td><td>Super<sup>?</sup>&nbsp;Interfaces<sup>?</sup>&nbsp;ValueClassBody </td></tr>
<tr><td align="right"></td></tr></table>
</em>


<div class="p"><!----></div>
The "Box" type constructor () can
be used to declare variables whose value may be "null" or a value
type.

<div class="p"><!----></div>
Stable equality for value types is defined through a deep walk,
bottoming out in fields of reference types ().

<div class="p"><!----></div>
It is a compile-time error for a value class to inherit from a
stateful class or for a reference class to inherit from a value
class. All fields of a value class are implicitly declared "final".


<div class="p"><!----></div>
     <h3><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;Representation</h3>

<div class="p"><!----></div>
Since value objects do not contain any updatable locations, they can
be freely copied from place to place. An implementation may use
copying techniques even within a place to implement value types,
rather than references. This is transparent to the programmer.

<div class="p"><!----></div>
More explicitly,  X10 guarantees that an implementation must always
behave as if a variable of a reference type takes up as much space as
needed to store a reference that is either null or is bound to an
object allocated on the (appropriate) heap. However,  X10 makes no
such guarantees about the representation of a variable of value
type. The implementation is free to behave as if the value is stored
"inline", allocated on the heap (and a reference stored in the
variable) or use any other scheme (such as structure-sharing) it may
deem appropriate. Indeed, an implementation may even dynamically
change the representation of an object of a value type, or dynamically
use different representations for different instances (that is,
implement automatic box/unboxing of values).

<div class="p"><!----></div>
Implementations are strongly encouraged to implement value types as
space-efficiently as possible (e.g., inlining them or passing them in
registers, as appropriate).  Implementations are expected to cache
values of remote final value variables by default. If a value is
large, the programmer may wish to consider spawning a remote activity
(at the place the value was created) rather than referencing the
containing variable (thus forcing it to be cached).

<div class="p"><!----></div>
A functional "LinkedList" program may be written as follows:

<div class="p"><!----></div>
<pre>
value LinkedList { 
  val first: Object;
  val rest: LinkedList;
  public def this(first: Object) { 
     this(first, null);
  }
  public def this(first: Object, rest: LinkedList) { 
    this.first = first;
    this.rest = rest;
  }
  public def first(): Object { 
    return first;
  }
  public def rest(): LinkedList { 
    return rest;
  } 
  public def append(l: LinkedList): LinkedList { 
    return (this.rest == null) 
        ? new LinkedList(this.first, l) 
        : this.rest.append(l);
  }
}
</pre>

<div class="p"><!----></div>
Similarly, a "Complex" class may be implemented as follows:
<pre>
value Complex { 
  re: Double;
  im: Double;
  public def this(re: Double, im: Double) {
     this.re=re;
     this.im=im;
  }
  public def add(other: Complex): Complex {
    return new Complex(this.re+other.re,
                       this.im+other.im);
  }
  public def mult(other: Complex): Complex {
    return new Complex(this.re^2-other.re^2,
                       2*this.im*other.im);
  }
  ...
}
</pre>


<div class="p"><!----></div>
</body>
</html>